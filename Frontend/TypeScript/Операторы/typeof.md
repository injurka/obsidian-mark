Механизм _запроса типа_ (Type Queries) позволяет получить тип, связанный со значением по его идентификатору и в дальнейшим использовать его как обычный тип. Запрос типа осуществляется оператором `typeof`, после которого идет идентификатор, ссылающийся на значение. Запрос типа также может располагаться в местах указания типа.

```ts
let v1: T1;
let v2: typeof v1; // let v2: T1;
```

С помощью данного механизма можно получить тип любой конструкции, будь то переменная, параметр функции или метода, а также член объекта и класса.

```ts
class T {
  static staticProp: number;

  field: string;

  get prop(): boolean {
    return true;
  }

  method(): void {}
}

let t: T = new T();

let v0: typeof t; // let v0: T
let v1: typeof T.staticProp; // // let v1: number
let v2: typeof t.field; // let v2: string
let v3: typeof t.prop; // let v3: boolean
let v4: typeof t.method; // let v4: ()=>void

function f(param: number): void {
  let v: typeof param; // let v: number
}
```

Запрос типа может быть очень полезен сторонникам минимализма, достигаемого при помощи вывода типов. К слову, я один из них. Тем, кто придерживается консерватизма, возможно, придется по душе идея ускорять написание тестов за счет механизма вывода типов. Ведь в тех ситуациях, когда для тестирования требуются не определенные в приложении типы данных, часто не хочется тратить время на их декларацию, но при этом хочется использовать автодополнение. Например, при тестировании метода класса может понадобиться тип, представляющий только его, но, поскольку для проекта подобный тип просто бессмыслен, его придется определять в контексте самих тестов, что гораздо проще сделать при помощи механизма запроса типа. Все это вместе в _TypeScript_ становится возможным благодаря выводу типов в паре с оператором запроса типа.

Представьте значение, присвоенное переменной, тип которой не указан явно. Теперь представьте, что это значение нужно передать в функцию, параметр которой также не имеет явного указания типа. В этом случае в функции будет сложно работать с параметрами, так как вывод типов определит его принадлежность к типу `any`.

```ts
const STANDART_NORMAL = { x: 0, y: 0 }; // данные, которые нужны только для контролирования точности самих тестов, а это в свою очередь означает, что декларация типов для них ещё не определена. Хотя вывод типов в состоянии вывести тип {x: number, y: number} для этой константы.

// здесь вывод типа не в состоянии вывести тип параметров функции
function valid(standart) {
  let element = document.querySelector('#some-id');
  let { clientLeft: x, clientTop: y } = element;
  let position = { x, y };

  // поэтому о параметрах невозможно получить какую-либо информацию
  // автодополнение отсутствует
  // let isPositionXValid = position.x === standart.
  // let isPositionYValid = position.y === standart.
  // автодополнение отсутствует

  // ...
}
```

Не стоит даже рассуждать, оставить так или указать типы, которые, возможно, предварительно нужно ещё задекларировать. Вместо этого нужно прибегнуть к механизму _запроса типа_. Запрос типа позволяет одновременно решить две задачи, одна из которых связана с проблемами, сопутствующими типу `any`, а другая — минимализму и расходу времени на декларирование типов.

```ts
const STANDART_NORMAL = { x: 0, y: 0 };

// получение типа для аннотирования параметров прямо из константы.
function valid(standart: typeof STANDART_NORMAL) {
  let element = document.querySelector('#some-id');
  let { clientLeft: x, clientTop: y } = element;
  let position = { x, y };

  // расходовать время на декларацию типа так и не пришлось. Тем не менее, автодополнение работает.
  let isPositionXValid = position.x === standart.x; // выводит .x
  let isPositionYValid = position.y === standart.y; // выводит .y

  // ...
}
```