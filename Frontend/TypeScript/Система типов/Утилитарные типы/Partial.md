> сделать все члены объекта необязательными

Сопоставимый тип `Partial<T>` добавляет членам объекта модификатор `?:`, делая их таким образом необязательными.

```ts
// lib.es6.d.ts

type Partial<T> = {
  [P in keyof T]?: T[P];
};
```

Тип сопоставления `Partial<T>` является гомоморфным и не влияет на существующие модификаторы, а лишь расширяет модификаторы конкретного типа.

```ts
interface IPerson {
  readonly name: string; // поле помечено как только для чтения
}

/**
 * добавлен необязательный модификатор
 * и при этом сохранен модификатор readonly
 *
 * type Person = {
 *  readonly name?: string;
 * }
 */
type Person = Partial<IPerson>;
```

Представьте приложение, зависящее от конфигурации, которая как полностью, так и частично, может быть переопределена пользователем. Поскольку работоспособность приложения завязана на конфигурации, члены, определенные в типе, представляющем её, должны быть обязательными. Но поскольку пользователь может переопределить лишь часть конфигурации, функция, выполняющая её слияние с конфигурацией по умолчанию, не может указать в аннотации типа уже определенный тип, так как его члены обязательны. Описывать новый тип слишком утомительно. В таких случаях необходимо прибегать к помощи `Partial<T>`.

```ts
interface IConfig {
  domain: string;
  port: '80' | '90';
}

const DEFAULT_CONFIG: IConfig = {
  domain: `https://domain.com`,
  port: '80',
};

function createConfig(config: IConfig): IConfig {
  return Object.assign({}, DEFAULT_CONFIG, config);
}

/**
 * Error -> Поскольку в типе IConfig все
 * поля обязательные, данную функцию
 * не получится вызвать с частичной конфигурацией.
 */
createConfig({
  port: '80',
});

function createConfig(config: Partial<IConfig>): IConfig {
  return Object.assign({}, DEFAULT_CONFIG, config);
}

/**
 * Ok -> Тип Partial<T> сделал все члены,
 * описанные в IConfig необязательными,
 * поэтому пользователь может переопределить
 * конфигурацию частично.
 */
createConfig({
  port: '80',
});
```