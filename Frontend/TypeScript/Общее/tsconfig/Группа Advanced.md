Группа опция относящаяся к строгости компиляции:

```json
{
  "compilerOptions": {
    "allowUnreachableCode": false,
    "allowUnusedLabels": false,
    
    "noImplicitUseStrict": false,
    "suppressExcessPropertyErrors": false,
    "suppressImplicitAnyIndexErrors": false,
    "noStrictGenericChecks": false,
  }
}
```

Первые два флага `allowUnreachableCode` и `allowUnusedLabels` опять отделены пустой строкой не случайно – они отбились от `Linter Checks`.

**_Внезапно по умолчанию эти флаги имеют значение_** `true`, однако для строгости должны быть `false` – ровно наоборот.

Запомнить это поведение достаточно легко. У предыдущих опций такого рода в названиях фигурировал префикс `no`, т. е. «запретить допущения». У данных же флагов префикс `allow` – «разрешить допущения». По-хорошему для консистентности стоит переименовать эти опции в `noUnreachableCode` и `noUnusedLabels` и отправить в соответствующую группу.

Остальные флаги: `noImplicitUseStrict`, `noStrictGenericChecks`, `suppressExcessPropertyErrors` и `suppressImplicitAnyIndexErrors` можно было бы вынести в новую группу и назвать её `Base Strict Checks.` И вот почему:

**_Эти флаги по умолчанию_** `false` и должны быть `false` для строгости!

Вот мы и нашли те опции, которые включены по умолчанию и составляют типобезопасность TypeScript из коробки!

По сути, вышеперечисленные опции (кроме `noImplicitUseStrict`) включают явные нарушения типизации, что в некоторых случаях можно использовать как временное решение при портировании сложных участков кода с JavaScript.

_Ни один флаг из данной четвёрки не придётся переопределять в 99.9% случаев._

## allowUnreachableCode

> Рекомендую: всегда для production / сложность: легко / правило ESLint: `no-unreachable`, пока не реализовано

Флаг запрещает недосягаемый код – код, написанный после операторов return, throw, break, continue:

```ts
function fn (n: number) {
  if (n > 5) {
    return true
  } else {
    return false
  }

  // недосягаемый код
  return true
}
```

Данный флаг будет удобно выключать для `development`. Аналогично правилу линтера `no-unreachable`, которое не реализовано для TypeScript.

## allowUnusedLabels

> Рекомендую: для production если не используется ESLint / сложность: легко / правило ESLint: no-unused-labels

Опция запрещает неиспользуемые [лэйблы](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label). Не думаю, что можно встретить данную синтаксическую конструкцию в наши дни, но тем не менее:

```ts
function verifyAge (age: number) {
  if (age > 18) {
    // тот самый неиспользуемый label
    verified: true
  }
}
```

Заменим правилом линтера `no-unused-labels`.

## noImplicitUseStrict

> Настроен по умолчанию, изменять противопоказано / связан с `alwaysStrict`

Флаг автоматически добавляет `"use strict"` если `target` версия меньше, чем `ES6`. Опция `alwaysStrict` в свою очередь делает тоже самое, но для любых `target`. Вряд ли когда-нибудь возникнет необходимость переопределять значение данного флага.

_Если же обоим флагам_ `noImplicitUseStrict` и `alwaysStrict` установить значение `true`, то возникнет ошибка компиляции, так как настройки противоречат друг другу.

## suppressExcessPropertyErrors

> Настроен по умолчанию, изменять противопоказано

Флаг проверяет, чтобы объект не мог содержать свойства, которые не были описаны в его структуре:

```ts
interface Point {
  x: number
  y: number
}

const p: Point = {
  x: 1,
  y: 3,
  // свойство z не объявлено в интерфейсе Point
  z: 10
}
```

Можно временно выключать данную настройку при миграции кодовой базы с JavaScript, если в коде много подобных моментов. Но после нужно обязательно восстановить исходное значение. Для разовых инцидентов лучше использовать `// @ts-ignore`.

## suppressImplicitAnyIndexErrors

> Настроен по умолчанию, изменять противопоказано / связан с `noImplicitAny`

Флаг проверяет, что используя скобочную нотацию невозможно обращаться к свойствам объекта, которые в нём не объявлены ни явно, ни через произвольные параметры. Вспомним пример флага `noUncheckedIndexedAccess` и удалим из него произвольные параметры:

```ts
interface User {
  // явно указанные параметры
  login: string
  email: string

  // закомментируем произвольные параметры
  // [key: string]: string
}

const user: User = {
  login: 'hello',
  email: 'hello@example.com'
}

// теперь обратиться к name нельзя
const username = user['name']
```

Казалось бы, другого поведения здесь и быть не может. Но как я и говорил, последняя четвёрка флагов порой разрешает включить нарушение типизации для каких-то крайних случаев. Например, данный флаг часто инвертируют, когда не знают, как расширять встроенные в TypeScript тайпинги или тайпинги внешних библиотек. Это плохая практика и в таких случаях правильно использовать `declaration merging`.

Рассмотрим пример. Мы подключили некую библиотеку, допустим Google Maps, через тэг script. Попробуем создать объект Pin:

```ts
const pin = new window.google.maps.Pin(59.9386, 30.3141)
```

Конечно, здесь будет ошибка, так как встроенные тайпинги ничего не знают о свойстве google. Использовать `// @ts-ignore` проблематично, так как его придётся писать чуть ли на каждой строчке кода. Поэтому часто можно встретить такое решение – ставим `suppressImplicitAnyIndexErrors: true` (разрешить допущение) и пишем код следующим образом:

```ts
const pin = new window['google']['maps']['Pin'](59.9386, 30.3141)
```

Это имеет место быть в проектах на промежуточной стадии портирования. Но я бы не рекомендовал прибегать к подобной практике даже в этом случае. Подобная проблема решается использованием объединения деклараций:

```ts
// произвольный файл merging.d.ts
interface Pin {
  // описание
}

interface PinConstructor {
  new(lat: number, lng: number): Pin
}

interface Window {
  google: {
    maps: {
      Pin: PinConstructor
    }
  }
}

// использование в коде
const pin = new window.google.maps.Pin(59.9386, 30.3141)
```

Данная практика применима и к внешним библиотекам, например для расширения `req` и `res` объектов фреймворка Express.

## noStrictGenericChecks

> Настроен по умолчанию, изменять противопоказано

Переопределение данного флага может сделать компилятор «более лояльным» при работе с `generics`:

```ts
type A = <T, U>(x: T, y: U) => [T, U]
type B = <S>(x: S, y: S) => [S, S]

function f (a: A, b: B) {
  // OK
  b = a
  // должна быть ошибка, но компилятор проигнорирует
  a = b
}
```


## Источники
- #### [habr](https://habr.com/ru/articles/557738/)
