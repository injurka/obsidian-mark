Флаги данной категории
- `strict`
- `alwaysStrict`
- `noImplicitAny`
- `strictNullChecks`
- `strictFunctionTypes`
- `strictPropertyInitialization`
- `noImplicitThis`
- `strictBindCallApply`

**_Все вышеперечисленные флаги по умолчанию имеют значение_** `false`, а для того, чтобы было строго нужно установить противоположное значение – `true`.

## alwaysStrict

> Рекомендован: всегда / сложность: легко

Флаг `alwaysStrict` включает добавление строки `"use strict"` в каждый скомпилированный файл. Другими словами, `alwaysStrict` включает [строгий режим JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode) и никак не связан с проверкой типов TypeScript.

## strict

> Рекомендован: всегда / сложность: сложно / может быть заменён набором других флагов

Флаг `strict` напрямую связан с проверкой типов. Его включение автоматически активирует абсолютно все флаги секции `Strict Checks`, включая и `alwaysStrict`. Это именно то, о чём я говорил в самом начале.

У такого подхода есть как минимум один недостаток – неочевидность. Устанавливая `strict: true`, нет наглядного представления, какие именно проверки включены и какие опции вообще существуют. Для проектов, которые с самого начала пишутся на TypeScript это не так принципиально, как для проектов, которые поэтапно портируются с JavaScript.

В процессе портирования существующего приложения нет возможности сразу включить все проверки. Приходится активировать их по одной шаг за шагом. Иногда даже случаются сложности, из-за которых приходится откатывать ранее установленные флаги обратно в `false`.

Есть небольшая особенность работы флага `strict` – список подконтрольных ему флагов может пополняться по мере выхода новых версий TypeScript. Подобные моменты если случаются, то редко и всегда освещаются в release notes если, конечно, вы их читаете перед обновлением версии.


## noImplicitAny

> Рекомендую: всегда / сложность: средне

Для начала несколько слов про `any`. Это специальный тип, который назначается всем переменным, если их тип не был задан явно и не может быть выведен компилятором автоматически. Данный тип создан для обратной совместимости с JavaScript. С точки зрения TypeScript, все переменные в JavaScript это `any`, поскольку в нём нет системы типов.

Для компилятора тип `any` означает «это может быть что угодно, передаю управление и ответственность разработчику». Так как компилятор не знает тип переменной, с такой переменной можно делать всё что угодно. В этом месте TypeScript полностью лишён своей силы:

```ts
// тип задан явно
let a: number = 5
// тип выведен
let b = 'hello'

// тип не указан и не может быть выведен
// value будет неявно объявлено как any
function someFunction (value) {
  // поэтому ошибка в этой строке останется незамеченной
  console.log(value.subtr(3))
}
```

Иначе говоря, если тип переменной не определён, значит он `any`, значит это JavaScript, а не TypeScript код. Т. е. количество неопределённых типов в коде, является реальным показателем отношения TypeScript кода к JavaScript коду. Флаг `noImplicitAny` подсвечивает все такие места, для того чтобы разработчик не забывал указывать типы.

Однако это не означает, что теперь вовсе нельзя использовать `any`. Это означает лишь, что в подобных ситуация разработчик должен явно писать `any`, если по каким-то причинам не получается правильно описать тип переменной или если указание типа переменной приводит к ошибкам в другом участке кода.

```ts
// явно помечаем код как потенциально не безопасный через any
function someFunction (value: any) {
  console.log(value.subtr(3))
}
```

Явное присутствие `any` напоминает разработчику о том, что код не доработан и эти места должны быть улучшены со временем. В этом заключается суть флага `noImplicitAny`.

Дополнительно усилить эффект можно включив ESLint правило `no-explicit-any`. Правило будет отмечать места с `any` как warning, каждый раз привлекая внимание разработчика.

## strictNullChecks

> Рекомендую: всегда / сложность: средне

Флаг активирует одну из самых мощных особенностей TypeScript. Рекомендую включить его сразу после `noImplicitAny`.

JavaScript содержит два нижних значения – `undefined` и `null`, для которых в TypeScript есть одноимённые типы. По иерархии считается, что все остальные типы происходят от них. Таким образом по принципу наследования вместо переменной любого типа: `string`, `boolean`, `number` и т. д – можно передать значение `undefined` или `null`:

```ts
function someFunction (value: number) {
  // можно получить неожиданный результат если value будет undefined или null
  return value * 2
}

someFunction(5)
// по умолчанию можно так
someFunction(null)
// и можно так
someFunction(undefined)
```

Подобное поведение справедливо для почти всех (если не всех) языков программирования. На практике это может вызывать неудобства в виде написания дополнительных проверок на `null` (`undefined`). Но гораздо большей проблемой является помнить о необходимости покрывать код данными проверками. Думаю, Java разработчики с их [NullPointerException](https://careerkarma.com/blog/java-null-pointer-exception/) как никто другой понимают эту проблему.

Включение опции `strictNullChecks` меняет правила игры. С данным флагом компилятор больше не позволяет передавать `undefined` или `null` туда, где ожидаются переменные других типов, если это не разрешено явно. Рассмотрим пример:

```ts
function someFunction (value: number) {
  // value всегда будет только number
  return value * 2
}

someFunction(5)
// следующие вызовы функции невозможны
someFunction(null)
someFunction(undefined)
```

Это позволяет не обрабатывать ситуации с `undefined` и `null` в тех участках кода, где возникновение данных значений невозможно. При этом в тем местах, где возникновение подобных ситуаций возможно, компилятор не позволит забыть о проверках. Это очень сильный механизм, существование которого сложно переоценить.

```ts
// Символ «?» разрешает undefined, а «| null» - null
function someFunction (value?: number | null) {
  if (value == null) {
    return 0
  }
  return value * 2
}
```

Есть только один потенциально опасный момент. В нашем статически типизированном коде всё будет работать как часы. Однако приложения часто работают с динамически получаемыми данными (например, данными от сервера), типы которых могут быть описаны одним образом, а на практике всё может быть совсем иначе. Другими словами, в типах описано, что некоторое значение не может быть `null`, а сервер его пришлёт. Избежать подобной ситуации можно введя практику проверять ответы от сервера. Например, с помощью [json-схем валидаторов](https://github.com/sideway/joi).

Чуть более коварной может быть ситуация с внешними библиотеками. В частности, с теми, который изначально написаны на JavaScript и тайпинги для них существуют отдельно от кода. В таких случаях потенциальные несовпадения реального кода с типами могут привести к возникновению вышеописанной ситуации.

Здесь можно найти таблицу совместимости типов с включенным и выключенным режимом `strictNullChecks` – `Any`, `unknown`, `object`, `void`, `undefined`, `null` and `never` assignability.

## strictPropertyInitialization

> Рекомендую: всегда / сложность: легко / связан с `strictNullChecks`

Флаг `strictPropertyInitialization` следит, чтобы объявленные свойства класса всегда были инициализированы:

```ts
class User {
  name: string
  // email не инициализирован ни здесь, ни в конструкторе
  // компилятор подскажет, что нужно установить значение
  email: string

  constructor (name: string) {
    this.name = name
  }
}
```

_Опция является своего рода дополнением к флагу_ `strictNullChecks` поэтому работает только когда второй флаг тоже включен.

## strictFunctionTypes

> Рекомендую: всегда / сложность: легко

Установка флага `strictFunctionTypes: true` включает более строгую проверку сигнатур функций. В целом, данная опция выглядит достаточно обязательной для использования:

```ts
interface StringOrNumberFunc {
  (value: string | number): void
}

function someFunction (value: string) {
  console.log(value)
}

// сигнатуры не совпадают
// string | number не эквивалентны string
let func: StringOrNumberFunc = someFunction

func(10)
func('10')
```

## noImplicitThis

> Рекомендую: всегда / сложность: легко

При использовании `this` проверяет, что контекст выполнения известен. Рассмотрим такой пример:

```ts
class SomeClass {
  multiplier: number = 5

  createSomeFunction (value: number) {
    return function () {
      // контекст потерян - здесь this НЕ является объектом класса SomeClass
      return value * this.multiplier
    }
  }
}
```

Объект `this` не известен, так как `function` не пробрасывает контекст автоматически. В данном случае это можно исправить, заменив `function` на `arrow function`.

Рассмотрим пример независимой функции, которая по каким-то причинам должна использовать внешний `this`:

```ts
function sayHello (name: string) {
  console.log(this.helloWord + ' ' + name)
}
```

В данном случае `this` также неизвестен. Выполнить функцию с внешним `this` можно с помощью `bind`, `call`, `apply`. А научить функцию понимать контекст можно следующим образом:

```ts
// укажем тип this первым «аргументом»
// фактически это не будет считаться аргументом функции
function sayHello (this: HelloStyle, name: string) {
  console.log(this.helloWord + ' ' + name)
}

// объявим варианты приветствий
interface HelloStyle {
  helloWord: string
}

class HawaiiStyle implements HelloStyle {
  helloWord = 'Aloha'
}

class RussianStyle implements HelloStyle {
  helloWord = 'Привет,'
}

// теперь вызовем
sayHello.bind(new HawaiiStyle())('World')
sayHello.call(new RussianStyle(), 'World')
sayHello.apply(new RussianStyle(), ['World'])
```

Во всех случаях тип контекста известен и даже тайпхинтинг работает как следует.

## strictBindCallApply

> Рекомендую: всегда / сложность: средне

Флаг `strictBindCallApply` – включает более строгую проверку сигнатур при использовании соответствующих методов: `bind`, `call`, `apply`.

```ts
function someFunction (value: string) {
  console.log(value)
}

someFunction.call(undefined, '10')
// да, для таких случаев нужен отдельный флаг
someFunction.call(undefined, false)
```

Кроме некоторых специфичных ситуаций при работе с данным флагом проблем не возникает. В случае возникновения сложных ситуаций рекомендую выключить проверку в месте возникновения проблемы через комментарий `// @ts-ignore` вместо полного отключения правила.

## Источники
- #### [habr](https://habr.com/ru/articles/557738/)
