
TypeScript использует структурную типизацию. Это означает, что при сравнении типов TypeScript учитывает только члены типа. Это означает, что _eсли это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка_.

Структурная типизация TypeScript была разработана на основе того, как обычно пишется код JavaScript. Поскольку в JavaScript широко используются анонимные объекты, такие как функциональные выражения и литералы объектов, гораздо естественнее представлять типы отношений, встречающиеся в библиотеках JavaScript, с помощью системы структурных типов, а не номинальной.

В этом отличие от систем номинальных типов: каждый тип уникален, и даже если типы имеют одинаковые данные, вы не можете назначать их между типами.

Если объект или класс имеет все необходимые свойства, TypeScript сообщит, что они совпадают, независимо от деталей реализации.

```ts
interface Ball {
  diameter: number
}
interface Sphere {
  diameter: number
}

let ball: Ball = {diameter: 10}
let sphere: Sphere = {diameter: 20}

sphere = ball // okay
ball = sphere // okay
```

Основное правило системы структурных типов TypeScript заключается в том, что **X** совместим с **Y**, если **Y** имеет по крайней мере те же элементы, что и **X**. Если мы добавим тип, который структурно содержит все элементы **Ball** и **Sphere**, то его также можно установить быть шаром или сферой.

```ts
interface Tube {
  diameter: number
  length: number
}

let tube: Tube = {diameter: 12, length: 3}

ball = tube // okay
tube = ball // error
```

Поскольку у шара нет длины, его нельзя присвоить переменной трубки. Однако все члены Ball находятся внутри трубы, поэтому их можно назначать.

TypeScript сравнивает каждый член типа друг с другом, чтобы проверить их равенство. Функция — это объект в JavaScript, и она сравнивается аналогичным образом. С одним полезным дополнительным трюком вокруг параметров:

```ts
let createBall = (diameter: number) => ({
  diameter
})
let createSphere = (diameter: number, useInches: boolean) => ({
  diameter: useInches ? diameter * 0.39 : diameter
})

createSphere = createBall // okay
createBall = createSphere // error
```

При сравнении двух объектов типа класса сравниваются только члены экземпляра. Статические члены и конструкторы не влияют на совместимость.

```ts
class Animal {
  feet: number
  constructor(name: string, numFeet: number) {}
}
class Size {
  feet: number
  constructor(numFeet: number) {}
}
let a: Animal
let s: Size

a = s // okay
s = a // okay
```

Это может иметь неожиданные последствия для программистов, привыкших работать на номинально типизированном языке. Например, бывают случаи, когда строка или число могут иметь особый контекст, и вы не хотите, чтобы эти значения когда-либо могли передаваться.

- Строки пользовательского ввода (небезопасно)
- Строки перевода
- Идентификационные номера пользователей
- Токены доступа

Возможно, вы слышали, [как печатает утка](https://en.wikipedia.org/wiki/Duck_typing) : если она ходит, как утка, и крякает, как утка, значит, это утка. Структурная типизация и утиная типизация очень похожи — структурная типизация часто используется для обозначения таких проверок, выполняемых во время компиляции, тогда как утиная типизация относится к тем же проверкам, выполняемым во время выполнения.

Структурная типизация необходима для совместимости TypeScript с утиной типизацией JavaScript и является ключевой частью того, как Typescript позволяет постепенно добавлять типы в базу нетипизированного кода.

---

## Источник
- #### [byby](https://byby.dev/ts-structural-typing)