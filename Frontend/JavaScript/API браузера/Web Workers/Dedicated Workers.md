Выделенный рабочий поток — самый простой тип рабочих потоков. Выделенные рабочие потоки создаются веб-страницей для выполнения сценариев вне потока выполнения страницы. Эти рабочие потоки способны обмениваться информацией с родительской страницей, отправлять сетевые запросы, выполнять файловый ввод- вывод, выполнять интенсивные вычисления, массово обрабатывать данные или любое другое количество вычислительных задач, которые не подходят для потока выполнения страницы (где они могли бы стать причиной проблем с задержкой).

Выделенные рабочие потоки могут быть точно описаны как фоновые сценарии. Характеристики рабочего потока JavaScript, включая управление жизненным циклом, путь к коду и ввод/вывод, регулируются единственным сценарием, предоставляемым при инициализации потока. Этот сценарий может, в свою очередь, запрашивать дополнительные сценарии, но рабочий поток всегда начинается с одного исходного сценария.

Все взаимодействие происходит с помощью функции `postMessage()` и listener `onmessage`, далее мы подробно их рассмотрим. Общий workflow выглядит следующим образом:
Dedicated Worker — это один из типов веб-воркеров (web workers), которые позволяют выполнять JavaScript в фоновом режиме, не блокируя основной поток выполнения, что особенно важно для обеспечения плавной работы пользовательского интерфейса в веб-приложениях.

## Основные аспекты работы

1. **Создание и запуск**:
   - Dedicated Worker создается с помощью конструктора `Worker`, которому передается путь к JavaScript-файлу, содержащему код воркера.
```javascript
const worker = new Worker('worker.js');
```

2. **Общение с основным потоком**:
   - Воркер и основной поток могут обмениваться сообщениями с помощью методов `postMessage` и обработчика `onmessage`.
   - Основной поток:
```javascript
worker.postMessage('Hello from main thread');
worker.onmessage = function(event) {
	console.log('Message from worker:', event.data);
};
```
   - Воркер:
```javascript
self.onmessage = function(event) {
	console.log('Message from main thread:', event.data);
	self.postMessage('Hello from worker');
};
```

3. **Область видимости**:
   - Dedicated Worker имеет свою собственную изолированную область видимости, что означает, что он не имеет доступа к переменным и функциям основного потока.

4. **Ограничения**:
   - Воркеры не имеют доступа к DOM, поэтому они не могут манипулировать элементами страницы напрямую.
   - Они также не могут использовать некоторые функции и объекты, такие как `alert`, `confirm`, и `prompt`.

5. **Использование**:
   - Dedicated Worker обычно используется для выполнения ресурсоемких вычислений, обработки данных, сетевых запросов и других задач, которые могут заблокировать основной поток и привести к зависанию пользовательского интерфейса.

1. **Завершение работы**:
   - Воркер может быть остановлен как из основного потока, так и из самого воркера.
   - Воркер:

```javascript
self.close();
```

- Основной поток:
```javascript
worker.terminate();
```

![[./_/dedicated-workers.png]]

### Пример использования

**main.js**
```javascript
const worker = new Worker('worker.js');

worker.postMessage({ action: 'calculate', data: [1, 2, 3, 4, 5] });

worker.onmessage = function(event) {
  console.log('Result from worker:', event.data);
};
```

**worker.js**
```javascript
self.onmessage = function(event) {
  if (event.data.action === 'calculate') {
    const result = event.data.data.reduce((acc, val) => acc + val, 0);
    self.postMessage(result);
  }
};
```

## Жизненный цикл выделенного рабочего потока

Конструктор `Worker()` — это начало жизни выделенного рабочего потока. После вызова он инициирует запрос сценария рабочего потока и возвращает объект `Worker` в родительский контекст. Несмотря на то, что объект `Worker` сразу доступен для использования в родительском контексте, связанный поток, возможно, еще не был создан из-за задержек в сети сценария рабочего потока или задержки инициализации.

Вообще говоря, выделенные рабочие потоки можно неофициально охарактеризовать как существующие в одном из трех состояний: **инициализирующийся**, **активный** и **завершенный**. Состояние выделенного рабочего потока непрозрачно для любых других контекстов. Хотя объект `Worker` может существовать в родительском контексте, он не может быть установлен, если выделенный поток инициализируется, активен или завершен. Другими словами, объект `Worker`, связанный с активным выделенным рабочим потоком, неотличим от объекта `Worker`, связанного с завершенным выделенным рабочим потоком.

Во время инициализации, хотя сценарий рабочего потока еще не начал выполняться, можно ставить в очередь сообщения для него. Эти сообщения будут ожидать, пока поток станет активным, и впоследствии будут добавлены в его очередь сообщений. Такое поведение демонстрируется здесь:

**initializingworker.js**
```javascript
self.addEventListener('message', ({data}) => console.log(data));
```

**main.js**
```javascript
const worker = new Worker('./initializingWorker.js');
// Рабочий поток может еще инициализироваться,
// но информация из postMessage будет обработана корректно.
worker.postMessage('foo');
worker.postMessage('bar');
worker.postMessage('baz');
```

```
foo
bar
baz
```

После создания выделенный рабочий поток будет работать в течение всей жизни страницы, если он не будет явно прерван либо через самоуничтожение (`self.close()`), либо через внешнее завершение (`worker.terminate()`). Даже после завершения рабочего сценария рабочая среда сохранится. Пока поток еще жив, связанный с ним объект `Worker` не будет собран как мусор.

Самоуничтожение и внешнее завершение в конечном счете выполняют одну и ту же процедуру завершения рабочего потока. Рассмотрим следующий пример, где рабочий поток самоуничтожается между отправкой сообщений:

**closeworker.js**
```javascript
self.postMessage('foo');
self.close();
self.postMessage('bar');
setTimeout(() => self.postMessage('baz'), 0);
```

**main.js**
```javascript
const worker = new Worker('./worker.js');
worker.onmessage = ({data}) => console.log(data);
```

```
foo
bar
```

Хотя вызывается `close()`, очевидно, что выполнение рабочего потока не прекращается немедленно. Метод `close()` только дает указание потоку отказаться от всех задач в цикле событий и предотвратить добавление дальнейших задач. Вот почему «baz» никогда не выведется в консоль. Остановка синхронного выполнения не требуется, и, следовательно, «bar» по-прежнему выводится в консоль, поскольку это обрабатывается в цикле событий родительского контекста.

Теперь рассмотрим следующий пример внешнего завершения:

**terminateworker.js**
```javascript
self.onmessage = ({data}) => console.log(data);
```

**main.js**
```javascript
const worker = new Worker('./worker.js');
// Дает 1000мс на инициализацию worker
setTimeout(() => {
  worker.postMessage('foo');
  worker.terminate();
  worker.postMessage('bar');
  setTimeout(() => worker.postMessage('baz'), 0);
}, 1000);
```

```
foo
```

Здесь рабочий поток сначала отправляет сообщение `postMessage` с «foo», которое он может обработать до внешнего завершения. После вызова `terminate()` очередь сообщений потока очищается и блокируется — поэтому печатается только «foo».

> [!WARN] Примечание
> И `close()`, и `terminate()` являются идемпотентными операциями; они могут быть безвредно вызваны несколько раз. Эти методы просто служат для того, чтобы пометить рабочий поток как подлежащий завершению, поэтому многократный вызов его не будет иметь вредных последствий.

В течение своего жизненного цикла выделенный рабочий поток связан только с одной веб-страницей (упоминаемой в спецификации Web Worker как документ). Если не было вызвано явное завершение, выделенный рабочий поток будет сохраняться, пока существует связанный документ. Если браузер закрывает страницу (возможно, с помощью навигации или закрытия вкладки или окна), браузер помечает рабочие потоки, связанные с этим документом, как подлежащие завершению, и их выполнение немедленно останавливается.

## Совместимость

<iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=webworkers" frameborder="0" width="100%" height="510px"></iframe>