
Служебный рабочий поток — это тип рабочего потока, который ведет себя как прокси-сервер внутри браузера. Служебные потоки позволяют перехватывать исходящие запросы и кешировать ответ. Это позволяет веб-странице работать без подключения к сети, поскольку некоторые или все страницы могут потенциально обслуживаться из кеша служебного рабочего потока. Служебный поток также может использовать *Notifications API*, *Push API*, *Background Sync API* и *Channel Messaging API*.

Как и общие рабочие потоки, несколько страниц в одном домене будут взаимодействовать с единственным экземпляром служебного рабочего потока. Однако для включения таких функций, как *Push API*, служебные потоки также могут пережить закрытие соответствующей вкладки или браузера и ожидать получения push-события.

## Основные аспекты работы

1. **Регистрация**:
   - Service Worker регистрируется на странице с помощью JavaScript. Это делается с помощью метода `navigator.serviceWorker.register()`.
   ```javascript
   if ('serviceWorker' in navigator) {
     navigator.serviceWorker.register('/service-worker.js')
       .then(registration => {
         console.log('Service Worker зарегистрирован:', registration);
       })
       .catch(error => {
         console.error('Ошибка при регистрации Service Worker:', error);
       });
   }
   ```

2. **Жизненный цикл**:
   - Service Worker проходит через несколько стадий жизненного цикла: `installing`, `installed`, `activating`, `activated` и `redundant`.
   - Во время установки (`installing`) Service Worker может кэшировать ресурсы.
   - После активации (`activated`) Service Worker может управлять запросами от страницы.

3. **Кэширование**:
   - Service Worker может кэшировать ресурсы, чтобы обеспечить автономную работу приложения.
   ```javascript
   self.addEventListener('install', event => {
     event.waitUntil(
       caches.open('my-cache').then(cache => {
         return cache.addAll([
           '/',
           '/index.html',
           '/styles.css',
           '/script.js'
         ]);
       })
     );
   });
   ```

4. **Перехват запросов**:
   - Service Worker может перехватывать сетевые запросы и обрабатывать их, например, возвращая кэшированные ресурсы, если они доступны.
   ```javascript
   self.addEventListener('fetch', event => {
     event.respondWith(
       caches.match(event.request).then(response => {
         return response || fetch(event.request);
       })
     );
   });
   ```

5. **Обновление**:
   - Service Worker может обновляться, когда браузер обнаруживает изменения в файле Service Worker. Обновление происходит в фоновом режиме.

6. **Фоновая синхронизация и push-уведомления**:
   - Service Worker может использоваться для фоновой синхронизации данных и получения push-уведомлений, даже когда приложение не активно.

1. **Безопасность**:
   - Service Workers работают только по HTTPS, чтобы обеспечить безопасность 
   - передачи данных.

### Пример использования

```javascript
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('my-cache').then(cache => {
      return cache.addAll([
        '/',
        '/index.html',
        '/styles.css',
        '/script.js'
      ]);
    })
  );
});

self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || fetch(event.request);
    })
  );
});
```

## ServiceWorkerContainer

Интерфейс `ServiceWorkerContainer` — это оболочка верхнего уровня для экосистемы рабочего потока браузера. Он предоставляет средства для управления состоянием и жизненным циклом служебного потока.

`ServiceWorkerContainer` всегда доступен в контексте клиента:
```javascript
console.log(navigator.serviceWorker);
// ServiceWorkerContainer { ... }
```

`ServiceWorkerContainer` поддерживает следующие обработчики событий:

- **oncontrollerchange** — может быть назначен обработчик событий, который будет вызываться каждый раз, когда событие `controllerchange` отправляется из `ServiceWorkerContainer`.
  - Это событие происходит при получении новой активированной регистрации `ServiceWorkerRegistration`.
  - Это событие также можно обработать с помощью `navigator.serviceWorker.addEventListener('controllerchange', handler)`.

- **onerror** — может быть назначен обработчик события, который будет вызываться всякий раз, когда `ErrorEvent` типа `error` всплывает от любого связанного служебного рабочего потока.
  - Это событие происходит, когда в любом связанном рабочем потоке возникает ошибка.
  - Это событие также можно обработать с помощью `navigator.serviceWorker.addEventListener('error', handler)`.

- **onmessage** — может быть назначен обработчик события, который будет вызываться всякий раз, когда сообщение `ServiceEvent` типа отправляется от служебного рабочего потока.
  - Это событие происходит, когда сценарий служебного рабочего потока отправляет событие сообщения обратно в родительский контекст.
  - Это событие также можно обработать с помощью `navigator.serviceWorker.addEventListener('message', handler)`.

### Свойства

`ServiceWorkerContainer` поддерживает следующие свойства:

- **ready** — возвращает промис, который может разрешиться с помощью активированного объекта `ServiceWorkerRegistration`. Этот промис никогда не будет отклонен.
- **controller** — возвращает активированный объект `ServiceWorker`, связанный с текущей страницей, или `null`, если активного служебного потока нет.

### Методы

`ServiceWorkerContainer` поддерживает следующие методы:

- **register()** — создает или обновляет `ServiceWorkerRegistration`, используя предоставленный объект URL-адреса и параметров.
- **getRegistration()** — возвращает промис, который разрешается с помощью объекта `ServiceWorkerRegistration`, соответствующего предоставленной области, или разрешается с `undefined`, если нет соответствующего служебного рабочего потока.
- **getRegistrations()** — возвращает промис, который разрешается с помощью массива всех объектов `ServiceWorkerRegistration`, связанных с `ServiceWorkerContainer`, или пустого массива, если нет связанных служебных потоков.
- **startMessage()** — запускает передачу сообщений через `Client.postMessage()`.

## ServiceWorkerRegistration

Объект `ServiceWorkerRegistration` представляет успешную регистрацию служебного рабочего потока. Объект доступен в обработчике разрешенных промисов, возвращаемом из `register()`. Этот объект позволяет определить статус жизненного цикла связанного рабочего потока, используя несколько свойств.

Объект регистрации предоставляется внутри промиса после вызова `navigator.serviceWorker.register()`. Несколько вызовов на одной странице с одним и тем же URL вернут один и тот же объект регистрации.

```javascript
navigator.serviceWorker.register('./serviceWorker.js')
.then((registrationA) => {
  console.log(registrationA);
  navigator.serviceWorker.register('./serviceWorker2.js')
  .then((registrationB) => {
    console.log(registrationA === registrationB);
  });
});
```

### Обработчик событий

`ServiceWorkerRegistration` поддерживает следующий обработчик событий:

- **onupdatefound** — может быть назначен обработчик событий, который будет вызываться всякий раз, когда событие типа `updatefound` запускается из служебного потока.
  - Это событие происходит, когда начинается установка новой версии этого рабочего потока, о чем свидетельствует `ServiceWorkerRegistration.installing` при получении нового служебного потока.
  - Это событие также можно обработать с помощью `serviceWorkerRegistration.addEventListener('updatefound', handler)`.

### Свойства

`ServiceWorkerRegistration` поддерживает следующие общие свойства:

- **scope** — возвращает полный путь URL-адреса области видимости служебного потока. Это значение является производным от пути, из которого был извлечен сценарий потока, и/или области, предоставленной в `register()`.
- **navigationPreload** — возвращает экземпляр `NavigationPreloadManager`, связанный с этим объектом регистрации.
- **pushManager** — возвращает экземпляр `PushManager`, связанный с этим объектом регистрации.

`ServiceWorkerRegistration` также поддерживает следующие свойства, которые можно использовать для проверки служебных рабочих потоков на различных этапах их жизненных циклов:

- **installing** — возвращает служебный поток с состоянием `installing`, если в данный момент он существует, иначе — `null`.
- **waiting** — возвращает рабочий поток с состоянием `waiting`, если оно есть в данный момент, иначе — `null`.
- **active** — возвращает служебный поток с состоянием `activating` или `active`, если оно есть в данный момент, иначе — `null`.

Обратите внимание, что эти свойства являются одноразовым захватом состояния служебного потока. Они подходят для большинства случаев использования, так как активный служебный поток не будет изменять состояние в течение всего срока жизни страницы, если его не заставят делать это с помощью чего-то вроде `ServiceWorkerGlobalScope.skipWaiting()`.

### Методы

`ServiceWorkerRegistration` поддерживает следующие методы:

- **getNotifications()** — возвращает промис, который разрешается с помощью массива объектов `Notification`.
- **showNotification()** — отображает уведомление, которое можно настроить с помощью аргументов `title` и `options`.
- **update()** — повторно запрашивает сценарий служебного рабочего потока непосредственно с сервера и запускает новую установку, если новый сценарий отличается от предыдущего.
- **unregister()** — попытается отменить регистрацию потока. Это позволяет завершить выполнение служебного потока перед отменой регистрации.

## ServiceWorker

Объект `ServiceWorker` может быть получен одним из двух способов: через свойство контроллера на объекте `ServiceWorkerController` и активное свойство объекта `ServiceWorkerRegistration`. Этот объект наследуется от прототипа `Worker` и поэтому получает все его свойства и методы, но, в частности, не имеет метода `terminate()`.

### Обработчик событий

`ServiceWorker` поддерживает следующий обработчик событий:

- **onstatechange** — может быть назначен обработчик событий, который будет вызываться всякий раз, когда событие `Servicechange` отправляется из `ServiceWorker`.
  - Это событие происходит при изменении `ServiceWorker.state`.
  - Это событие также может быть обработано с помощью `serviceWorker.addEventListener('statechange', handler)`.

### Свойства

`ServiceWorker` поддерживает следующие свойства:

- **scriptURL** — разрешенный URL-адрес, используемый для регистрации служебного рабочего потока. Например, если поток был создан с относительным путем `./serviceWorker.js`, то если он был зарегистрирован на `https://www.example.com`, свойство `scriptURL` вернет `https://www.example.com/serviceWorker.js`.
- **state** — возвращает строку, идентифицирующую состояние служебного потока. Возможны следующие состояния:
  - `installing`
  - `installed`
  - `activating`
  - `activated`
  - `redundant`


## ServiceWorkerGlobalScope

Внутри служебного потока глобальная область является экземпляром `ServiceWorkerGlobalScope`. Она наследуется от `WorkerGlobalScope` и, следовательно, включает в себя все его свойства и методы. Служебный рабочий поток может получить доступ к этой глобальной области через `self`.

`ServiceWorkerGlobalScope` расширяет `WorkerGlobalScope` следующими свойствами и методами:

- **caches** — возвращает объект `CacheStorage` служебного потока.
- **clients** — возвращает интерфейс клиентов служебного потока. Используется для доступа к базовым объектам `Client`.
- **registration** — возвращает объект `ServiceWorkerRegistration` служебного потока.
- **skipWaiting()** — переводит служебный поток в активное состояние. Это используется вместе с `Clients.claim()`.
- **fetch()** — выполняет обычное извлечение из служебного потока. Это используется, когда служебный поток определяет, что должен быть сделан фактический исходящий сетевой запрос (вместо возврата кешированного значения).

В то время как выделенные или общие рабочие потоки имеют в качестве входных данных только событие `message`, служебные потоки могут использовать большое количество событий, которые инициируются действиями на странице, действиями по уведомлению или push-событиями.

> [!WARN] Примечание 
> В зависимости от реализации браузера запись в `console` внутри `SharedWorker` может не выводиться в представлении консоли браузера по умолчанию.

Глобальная область видимости служебного рабочего потока может прослушивать следующие события, разбитые здесь по категориям:

### Состояние служебного потока

- **install** запускается, когда служебный поток входит в состояние `installing` (отображается на клиенте через `ServiceWorkerRegistration.installing`). Также можно установить обработчик для этого события в `self.oninstall`.
  - Это первое событие, полученное служебным потоком, и оно запускается, как только начинается выполнение потока.
  - Вызывается только один раз на поток.
- **activate** запускается, когда служебный поток входит в состояние `activating` или `activated` (отображается на клиенте через `ServiceWorkerRegistration.active`). Также можно установить обработчик для этого события в `self.onactivate`.
  - Это событие вызывается, когда служебный поток готов обрабатывать функциональные события и управлять клиентами.
  - Это событие не означает, что служебный поток контролирует клиента, только то, что он готов сделать это.

### Fetch API

- **fetch** запускается, когда служебный поток перехватывает функцию `fetch()`, вызываемую на главной странице. Обработчик события `fetch` потока имеет доступ к `FetchEvent` и может корректировать результат по своему усмотрению. Также можно установить обработчик для этого события в `self.onfetch`.

### Message API

- **message** запускается, когда служебный поток получает данные через `postMesssage()`. Также можно установить обработчик для этого события в `self.onmessage`.

### Notification API

- **notificationclick** срабатывает, когда система сообщает браузеру, что было щелкнуто мышью уведомление, порожденное `ServiceWorkerRegistration.showNotification()`. Также можно установить обработчик для этого события на `self.onnotificationclick`.
- **notificationclose** запускается, когда система сообщает браузеру, что уведомление, порожденное `ServiceWorkerRegistration.showNotification()`, было закрыто или отклонено. Также можно установить обработчик для этого события в `self.onnotificationclose`.

### Push API

- **push** запускается, когда служебный поток получает push-сообщение. Также можно установить обработчик для этого события в `self.onpush`.
- **pushsubscriptionchange** запускается при изменении состояния принудительной подписки, которое произошло вне контроля приложения (явно не в JavaScript). Также можно установить обработчик для этого события в `self.onpushsubscriptionchange`.

> [!WARN] Примечание
> Некоторые браузеры также поддерживают событие `sync`, которое является частью `Background Sync API`. Этот API не стандартизирован и поддерживается только в Chrome и Opera, поэтому он не включен в эту книгу.

## Ограничения безопасности служебного потока

Как класс рабочего потока, служебные потоки подчиняются обычным ограничениям в отношении соответствия происхождения загруженного сценария. (Подробнее об этом см. в разделе «Ограничения безопасности для рабочих потоков» ранее в этой главе.) Кроме того, поскольку служебным потокам предоставляется практически неограниченная возможность изменять и перенаправлять сетевые запросы и загруженные статические ресурсы, API служебного потока доступен только в безопасном `https` контексте; в контексте `http` `navigator.serviceWorker` будет иметь значение `undefined`.

Для упрощения разработки браузеры делают исключение из правила безопасного контекста для страниц, загружаемых локально, через `localhost` или `127.0.0.1`.

> [!WARN] Примечание 
> Удобным инструментом для оценки того, является ли текущий контекст безопасным, является `window.isSecureContext`.

## Совместимость 

<iframe src="https://caniuse.bitsofco.de/embed/index.html?feat=serviceworkers" frameborder="0" width="100%" height="510px"></iframe>