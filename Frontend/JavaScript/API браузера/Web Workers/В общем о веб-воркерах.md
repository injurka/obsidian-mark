## Введение
  
Единая среда JavaScript — это виртуализированная среда, работающая внутри операционной системы хоста. Каждой открытой странице в браузере выделяется своя среда. Это обеспечивает каждой странице собственную память, цикл обработки событий, DOM и т. д. Каждая страница более или менее изолирована и не может мешать другим страницам. Обязательным условием для браузера является одновременное управление многими средами, причем все они выполняются параллельно.

Используя рабочие потоки, браузеры могут выделить вторую дочернюю среду, которая полностью отделена от исходной среды страницы. Эта дочерняя среда не может взаимодействовать с однопоточными зависимыми конструкциями, такими как DOM, но в противном случае она может выполнять код параллельно с родительской средой.

### Сравнение рабочих потоков и потоков выполнения

Вводные ресурсы обычно проводят сравнение между рабочими потоками и потоками выполнения. Во многих отношениях это удачное сравнение, поскольку рабочие потоки и потоки выполнения действительно имеют много общих характеристик:

- **Рабочие потоки реализованы в виде реальных потоков выполнения.** Например, механизм браузера Blink реализует рабочие потоки с `WorkerThread`, который соответствует базовому потоку платформы.
- **Рабочие потоки выполняются параллельно.** Несмотря на то, что страница и рабочий объект реализуют однопоточную среду JavaScript, инструкции в каждой среде могут выполняться параллельно.
- **Рабочие потоки могут разделять часть памяти.** Рабочие потоки могут использовать `SharedArrayBuffer` для разделения памяти между несколькими средами, в то время как потоки выполнения будут использовать блокировки для реализации управления параллелизмом. JavaScript использует интерфейс `Atomics` для реализации управления параллелизмом.

Рабочие потоки и потоки выполнения сильно перекрываются, но между ними есть некоторые важные различия:

- **Рабочие потоки не разделяют всю память.** В традиционной модели потоков несколько потоков имеют возможность чтения и записи в общую область памяти. За исключением `SharedArrayBuffer`, перемещение данных в и из рабочих потоков требует их копирования или переноса.
- **Рабочие потоки не обязательно являются частью одного и того же процесса.** Как правило, один процесс может порождать несколько потоков внутри него. В зависимости от реализации движка браузера рабочий поток может быть или не быть частью того же процесса, что и страница. Например, движок Chrome Blink использует отдельный процесс для общих рабочих и служебных потоков.
- **Рабочие потоки выполнения дороже создавать.** Рабочие потоки выполнения включают в себя собственный отдельный цикл событий, глобальные объекты, обработчики событий и другие функции, которые являются неотъемлемой частью среды JavaScript. Расходы на их создание не следует упускать из виду.

Как по форме, так и по функциям рабочие потоки не заменяют потоки выполнения. В спецификации HTML Web Worker указано следующее:

> Рабочие потоки имеют относительно большой вес и не предназначены для использования в больших количествах. Например, было бы неуместно запускать один рабочий поток на каждый пиксель изображения размером в четыре мегапикселя. Как правило, ожидается, что рабочие потоки будут долгоживущими и будут иметь высокую стоимость запуска и высокую стоимость памяти для каждого экземпляра.

## Обзор веб-воркеров

Веб-воркеры позволяют выполнять тяжёлые в вычислительном плане и длительные задачи без блокировки потока пользовательского интерфейса. На самом деле, при их использовании вычисления выполняются параллельно. Перед нами настоящая многопоточность.  
  
Возможно, вы вспомните о том, что JavaScript — это однопоточный язык программирования. Пожалуй, тут вы должны осознать, что JS — это язык, который не определяет модель потоков. Веб-воркеры не являются частью JavaScript. Они представляют собой возможность браузера, к которой можно получить доступ посредством JavaScript. Большинство браузеров исторически были однопоточными (эта ситуация, конечно, изменилась), и большинство реализаций JavaScript создано для браузеров.  
  
Веб-воркеры не реализованы в Node.js — там есть концепция «кластеров» или «дочерних процессов», а это уже немного другое.  
  
Стоит отметить, что [спецификация](http://www.whatwg.org/specs/web-workers/current-work/) упоминает три типа веб-воркеров:  
  
- Выделенные воркеры ([Dedicated Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers))  
- Разделяемые воркеры ([Shared Workers](https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker))  
- Сервис-воркеры ([Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API))  

> [!WARN] Примечание
> Спецификацию Web Worker можно найти по адресу https://html.spec.whatwg.org/multipage/workers.html.

### Выделенные воркеры ~ Dedicated Workers

Выделенный рабочий поток, обычно называемый выделенным потоком или просто рабочим потоком, — это универсальная утилита, которая позволяет сценариям создавать отдельный поток JavaScript и делегировать ему задачи. Как следует из названия, выделенный рабочий поток может быть доступен только на той странице, которая его выделила.

### Разделяемые воркеры ~ Shared Workers

Общий рабочий поток ведет себя очень похоже на выделенный. Основное отличие состоит в том, что к общему рабочему потоку можно обращаться в разных контекстах, включая разные страницы. Любые сценарии, выполняющиеся в том же источнике, что и сценарий, который первоначально выделил общий рабочий поток, могут отправлять и получать сообщения для общего потока.
  
### Сервис-воркеры ~ Service Workers

Сервис-воркеры — это воркеры, управляемые событиями, зарегистрированные с использованием источника их происхождения и пути. Они могут контролировать веб-страницу, с которой связаны, перехватывая и модифицируя команды навигации и запросы ресурсов, и выполняя кэширование данных, которым можно очень точно управлять. Всё это даёт нам отличные средства управления поведением приложения в определённой ситуации (например, когда сеть недоступна). Служебный рабочий поток полностью отличается от выделенного или общего. Его основная цель — выступать в качестве арбитра для сетевых запросов, способного перехватывать, перенаправлять и изменять запросы, отправляемые страницей.
  
## Как работают веб-воркеры

Веб-воркеры реализованы с использованием .js-файлов, которые включаются в страницу с применением асинхронного HTTP-запроса. Эти запросы полностью скрыты от разработчика благодаря [Web Worker API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers).
  
Воркеры используют механизмы передачи сообщений, характерные для технологий, которые применяются для организации взаимодействия потоков, что позволяет организовать их параллельное выполнение. Они отлично подходят для того, чтобы выполнять тяжёлые вычислительные операции, не замедляя работу пользовательского интерфейса.  
  
Веб-воркеры выполняются в изолированных потоках в браузере. Как результат, код, который они выполняют, должен быть включён в отдельный файл. Это важно запомнить.  
  
## Обмен данными с веб-воркером

Для того чтобы страница, создавшая веб-воркер, могла взаимодействовать с ним, нужно использовать либо метод `postMessage`, либо широковещательный канал передачи данных, представленный объектом [BroadcastChannel](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel).  
  
### Метод postMessage

При вызове этого метода более новые браузеры поддерживают, в качестве первого параметра, объект JSON, а в более старых браузерах поддерживается лишь параметр типа `String`.  
  
Посмотрим на пример того, как страница, создавшая воркер, может обмениваться с ним данными, используя JSON-объект. При передаче строки выглядит всё практически точно так же.  
  
HTML-страница:  
```js
<button onclick="startComputation()">Start computation</button>

<script>
  function startComputation() {
    worker.postMessage({'cmd': 'average', 'data': [1, 2, 3, 4]});
  }

  var worker = new Worker('doWork.js');

  worker.addEventListener('message', function(e) {
    console.log(e.data);
  }, false);
  
</script>
```

Код воркера:  
```js
self.addEventListener('message', function(e) {
  var data = e.data;
  switch (data.cmd) {
    case 'average':
	  // Функция, вычисляющая среднее значение числового массива
      var result = calculateAverage(data); 
      self.postMessage(result);
      break;
    default:
      self.postMessage('Unknown command');
  }
}, false);
```
  
### Широковещательный канал передачи данных

Объект [BroadcastChannel](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel) представляет собой более универсальное API для передачи данных. Он позволяет передавать сообщения, которые можно принять во всех контекстах, имеющих один и тот же источник. Все вкладки браузера, `iframe` или воркеры, относящиеся к одному источнику, могут передавать и принимать широковещательные сообщения:  
  
```js
// Подключение к широковещательному каналу
var bc = new BroadcastChannel('test_channel');

// Пример отправки сообщения
bc.postMessage('This is a test message.');

// Пример простого обработчика событий, который
// выводит сообщения в консоль
bc.onmessage = function (e) { 
  console.log(e.data); 
}

// Отключение от канала
bc.close()
```

Пример связи с webworker
```js
// index.js
const channel = new BroadcastChannel('worker_channel');

const worker = new Worker('worker.js');

channel.onmessage = (event) => {
  console.log('Received message from worker:', event.data);
};

worker.postMessage('Hello from main script');

// worker.js
const channel = new BroadcastChannel('worker_channel');

channel.onmessage = (event) => {
  console.log('Received message from main script:', event.data);
};

self.onmessage = (event) => {
  console.log('Received message from main script in worker:', event.data);
  channel.postMessage('Hello from worker');
};
```
  
Вот как выглядит схема взаимодействия различных сущностей с использованием широковещательного канала обмена сообщениями:  

![[broadcast.png]]
_Обмен данными с использованием широковещательного канала передачи сообщений_  
  
Однако тут стоит отметить, что объект `BroadcastChannel` пока имеет довольно ограниченную поддержку в браузерах.  

## Способы отправки сообщений веб-воркерам

Есть два способа отправки сообщений веб-воркерам. Первый заключается в копировании данных, второй — в передаче данных от источника к приёмнику без их копирования. Рассмотрим эти способы работы с сообщениями:  

- Копирование сообщения. Сообщение сериализуется, копируется, отправляется, а затем, на принимающей стороне, десериализуется. Страница и воркер не используют общий экземпляр сообщения, поэтому тут мы сталкиваемся с созданием копий данных в каждом сеансе отправки сообщений. Большинство браузеров реализуют эту возможность путём автоматического преобразования передаваемой информации в JSON на стороне передатчика и декодирования этих данных на стороне приёмника. Как можно ожидать, это добавляет значительную нагрузку на систему при отправке сообщений. Чем больше сообщение — тем больше времени займёт его отправка.  
    
- Передача сообщения. При таком подходе оказывается, что отправитель сообщения больше не может использовать сообщение после того, как оно отправлено. При этом передача сообщений выполняется практически мгновенно. Главная особенность этого метода заключается в том, что передать с его помощью можно только объект [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).  
  
## Возможности, доступные веб-воркерам

Веб-воркерам, из-за их многопоточной сущности, доступен лишь ограниченный набор возможностей JavaScript. Вот эти возможности:  
  
- Объект `navigator`
- Объект `location` (только для чтения)  
- `XMLHttpRequest`
- `setTimeout()` / `clearTimeout()` и `setInterval()` / `clearInterval()`
- [Кэш приложения](https://www.html5rocks.com/tutorials/appcache/beginner/)  
- Импорт внешних скриптов с использованием `importScripts()`
- [Создание](https://www.html5rocks.com/en/tutorials/workers/basics/#toc-enviornment-subworkers) других веб-воркеров

## Ограничения веб-воркеров

К сожалению, у веб-воркеров нет доступа к некоторым весьма важным возможностям JavaScript. Среди них следующие:  
  
- DOM (это не потокобезопасно) 
- Объект `window`
- Объект `document`
- Объект `parent`

Всё это значит, что веб-воркеры не могут манипулировать DOM (и, таким образом, не могут прямо влиять на пользовательский интерфейс). Поначалу может показаться, что это значительно усложняет использование веб-воркеров, однако со временем, узнав о том, как правильно использовать веб-воркеры, вы начнёте воспринимать их как отдельные «вычислительные машины», в то время как то, что относится к работе с пользовательским интерфейсом, будет выполняться в коде страницы. Воркеры будут выполнять тяжёлые вычисления, и после того, как работа будет завершена, отправлять результаты на страницу, вызывающую их, код которой уже внесёт необходимые изменения в пользовательский интерфейс.  

## Обработка ошибок
  
Как и при работе с любым JS-кодом, в веб-воркерах нужно обрабатывать ошибки. Если ошибка возникает в процессе выполнения воркера, вызывается событие `ErrorEvent`. Объект ошибки содержит три полезных свойства, которые позволяют понять её суть:  
  
- `filename` — имя файла, в котором содержится скрипт воркера, вызвавший ошибку.
- `lineno` — номер строки, в которой произошла ошибка.  
- `message` — описание ошибки.  

  
Вот пример кода для обработки ошибок в веб-воркере:  

```js
function onError(e) {
  console.log('Line: ' + e.lineno);
  console.log('In: ' + e.filename);
  console.log('Message: ' + e.message);
}

var worker = new Worker('workerWithError.js');
worker.addEventListener('error', onError, false);
worker.postMessage(); // Запустить воркер без сообщения.
```

Вот код воркера  
```js
self.addEventListener('message', function(e) {
  postMessage(x * 2); // Намеренная ошибка. 'x' не определено.
};
```

  
Тут вы можете видеть, как мы создали воркер и назначили ему обработчик события `error`.  
  
Внутри воркера (второй фрагмент кода) мы намеренно вызываем исключение, умножая `x` на 2 в то время как `x` не определено в текущей области видимости. Исключение доходит до исходного скрипта и вызывается обработчик `onError`, выводящий сведения об ошибке.  
  
## Сценарии использования веб-воркеров
  
Мы рассказали о сильных и слабых сторонах веб-воркеров. Теперь рассмотрим несколько сценариев их использования.  

- Рендеринг трёхмерных сцен. В частности, речь идёт о реализации метода трассировки лучей — техники [рендеринга](https://en.wikipedia.org/wiki/Rendering_%28computer_graphics%29), позволяющей создавать изображения путём отслеживания направления лучей [света](https://en.wikipedia.org/wiki/Light) и определения цвета пикселей. Трассировка лучей использует интенсивные математические вычисления для моделирования особенностей распространения света. При таком подходе реализуются такие эффекты, как отражения и преломления, трассировка лучей позволяет добиться имитировать внешний вид различных материалов, и так далее. Вся эта вычислительная логика может быть вынесена в веб-воркер для того, чтобы она не блокировала поток пользовательского интерфейса. Можно сделать ещё интереснее, а именно, разделить рендеринг изображения между несколькими воркерами (и, соответственно, между несколькими процессорными ядрами). [Вот](https://nerget.com/rayjs-mt/rayjs.html) простой пример реализации трассировки лучей с использованием веб-воркеров.  
    
- Шифрование. Сквозное шифрование становится всё более популярным из за всё возрастающего внимания к регулированию распространения персональных и конфиденциальных данных. Операции шифрования могут быть достаточно продолжительными, особенно если возникает необходимость в частом шифровании больших объёмов данных. Это — весьма адекватный сценарий использования веб-воркера, так как тут не нужен доступ к объектам DOM или нечто подобное. Шифрование — это алгоритмы обработки информации, которым достаточно базовых возможностей JS. Когда шифрование выполняется воркером, это не влияет на работу пользователя с интерфейсом сайта.  
    
- Предварительная загрузка данных. Для того чтобы оптимизировать веб-сайт и улучшить впечатления пользователя от работы с ним, можно использовать веб-воркеры для заблаговременной загрузки и сохранения некоторых данных, которыми можно очень быстро воспользоваться тогда, когда позже в них возникнет необходимость. Веб-воркеры отлично подходят для подобного сценария использования, так как выполняемые ими операции не подействуют на интерфейс приложения, в отличие от предварительной загрузки данных, реализованной средствами главного потока.  
    
- Прогрессивные веб-приложения. Такие приложения должны, даже при ненадёжном сетевом соединении, быстро загружаться. Это означает, что данные нужно хранить в браузере локально. Именно здесь в дело вступает [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) или похожее API. В целом, речь идёт о необходимости обслуживания некоего хранилища данных на стороне клиента. Для того чтобы работать с этим хранилищем, не блокируя пользовательский интерфейс, работу надо организовать в веб-воркере. Тут надо отметить, что, в случае с IndexedDB, существует асинхронное API, которое позволяет не нагружать главный поток и без веб-воркеров, но раньше здесь было синхронное API (которое может появиться снова), которым нужно пользоваться только внутри веб-воркеров.  
    
- Проверка правописания. Простая система проверки правописания работает так: программа считывает файл словаря со списком правильно написанных слов. Из словаря формируется дерево поиска, которое обеспечивает эффективный поиск по тексту. Когда системе передают слово для проверки, она проверяет его наличие в дереве поиска. Если слово найти не удаётся, пользователю могут быть предоставлены альтернативные варианты этого слова, полученные путём замены символов исходного слова и поиска полученных слов в дереве на предмет проверки того, являются ли они, с точки зрения системы проверки, правильными. Всё это легко можно вынести в веб-воркер, что даст пользователю возможность работать с текстом, не испытывая проблем, связанных с блокировкой интерфейса при проверке слова и при поиске альтернативных вариантов его написания.


## Полезные ссылки
- #### [habr](https://habr.com/ru/companies/ruvds/articles/348424/)
- #### Книга  `Фрисби М. Ф89	JavaScript для профессиональных веб-разработчиков. 4-е международное изд. — СПб.: Питер, 2022. — 1168 с.: ил. — (Серия «Для профессионалов»). ISBN 978-5-4461-1740-6`