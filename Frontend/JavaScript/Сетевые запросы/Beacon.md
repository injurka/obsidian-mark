Beacon API используется для отправки небольших по объему данных на сервер _без ожидания ответа_. Последняя часть утверждения является наиболее интересной. Beacon API разработан специально для того, что бы можно было отправить данные и забыть о них. Не нужно ожидать ответ, так как его и не будет.

### История появления

Чтобы максимизировать объем информации, передаваемой о странице, многим аналитическим инструментам необходимо отправлять данные телеметрии или аналитики на сервер как можно позже в жизненном цикле страницы. В результате оптимальным вариантом является отправка сетевого запроса на событие `unload` браузера. Это событие сигнализирует о том, что происходит отправка страницы и что на этой странице больше не будет генерироваться никакой полезной информации.

Когда происходит событие `unload`, аналитические инструменты хотят прекратить сбор информации и попытаться отправить то, что у них есть, на сервер. Это создает проблему, так как событие `unload` означает для браузера, что нет особых оснований для отправки любых ожидающих сетевых запросов (поскольку страница все равно удаляется). Например, любые асинхронные запросы, созданные в обработчике выгрузки, будут отменены браузером. Поэтому асинхронный `XMLHttpRequest` или `fetch()` не подходит для этой задачи. Аналитические инструменты могут использовать синхронный `XMLHttpRequest` для принудительной доставки запроса, но это вызывает проблемы с пользовательским интерфейсом. Поскольку браузер приостанавливает ожидание возврата запроса, переход к следующей странице задерживается, пока браузер ожидает завершения работы обработчика выгрузки внутри обработчика `unload`.

Для решения этой проблемы W3C представил дополнительный API — Beacon. API добавляет единственный метод `sendBeacon()` к объекту `navigator`. Этот простой метод принимает URL-адрес и полезную нагрузку данных и отправляет запрос POST. Дополнительной полезной нагрузкой данных может быть экземпляр `ArrayBufferView`, `Blob`, `DOMString` или `FormData`. Метод возвращает `true`, если запрос был успешно поставлен в очередь для возможной передачи, иначе `false`.

### Пример использования

```ts
// Sends POST request
// URL: 'https://example.com/analytics-reporting-url'
// Request Payload: '{foo: "bar"}'
navigator.sendBeacon('https://example.com/analytics-reporting-url', '{foo: "bar"}');
```

1. `sendBeacon()` не ограничивается концом жизненного цикла страницы, его можно использовать в любое время.
2. После вызова `sendBeacon()` браузер добавляет запросы во внутреннюю очередь запросов. Браузер будет усиленно пытаться отправить запросы в очереди.
3. Браузер гарантирует, что попытается отправить запрос, даже после уничтожения исходной страницы.
4. Коды ответов, тайм-ауты и любые другие сбои в сети полностью непрозрачны и не могут быть обработаны программно.
5. Запрос beacon отправляется со всеми соответствующими файлами cookie в момент первоначального вызова `sendBeacon()`.
