Строковый тип (`String`) — это последовательности 16-разрядных знаков Юникода (в том числе пустые). Строки могут быть заключены в двойные (`"`), одинарные (') или обратные (`'`) кавычки:

| Литерал  | Значение                                                                                                                                 |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------- |
| `\n`     | Перевод строки                                                                                                                           |
| `\t`     | Табуляция                                                                                                                                |
| `\b`     | Возврат на одну позицию                                                                                                                  |
| `\r`     | Возврат каретки                                                                                                                          |
| `\f`     | Перевод страницы                                                                                                                         |
| `\\`     | Обратная косая черта (`\`)                                                                                                               |
| `\'`     | Одинарная кавычка (`'`). Используется, если строка заключена в одинарные кавычки, например: `'He said, \'hey.\''`                        |
| `\"`     | Двойная кавычка (`"`). Используется, если строка заключена в двойные кавычки, например: `"He said, \"hey.\""`                            |
| \`       | Обратная кавычка (`` ` ``). Используется, если строка заключена в обратные кавычки, например: `` `He said, \`hey.\`` ``                  |
| `\xnn`   | Знак с шестнадцатеричным кодом `nn` (где `n` — шестнадцатеричный знак 0-F). Пример: `\x41` эквивалентно «A»                              |
| `\unnnn` | Знак Юникода с шестнадцатеричным кодом `nnnn` (где `n` — шестнадцатеричный знак 0-F). Пример: `\u03a3` эквивалентно греческому символу Σ |


> [!INFO]
> Если строка содержит символы удвоенной разрядности, свойство `length` может возвратить неправильный результат. Стратегии смягчения послед ствий этого подробно описаны в главе 5 «Ссылочные типы».


## Природа строк

После создания строки в ECMAScript изменить ее значение невозможно. Для изменения строковой переменной первоначальная строка уничтожается, а затем переменной присваивается другая строка с новым значением:

```javascript
let lang = "Java";
lang = lang + "Script";
```

Здесь переменная `lang` определяется со значением `"Java"`. В следующей строке она переопределяется как конкатенация строк `"Java"` и `"Script"` и получает значение `"JavaScript"`. Для этого создается новая строка с местом, достаточным для хранения 10 символов, и затем оно заполняется фрагментами `"Java"` и `"Script"`. Наконец, строки `"Java"` и `"Script"` уничтожаются, потому что они больше не нужны. Все это происходит за кулисами, и именно поэтому старые браузеры (например, Firefox до версии 1.0 и Internet Explorer 6.0) очень медленно выполняли конкатенацию строк. Более поздние версии этих браузеров обрабатывают строки эффективнее.

## Преобразование значения в строку

Преобразовать значение в строку можно двумя способами. Первый — использовать метод `toString()`, который есть почти у любого значения. Он просто возвращает строковый эквивалент значения, например:

```javascript
let age = 11;
let ageAsString = age.toString();  // строка "11"

let found = true;
let foundAsString = found.toString();  // строка "true"
```

Метод `toString()` доступен для чисел, логических значений, объектов и строк (да, у каждой строки есть метод `toString()`, который просто возвращает копию строки). Для значений `null` и `undefined` вызвать его нельзя.

В большинстве случаев у метода `toString()` нет аргументов, но при использовании с числами он может принимать один аргумент: основание целевой системы счисления. По умолчанию метод `toString()` всегда возвращает строковое представление числа в десятичном формате, но если задано основание, он может вывести значение с двоичным, восьмеричным, шестнадцатеричным и любым другим допустимым основанием, например:

```javascript
let num = 10;
console.log(num.toString());  // "10"
console.log(num.toString(2));  // "1010"
console.log(num.toString(8));  // "12"
console.log(num.toString(10));  // "10"
console.log(num.toString(16));  // "a"
```

Этот пример показывает, как изменяется вывод метода `toString()` для чисел при изменении основания. Значение 10 может выводиться в самых разных числовых форматах, но по умолчанию (без аргумента) используется основание 10.

Если переменная способна принимать значение `null` или `undefined`, вы можете использовать функцию приведения типов `String()`, которая всегда возвращает строку независимо от полученного значения. Она работает следующим образом:

- если у значения есть метод `toString()`, он вызывается (без аргументов), а затем возвращается результат;
- для значения `null` возвращается строка `"null"`;
- для значения `undefined` возвращается строка `"undefined"`.

Рассмотрим следующий пример:

```javascript
let value1 = 10;
let value2 = true;
let value3 = null;
let value4;

console.log(String(value1));  // "10"
console.log(String(value2));  // "true"
console.log(String(value3));  // "null"
console.log(String(value4));  // "undefined"
```

Здесь в строки преобразуются число, логическое значение, значения `null` и `undefined`. Для числа и логического значения возвращается такой же результат, как если бы был вызван метод `toString()`. Поскольку для значений `null` и `undefined` он недоступен, для них метод `String()` просто возвращает текстовые литералы.

> [!INFO]
> Также можно преобразовать значение в строку, добавив к нему пустую строку ( "") с помощью оператора «плюс» (см. далее раздел «Операторы»).

## Шаблонные строки

В ECMAScript 6 появилась возможность определять строки с использованием шаблонных строк. В отличие от одинарных и двойных кавычек, шаблонные строки учитывают символы новой строки и могут быть определены в нескольких строках:

```javascript
let myMultiLineString = 'first line\nsecond line';
let myMultiLineTemplateLiteral = `first line
second line`;

console.log(myMultiLineString);
// first line
// second line

console.log(myMultiLineTemplateLiteral);
// first line
// second line

console.log(myMultiLineString === myMultiLineTemplateLiteral); // true
```

Как следует из названия, шаблонные строки особенно полезны при определении шаблонов, таких как HTML:

```javascript
let pageHTML = `
<div>
  <a href="#">
    <span>Jake</span>
  </a>
</div>`;
```

Поскольку шаблонные строки будут в точности учитывать пробелы внутри обратных кавычек, при их определении необходимо будет соблюдать особую осторожность. Правильно отформатированная шаблонная строка может иметь неправильный отступ:

```javascript
// Эта шаблонная строка содержит 25 пробелов за символом переноса строки
let myTemplateLiteral = `first line
second line`;
console.log(myTemplateLiteral.length); // 47

// Эта шаблонная строка начинается с символа переноса строки
let secondTemplateLiteral = `
first line
second line`;
console.log(secondTemplateLiteral[0] === '\n'); // true

// В этой шаблонной строке нет неожиданных пробельных символов
let thirdTemplateLiteral = `first line
second line`;
console.log(thirdTemplateLiteral[0]); // f
```

## Интерполяция

Одной из наиболее полезных функций шаблонных строк является их поддержка интерполяции, которая позволяет вставлять значения в одном или нескольких местах внутри одного непрерывного определения. Технически шаблонные строки не являются строками, они представляют собой специальные синтаксические выражения JavaScript, которые преобразуются в строки.

Шаблонные строки вычисляются сразу же после определения и преобразования в экземпляр строки, и любые интерполированные переменные будут извлечены из их непосредственной области видимости.

Это можно сделать с помощью выражения JavaScript внутри `${}`:

```javascript
let value = 5;
let exponent = 'second';

// Ранее интерполяция осуществлялась следующим образом:
let interpolatedString = value + ' to the ' + exponent + ' power is ' + (value * value);

// То же самое с использованием шаблонных строк:
let interpolatedTemplateLiteral = `${value} to the ${exponent} power is ${value * value}`;

console.log(interpolatedString); // 5 to the second power is 25
console.log(interpolatedTemplateLiteral); // 5 to the second power is 25
```

Интерполируемое значение в конечном итоге будет приведено к строке с помощью `toString()`, но любое выражение JavaScript можно безопасно интерполировать.

Вложенные шаблонные строки безопасны без необходимости экранирования:

```javascript
console.log(`Hello, ${`World`}!`); // Hello, World!
```

`toString()` вызывается для приведения результата выражения к строке:

```javascript
let foo = { toString: () => 'World' };
console.log(`Hello, ${foo}!`); // Hello, World!
```

Допускается вызов функций и методов внутри интерполированных выражений:

```javascript
function capitalize(word) {
  return `${word[0].toUpperCase()}${word.slice(1)}`;
}

console.log(`${capitalize('hello')}, ${capitalize('world')}!`); // Hello, World!
```

Кроме того, шаблоны могут безопасно интерполировать свои предыдущие значения:

```javascript
let value = '';
function append() {
  value = `${value}abc`;
  console.log(value);
}

append(); // abc
append(); // abcabc
append(); // abcabcabc
```

## Теговые функции шаблонных строк

Шаблонные строки также поддерживают возможность определения теговых функций, которые могут определять пользовательское поведение интерполяции. Теговая функция передает отдельные фрагменты после разбиения шаблона токеном интерполяции и после вычисления выражений.

Теговая функция определяется как обычная функция и применяется к шаблонной строке путем добавления к ней префикса, как показано в следующем коде. Теговая функция будет передавать шаблонную строку, разбитую на части: первый аргумент — это массив простых строк, а остальные аргументы — это результаты вычисленных выражений. Возвращаемое значение этой функции будет строкой, вычисленной из шаблонной строки.

Лучше всего продемонстрировать это на примере:

```javascript
let a = 6;
let b = 9;

function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
  console.log(strings);
  console.log(aValExpression);
  console.log(bValExpression);
  console.log(sumExpression);
  return 'foobar';
}

let untaggedResult = `${a} + ${b} = ${a + b}`;
let taggedResult = simpleTag`${a} + ${b} = ${a + b}`;

// ["", " + ", " = ", ""]
// 6
// 9
// 15

console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "foobar"
```

Поскольку в данном случае количество аргументов выражения переменно, обычно целесообразно использовать оператор распространения для объединения их в одну коллекцию:

```javascript
let a = 6;
let b = 9;

function simpleTag(strings, ...expressions) {
  console.log(strings);
  for (const expression of expressions) {
    console.log(expression);
  }
  return 'foobar';
}

let taggedResult = simpleTag`${a} + ${b} = ${a + b}`;

// ["", " + ", " = ", ""]
// 6
// 9
// 15

console.log(taggedResult); // "foobar"
```

Для шаблонной строки с n интерполированными значениями число аргументов выражения для теговой функции всегда будет n, а количество частей строки в первом аргументе всегда будет ровно n + 1. Поэтому, если нужно «сжать» строки и вычисленные выражения вместе в возвращаемую строку по умолчанию, можно сделать это следующим образом:

```javascript
let a = 6;
let b = 9;

function zipTag(strings, ...expressions) {
  return strings[0] + expressions.map((e, i) => `${e}${strings[i + 1]}`).join('');
}

let untaggedResult = `${a} + ${b} = ${a + b}`;
let taggedResult = zipTag`${a} + ${b} = ${a + b}`;

console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "6 + 9 = 15"
```

## Простые строки

Шаблонные строки также можно использовать, чтобы предоставить доступ к простому содержимому шаблонной строки, не преобразуя его в реальные символьные представления, такие как новая строка или символ Unicode.

Это можно сделать с помощью теговой функции `String.raw`, доступной по умолчанию.

```javascript
// Пример Unicode
// \u00A9 — знак охраны авторского права
console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9

// Пример с символом переноса строки
console.log(`first line\nsecond line`);
// first line
// second line

console.log(String.raw`first line\nsecond line`); // "first line\nsecond line"

// Это не работает для реальных символов переноса строки: они не пройдут
// преобразование из открытых экранированных эквивалентов
console.log(`first line
second line`);
// first line
// second line

console.log(String.raw`first line
second line`);
// first line
// second line
```

Простые значения также доступны как свойство для каждого элемента в коллекции частей строки внутри теговой функции:

```javascript
function printRaw(strings) {
  console.log('Actual characters:');
  for (const string of strings) {
    console.log(string);
  }

  console.log('Escaped characters:');
  for (const rawString of strings.raw) {
    console.log(rawString);
  }
}

printRaw`\u00A9${'and'}\n`;

// Actual characters:
// ©
// (newline)

// Escaped characters:
// \u00A9
// \n
```

## Источники
- #### Книга  `Фрисби М. Ф89	JavaScript для профессиональных веб-разработчиков. 4-е международное изд. — СПб.: Питер, 2022. — 1168 с.: ил. — (Серия «Для профессионалов»). ISBN 978-5-4461-1740-6`