---
tags:
  - js
keywords:
  - regex
  - js-type
title: Тип RegExp
---
Тип `RegExp` реализует в ECMAScript регулярные выражения, которые можно легко создавать, используя синтаксис, похожий на Perl:

```javascript
let expression = /pattern/flags;
```

Шаблоном может быть регулярное выражение любой сложности, включающее классы символов, квантификаторы, группировки, предпросмотр и обратные ссылки. Каждое выражение может иметь или не иметь флаги, указывающие режим сопоставления. Поддерживаются следующие флаги:

- `g` — включает глобальный режим, в котором шаблон применяется ко всей строке, то есть поиск не прекращается после обнаружения первого совпадения.
- `i` — включает режим без учета регистра, в котором при поиске совпадений регистры шаблона и строки игнорируются.
- `m` — включает многострочный режим, в котором поиск совпадений продолжается после достижения конца одной строки текста.
- `y` — включает режим закрепления, то есть поиск совпадений учитывает только содержимое строки, начиная с `lastIndex`.
- `u` — включает режим Юникода.

## Примеры создания регулярных выражений

```javascript
// Поиск всех экземпляров "at" в строке.
let pattern1 = /at/g;

// Поиск первого экземпляра "bat" или "cat" без учета регистра.
let pattern2 = /[bc]at/i;

// Поиск всех трехсимвольных сочетаний, заканчивающихся на "at", независимо от регистра.
let pattern3 = /.at/gi;
```

## Метасимволы в регулярных выражениях

В регулярных выражениях используются метасимволы, которые нужно экранировать, если требуется сопоставить их со строкой. Доступны следующие метасимволы:

```
( [ { \ ^ $ | ) ] } ? * + .
```

### Примеры экранирования метасимволов

```javascript
// Поиск первого экземпляра "bat" или "cat" без учета регистра.
let pattern1 = /[bc]at/i;

// Поиск первого экземпляра "[bc]at" без учета регистра.
let pattern2 = /\[bc\]at/i;

// Поиск всех трехсимвольных сочетаний, заканчивающихся на "at", без учета регистра.
let pattern3 = /.at/gi;

// Поиск всех экземпляров ".at" без учета регистра.
let pattern4 = /\.at/gi;
```

## Создание регулярных выражений с помощью конструктора `RegExp`

Регулярные выражения можно создавать не только с помощью литералов, но и с помощью конструктора `RegExp`. Он принимает два аргумента: строковый шаблон для сопоставления и необязательную строку флагов.

```javascript
// Поиск первого экземпляра "bat" или "cat" без учета регистра.
let pattern1 = /[bc]at/i;

// То же, что и pattern1, но с использованием конструктора.
let pattern2 = new RegExp("[bc]at", "i");
```

### Экранирование в строках для конструктора `RegExp`

Поскольку шаблон передается в конструктор `RegExp` как строка, иногда его знаки могут требовать двойного экранирования. В следующей таблице приведены некоторые шаблоны в форме литералов и эквивалентные строки для передачи в конструктор `RegExp`:

| Литерал шаблона    | Строковый эквивалент    |
| ------------------ | ----------------------- |
| `/\[bc\]at/`       | `"\\[bc\\]at"`          |
| `/\.at/`           | `"\\.at"`               |
| `/name\/age/`      | `"name\\/age"`          |
| `/\d.\d{1,2}/`     | `"\\d.\\d{1,2}"`        |
| `/\w\\hello\\123/` | `"\\w\\\\hello\\\\123"` |

## Различия между литералами и конструктором `RegExp`

Определить регулярное выражение на основе литерала и создать его с помощью конструктора `RegExp` — это не совсем одно и то же. В ECMAScript литералы регулярных выражений всегда относятся к одному экземпляру `RegExp`, тогда как вызов конструктора типа `RegExp` каждый раз создает его новый экземпляр.

```javascript
let re = null;
for (let i = 0; i < 10; i++) {
  re = /cat/g;
  re.test("catastrophe");
}

for (let i = 0; i < 10; i++) {
  re = new RegExp("cat", "g");
  re.test("catastrophe");
}
```

В первом цикле создается только один экземпляр `RegExp` для шаблона `/cat/`, несмотря на то что он указан в теле цикла. Свойства экземпляра не сбрасываются, из-за чего метод `test()` каждый второй раз не может обнаружить шаблон `/cat/` в строке.

Во втором цикле используется конструктор `RegExp`, который на каждой итерации создает новое регулярное выражение, поэтому каждый вызов метода `test()` возвращает `true`.

## Копирование и изменение флагов регулярных выражений

Также можно скопировать существующие экземпляры регулярного выражения и при необходимости изменить их флаги с помощью конструктора:

```javascript
const re1 = /cat/g;
console.log(re1); // "/cat/g"

const re2 = new RegExp(re1);
console.log(re2); // "/cat/g"

const re3 = new RegExp(re1, "i");
console.log(re3); // "/cat/i"
```

## Свойства экземпляра `RegExp`

У каждого экземпляра `RegExp` есть следующие свойства, позволяющие получить сведения о шаблоне:

- **global** — логическое значение, указывающее, задан ли флаг `g`.
- **ignoreCase** — логическое значение, указывающее, задан ли флаг `i`.
- **unicode** — логическое значение, указывающее, задан ли флаг `u`.
- **sticky** — логическое значение, указывающее, задан ли флаг `y`.
- **lastIndex** — целое число, указывающее позицию в исходной строке, где сопоставление будет выполнено в следующий раз (это значение всегда первоначально равно 0).
- **multiline** — логическое значение, указывающее, задан ли флаг `m`.
- **source** — исходная строка регулярного выражения, которая всегда возвращается в форме литерала (без открывающей и закрывающей косых черт), а не как строковый шаблон, переданный в конструктор.
- **flags** — строковые флаги регулярного выражения. Данное свойство всегда возвращается, как если бы оно было указано в буквальной форме (без открывающей и закрывающей косой черты), а не в виде строкового шаблона, переданного в конструктор.

С помощью этих свойств можно получить полезную информацию о регулярном выражении, но они используются редко, потому что эта информация доступна в объявлении шаблона. Например:

```javascript
let pattern1 = /\[bc\]at/i;
console.log(pattern1.global);      // false
console.log(pattern1.ignoreCase);  // true
console.log(pattern1.multiline);   // false
console.log(pattern1.lastIndex);   // 0
console.log(pattern1.source);      // "\[bc\]at"
console.log(pattern1.flags);       // "i"

let pattern2 = new RegExp("\\[bc\\]at", "i");
console.log(pattern2.global);      // false
console.log(pattern2.ignoreCase);  // true
console.log(pattern2.multiline);   // false
console.log(pattern2.lastIndex);   // 0
console.log(pattern2.source);      // "\[bc\]at"
console.log(pattern2.flags);       // "i"
```

Заметьте, что значения свойства `source` и `flags` у обоих шаблонов одинаковы, хотя первый представлен в формате литерала, а второй был передан в конструктор `RegExp`. Свойства `source` и `flags` форматируют строку как литерал.

## Методы экземпляра `RegExp`

### Метод `exec()`

Главный метод объекта `RegExp` называется `exec()` и предназначен для работы с группами захвата. Он принимает в качестве единственного аргумента строку, к которой нужно применить шаблон, и возвращает массив со сведениями о первом совпадении или значение `null`, если совпадения отсутствуют. Возвращенный массив является экземпляром `Array`, но содержит два дополнительных свойства:

- **index** — место в строке, где было зарегистрировано совпадение с шаблоном.
- **input** — исходная строка для сопоставления с шаблоном.

Первым элементом массива является строка, соответствующая всему шаблону, а любые дополнительные элементы представляют захваченные группы в выражении (если в шаблоне нет групп захвата, массив содержит только один элемент).

#### Пример использования `exec()`:

```javascript
let text = "mom and dad and baby";
let pattern = /mom( and dad( and baby)?)?/gi;
let matches = pattern.exec(text);

console.log(matches.index);  // 0
console.log(matches.input);  // "mom and dad and baby"
console.log(matches[0]);     // "mom and dad and baby"
console.log(matches[1]);     // " and dad and baby"
console.log(matches[2]);     // " and baby"
```

В этом примере у шаблона две группы захвата. Внутренняя сопоставляется со строкой " and baby", а охватывающая ее — со строкой " and dad" или " and dad and baby".

#### Глобальный поиск и `exec()`:

Если флаг глобального поиска не указан, многократные вызовы метода `exec()` для одной и той же строки всегда возвращают сведения о первом совпадении.

```javascript
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = pattern.exec(text);

console.log(matches.index);  // 0
console.log(matches[0]);     // cat
console.log(pattern.lastIndex);  // 0
```

При установленном глобальном флаге `g` в шаблоне каждый вызов `exec()` перемещается дальше в строку в поисках совпадений.

```javascript
let text = "cat, bat, sat, fat";
let pattern = /.at/g;
let matches = pattern.exec(text);

console.log(matches.index);  // 0
console.log(matches[0]);     // cat
console.log(pattern.lastIndex);  // 3

matches = pattern.exec(text);
console.log(matches.index);  // 5
console.log(matches[0]);     // bat
console.log(pattern.lastIndex);  // 8
```

### Метод `test()`

Если требуется выяснить, соответствует ли строка шаблону, но текст совпадения не нужен, можно использовать метод `test()`. Он принимает строковый аргумент и возвращает `true`, если шаблон соответствует аргументу, или `false` в противном случае.

#### Пример использования `test()`:

```javascript
let text = "000-00-0000";
let pattern = /\d{3}-\d{2}-\d{4}/;

if (pattern.test(text)) {
  console.log("The pattern was matched.");  // Обнаружено соответствие шаблону
}
```

### Унаследованные методы

Унаследованные методы `toLocaleString()` и `toString()` возвращают литерал регулярного выражения независимо от того, как оно было создано.

#### Пример использования `toLocaleString()` и `toString()`:

```javascript
let pattern = new RegExp("\\[bc\\]at", "gi");
console.log(pattern.toString());  // /\[bc\]at/gi
console.log(pattern.toLocaleString());  // /\[bc\]at/gi
```

### Метод `valueOf()`

Метод `valueOf()` типа `RegExp` возвращает само регулярное выражение.

## Свойства конструктора `RegExp`

У функции конструктора `RegExp` есть несколько свойств, которые применяются ко всем регулярным выражениям в области видимости и изменяются согласно последней операции с регулярным выражением. Эти свойства уникальны тем, что есть два способа доступа к ним: по полному и по сокращенному имени.

### Таблица свойств

| Сокращенное имя | Полное имя | Описание                                                |
| --------------- | ---------- | ------------------------------------------------------- |
| `input`         | `$_`       | Последняя строка, для которой выполнялось сопоставление |
| `lastMatch`     | `$&`       | Последний совпавший текст                               |
| `lastParen`     | `$+`       | Последняя совпавшая группа захвата                      |
| `leftContext`   | `$`        | Текст в строке `input` перед `lastMatch`                |
| `rightContext`  | `$'`       | Текст в строке `input` после `lastMatch`                |

### Пример использования

Эти свойства можно использовать для извлечения сведений об операции, выполненной методом `exec()` или `test()`.

```javascript
let text = "this has been a short summer";
let pattern = /(.)hort/g;

if (pattern.test(text)) {
  console.log(RegExp.input);       // this has been a short summer
  console.log(RegExp.leftContext); // this has been a
  console.log(RegExp.rightContext); // summer
  console.log(RegExp.lastMatch);   // short
  console.log(RegExp.lastParen);   // s
  console.log(RegExp.multiline);   // false
}
```

В этом коде создается шаблон, который ищет любой знак, предшествующий строке "hort", и определяет группу захвата для первой буквы. Со свойствами при этом происходит следующее:

- `input` содержит исходную строку.
- `leftContext` содержит символы строки до слова "short", а `rightContext` — после слова "short".
- `lastMatch` содержит последнюю строку, которая соответствует всему регулярному выражению, или "short".
- `lastParen` содержит последнюю совпавшую группу захвата, или "s" в данном случае.

### Доступ к свойствам через сокращенные имена

Полные имена свойств можно заменить сокращенными, но для доступа к ним нужно использовать квадратные скобки, потому что большинство из них не являются допустимыми ECMAScript-идентификаторами.

```javascript
let text = "this has been a short summer";
let pattern = /(.)hort/g;

if (pattern.test(text)) {
  console.log(RegExp.$_);    // this has been a short summer
  console.log(RegExp["$`"]); // this has been a
  console.log(RegExp["$'"]); // summer
  console.log(RegExp["$&"]); // short
  console.log(RegExp["$+"]); // s
  console.log(RegExp["$*"]); // false
}
```

### Свойства для групп захвата

У конструктора также есть свойства, хранящие до девяти совпадений с группами захвата. Они имеют имена с `RegExp.$1` (первое совпадение) по `RegExp.$9` (девятое совпадение). Эти свойства заполняются при вызове метода `exec()` или `test()`.

```javascript
let text = "this has been a short summer";
let pattern = /(..)or(.)/g;

if (pattern.test(text)) {
  console.log(RegExp.$1); // sh
  console.log(RegExp.$2); // t
}
```

В этом примере создается шаблон с двумя группами сопоставления, который затем применяется к строке. Хотя метод `test()` просто возвращает логическое значение, при этом также заполняются свойства `$1` и `$2` конструктора `RegExp`.

> [!WARN] Примечание
> Все эти свойства конструктора `RegExp` не являются частью какого-либо веб-стандарта; избегайте использования в любом реальном приложении.

## Ограничения шаблонов в ECMAScript

В целом поддержка регулярных выражений в языке ECMAScript очень хороша, но в нем нет некоторых нетривиальных возможностей, доступных в таких языках, как Perl. Например, следующие функциональные возможности в ECMAScript не поддерживаются (дополнительные сведения см. на сайте [www.regularexpressions.info](http://www.regularexpressions.info)

- **якоря \A и \Z** (начало и конец строки соответственно);
- **обратный просмотр**;
- **классы объединения и пересечения**;
- **атомарные группировки**;
- **поддержка Юникода** (исключая сопоставление с одним символом за раз);
- **именованные группы захвата**;
- **режимы сопоставления s (однострочный) и x (с пробельными символами)**;
- **условия**;
- **комментарии в регулярных выражениях**.

Несмотря на эти ограничения, имеющихся в ECMAScript возможностей достаточно для решения большинства задач сопоставления с шаблонами.

## Источники
- #### Книга  `Фрисби М. Ф89	JavaScript для профессиональных веб-разработчиков. 4-е международное изд. — СПб.: Питер, 2022. — 1168 с.: ил. — (Серия «Для профессионалов»). ISBN 978-5-4461-1740-6`