---
tags:
  - js
keywords:
  - string
  - js-type
title: Объект String в JavaScript
---
Тип **String** — это ссылочный аналог строк. Объекты этого типа создаются с помощью конструктора `String`:

```javascript
let stringObject = new String("hello world");
```

Методы объекта `String` доступны для всех строковых примитивов. Все три унаследованных метода — `valueOf()`, `toLocaleString()` и `toString()` — возвращают примитивное строковое значение объекта.

## Свойство length

Каждый экземпляр `String` содержит единственное свойство `length`, в котором хранится количество знаков в строке, например:

```javascript
let stringValue = "hello world";
console.log(stringValue.length);
// "11"
```

В этом примере выводится строка `"11"`, отражающая количество знаков в строке `"hello world"`. Имейте в виду, что даже если строка содержит двухбайтовые символы, а не только однобайтовые ASCII-символы, каждый символ все равно считается за один.

## Символ в JavaScript

Строки в JavaScript состоят из 16-битных единиц кода. Для большинства символов каждая 16-битная единица кода будет соответствовать одному символу. Свойство `length` указывает на количество 16-битных кодовых единиц внутри строки:

```javascript
let message = "abcde";
console.log(message.length); // 5
```

Кроме того, `charAt()` возвращает символ по заданному индексу, указанному целочисленным аргументом метода. В частности, этот метод находит 16-битную единицу кода по указанному индексу и возвращает символ, соответствующий этой единице кода:

```javascript
let message = "abcde";
console.log(message.charAt(2)); // "c"
```

Строки в JavaScript используют гибрид двух кодировок Юникода: UCS-2 и UTF-16. Для символов, которые могут быть закодированы 16 битами (от U+0000 до U+FFFF), эти два кодирования фактически идентичны.

> [!WARN] Примечание 
> Для всестороннего освещения кодировки символов проверьте превосходное сообщение в блоге Джоэла Спольски: [The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)](https://www.joelonsoftware.com/2003/10/08/theabsolute-minimum-every-software-developer-absolutely-positively-mustknow-about-unicode-and-character-sets-no-excuses/).
> 
> Другим хорошим ресурсом является сообщение в блоге Матиаса Биненса: [JavaScript Character Encoding](https://mathiasbynens.be/notes/javascript-encoding).

Можно проверить кодировку символов данного блока кода с помощью метода `charCodeAt()`. Этот метод возвращает значение единицы кода по заданному индексу (целочисленному аргументу метода). Вот пример:

```javascript
let message = "abcde";
// "Латинская строчная буква C" в Юникоде — U + 0063
console.log(message.charCodeAt(2)); // 99
// Десятичное 99 === шестнадцатеричное 63
console.log(99 === 0x63); // true
```

Метод `fromCharCode()` используется для создания символов в строке из их представления в качестве единиц кода в UTF-16. Этот метод принимает любое количество чисел и возвращает их символьные эквиваленты, объединенные в строку:

```javascript
// "Латинская маленькая буква A" в Юникоде — U+0061
// "Латинская маленькая буква B" в Юникоде — U+0062
// "Латинская маленькая буква C" в Юникоде — U+0063
// "Латинская маленькая буква D" в Юникоде — U+0064
// "Латинская маленькая буква E" в Юникоде — U+0065
console.log(String.fromCharCode(0x61, 0x62, 0x63, 0x64, 0x65)); // "abcde"
// 0x0061 === 97
// 0x0062 === 98
// 0x0063 === 99
// 0x0064 === 100
// 0x0065 === 101
console.log(String.fromCharCode(97, 98, 99, 100, 101)); // "abcde"
```

Для символов в диапазоне от U+0000 до U+FFFF `length`, `charAt()`, `charCodeAt()` и `fromCharCode()` ведут себя точно так, как ожидается, потому что каждый символ представлен ровно 16 битами и каждый из этих методов работает на 16-битных единицах кода. Пока есть четность между размером кодировки символов и размером кодовой единицы, эти методы будут вести себя ожидаемо.

Этот паритет нарушается при расширении в область дополнительных символьных плоскостей Юникода. Идея этой концепции относительно проста: 16 битов могут однозначно представлять только 65 536 символов. Этого достаточно, чтобы охватить большинство языковых наборов символов, и данный набор называется Базовой многоязычной плоскостью (Basic Multilingual Plane, BMP). Чтобы ввести еще больше символов, Юникод определил стратегию, которая использовала дополнительные 16 бит на символ для выбора дополнительной, или астральной, плоскости. Использование двух 16-битных кодовых единиц на символ называется суррогатной парой.

С введением этого соглашения ранее обсужденные строковые методы начинают разрушаться. Рассмотрим следующий пример, в котором используется смайлик — символ, закодированный с помощью суррогатной пары:

```javascript
// Код смайла "улыбающееся лицо с глазами" — U+1F60A
// 0x1F60A === 128522
let message = "ab☺de";
console.log(message.length); // 6
console.log(message.charAt(1)); // b
console.log(message.charAt(2)); // <?>
console.log(message.charAt(3)); // <?>
console.log(message.charAt(4)); // d
console.log(message.charCodeAt(1)); // 98
console.log(message.charCodeAt(2)); // 55357
console.log(message.charCodeAt(3)); // 56842
console.log(message.charCodeAt(4)); // 100
console.log(String.fromCharCode(0x1F60A)); // ☺
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺de
```

Эти методы по-прежнему обрабатывают каждую 16-битную единицу кода как отдельный символ, когда фактически единицы кода в индексах 2 и 3 необходимо рассматривать вместе как одну суррогатную пару, чтобы сформировать один символ. Метод `fromCharCode()` по-прежнему работает правильно, используя две отдельные единицы кода, потому что этот метод буквально собирает строку из предоставленного двоичного представления. Браузер может правильно анализировать суррогатную пару (которая была собрана как две отдельные единицы кода) и правильно интерпретировать ее как один символ Юникода со смайликом.

Чтобы правильно проанализировать строку, содержащую как единичный код, так и символы суррогатной пары, можно использовать метод `codePointAt()` вместо подверженного ошибкам `charAt()`. Как и в случае с `charAt()`, данный метод принимает 16-битный индекс единицы кода и возвращает кодовую точку с этим индексом. Кодовая точка относится к полному идентификатору Юникода для одного символа. Кодовая точка для `"c"` — 0x0063. Кодовая точка для `"☺"` — 0x1F60A. Для полного представления кодовых точек может потребоваться 16 или 32 бита, а метод `codePointAt()` идентифицирует полную кодовую точку, начиная с указанной единицы кода.

```javascript
let message = "ab☺de";
console.log(message.codePointAt(1)); // 98
console.log(message.codePointAt(2)); // 128522
console.log(message.codePointAt(3)); // 56842
console.log(message.codePointAt(4)); // 100
```

Обратите внимание, что в этом примере кодовая точка может быть неверно идентифицирована, если она нацелена на индекс единицы кода, не являющийся началом суррогатной пары. Это проблематично только для одноразовой проверки символов, и это можно предотвратить, обойдя строку слева направо и увеличив правильное количество единиц кода на итератор. Итератор для строки достаточно умен, чтобы идентифицировать кодовые точки суррогатной пары:

```javascript
console.log([..."ab☺de"]); // ["a", "b", "☺", "d", "e"]
```

Подобно тому как `charAt()` имеет аналог `codePointAt()`, у `fromCharCode()` есть аналог `fromCodePoint()`. Этот метод принимает любое количество номеров кодовых точек и возвращает их символьные эквиваленты, объединенные в строку:

```javascript
console.log(String.fromCharCode(97, 98, 55357, 56842, 100, 101)); // ab☺de
console.log(String.fromCodePoint(97, 98, 128522, 100, 101)); // ab☺de
```

## Метод `normalize()`

Некоторые символы Юникода могут быть закодированы несколькими способами. Иногда символ может быть представлен либо одним символом BMP, либо суррогатной парой. Для примера рассмотрим следующее:

```javascript
// U+00C5: Латинская заглавная буква A с кольцом над ней
console.log(String.fromCharCode(0x00C5)); // Å
// U+212B: Знак ангстрема
console.log(String.fromCharCode(0x212B)); // Å
// U+0041: Латинская заглавная буква A
// U+030A: Комбинированное кольцо над ней
console.log(String.fromCharCode(0x0041, 0x030A)); // Å
```

Операторы сравнения не заботятся о внешнем виде символов, и поэтому три символа ниже будут считаться различными:

```javascript
let a1 = String.fromCharCode(0x00C5),
    a2 = String.fromCharCode(0x212B),
    a3 = String.fromCharCode(0x0041, 0x030A);

console.log(a1, a2, a3); // Å, Å, Å
console.log(a1 === a2); // false
console.log(a1 === a3); // false
console.log(a2 === a3); // false
```

Юникод объясняет это, предлагая четыре формы нормализации, с помощью которых символы, подобные этому, можно нормализовать в согласованный формат независимо от происхождения их кодов символов. Эти четыре формы нормализации — форма нормализации D (NFD), форма нормализации C (NFC), форма нормализации KD (NFKD) и форма нормализации KC (NFKC), могут быть применены к строке с помощью метода `normalize()`. Этот метод должен быть снабжен строковым идентификатором, чтобы указать, какую форму нормализации применять: NFD, NFC, NFKD или NFKC.

>[!WARN] Примечание
> Специфика каждой из этих нормальных форм выходит за рамки этого текста. Обратитесь к [http://unicode.org/reports/tr15/](http://unicode.org/reports/tr15/) для получения дополнительной информации.

Можно определить, нормализована ли уже строка, проверив ее по возвращаемому значению `normalize()`:

```javascript
let a1 = String.fromCharCode(0x00C5),
    a2 = String.fromCharCode(0x212B),
    a3 = String.fromCharCode(0x0041, 0x030A);

// U+00C5 — нормализованная форма NFC/NFKC для 0+212B
console.log(a1 === a1.normalize("NFD")); // false
console.log(a1 === a1.normalize("NFC")); // true
console.log(a1 === a1.normalize("NFKD")); // false
console.log(a1 === a1.normalize("NFKC")); // true

// U+212B не нормализован
console.log(a2 === a2.normalize("NFD")); // false
console.log(a2 === a2.normalize("NFC")); // false
console.log(a2 === a2.normalize("NFKD")); // false
console.log(a2 === a2.normalize("NFKC")); // false

// U+0041/U+030A — нормализованная форма NFD/NFKD для 0+212B
console.log(a3 === a3.normalize("NFD")); // true
console.log(a3 === a3.normalize("NFC")); // false
console.log(a3 === a3.normalize("NFKD")); // true
console.log(a3 === a3.normalize("NFKC")); // false
```

Выбор нормальной формы позволит оператору сравнения при проверке одинаковых символов вести себя ожидаемо:

```javascript
let a1 = String.fromCharCode(0x00C5),
    a2 = String.fromCharCode(0x212B),
    a3 = String.fromCharCode(0x0041, 0x030A);

console.log(a1.normalize("NFD") === a2.normalize("NFD")); // true
console.log(a2.normalize("NFKC") === a3.normalize("NFKC")); // true
console.log(a1.normalize("NFC") === a3.normalize("NFC")); // true
```

## Методы поиска строк

Есть два метода поиска подстрок в других строках: `indexOf()` и `lastIndexOf()`. Оба метода ищут в строке конкретную подстроку и возвращают ее позицию (или `-1`, если найти ее не удается). Разница между ними в том, что метод `indexOf()` начинает искать подстроку с начала строки, а `lastIndexOf()` — с конца. Рассмотрим пример:

```javascript
let stringValue = "hello world";
console.log(stringValue.indexOf("o")); // 4
console.log(stringValue.lastIndexOf("o")); // 7
```

Здесь первая подстрока `"o"` встречается в позиции 4, это буква `"o"` в слове `"hello"`. Последнее вхождение подстроки `"o"` в строку имеет место в позиции 7 в слове `"world"`. Если бы в строке содержалась только одна буква `"o"`, методы `indexOf()` и `lastIndexOf()` вернули бы одно и то же значение.

Оба метода могут принимать необязательный второй аргумент, указывающий начальную позицию поиска в строке. Иначе говоря, метод `indexOf()` выполняет поиск с этой позиции до конца строки, пропуская все символы перед начальной позицией, а метод `lastIndexOf()` начинает поиск с указанной позиции и продвигается к началу строки, пропуская символы между указанной позицией и концом строки:

```javascript
let stringValue = "hello world";
console.log(stringValue.indexOf("o", 6)); // 7
console.log(stringValue.lastIndexOf("o", 6)); // 4
```

Как видите, если в каждый метод передать второй аргумент 6, возвращаются результаты, противоположные предыдущим. На этот раз метод `indexOf()` возвращает 7, потому что он начинает поиск подстроки с позиции 6 (буква `"w"`) и обнаруживает букву `"o"` в позиции 7. Метод `lastIndexOf()` возвращает 4, потому что он начинает поиск с позиции 6 и продвигается к началу строки, пока не встречает букву `"o"` в слове `"hello"`. С помощью второго аргумента можно найти все экземпляры подстроки в строке, циклически вызывая метод `indexOf()` или `lastIndexOf()`:

```javascript
let stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing...";
let positions = new Array();
let pos = stringValue.indexOf("e");

while(pos > -1) {
    positions.push(pos);
    pos = stringValue.indexOf("e", pos + 1);
}

console.log(positions); // "3,24,32,35"
```

Этот фрагмент обрабатывает строку, постоянно увеличивая позицию, в которой метод `indexOf()` начинает поиск. Сначала определяется позиция первой подстроки `"e"` в строке, а затем запускается цикл, в котором в метод `indexOf()` каждый раз передается позиция последней обнаруженной буквы `"e"`, увеличенная на 1. Благодаря этому поиск продолжается после обнаружения каждой подстроки. Позиции подстрок сохраняются в массиве `positions`, чтобы эти данные можно было использовать позже.

## Методы включения строк

В ECMAScript 6 добавлены три дополнительных метода для определения того, включена ли строка в другую строку: `startsWith()`, `endsWith()` и `includes()`. Все методы ищут строку для данной подстроки и возвращают логическое значение, указывающее, включено ли оно или нет. Разница между ними заключается в том, что `startsWith()` проверяет совпадение, начинающееся с индекса 0, `endsWith()` проверяет совпадение, начинающееся с индекса `(string.length - substring.length)`, и `includes()` проверяет всю строку.

```javascript
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("bar")); // false
console.log(message.endsWith("baz")); // true
console.log(message.endsWith("bar")); // false
console.log(message.includes("bar")); // true
console.log(message.includes("qux")); // false
```

Методы `startsWith()` и `includes()` принимают необязательный второй аргумент, который указывает позицию для начала поиска внутри строки. Это означает, что методы начнут поиск с этой позиции и пойдут к концу строки, игнорируя все до начальной позиции. Вот пример:

```javascript
let message = "foobarbaz";
console.log(message.startsWith("foo")); // true
console.log(message.startsWith("foo", 1)); // false
console.log(message.includes("bar")); // true
console.log(message.includes("bar", 4)); // false
```

Метод `endsWith()` принимает необязательный второй аргумент, который указывает позицию, которая должна рассматриваться как конец строки. Если это значение не указано, длина строки используется по умолчанию. Если указан второй аргумент, метод будет обрабатывать строку так, как если бы она имела столько символов:

```javascript
let message = "foobarbaz";
console.log(message.endsWith("bar")); // false
console.log(message.endsWith("bar", 6)); // true
```

## Метод `trim()`

В ECMAScript введен метод `trim()`, который создает копию строки, удаляет все начальные и конечные пробельные символы, а затем возвращает результат, например:

```javascript
let stringValue = " hello world ";
let trimmedStringValue = stringValue.trim();
console.log(stringValue); // " hello world "
console.log(trimmedStringValue); // "hello world"
```

Также доступны методы `trimLeft()` и `trimRight()`, которые удаляют только начальные и только конечные пробельные символы соответственно.

## Метод `repeat()`

В ECMAScript существует метод `repeat()` для всех строк. Метод `repeat()` принимает один целочисленный аргумент `count`, копирует строки `count` раз и объединяет все копии.

```javascript
let stringValue = "na ";
console.log(stringValue.repeat(16) + "batman");
// na na na na na na na na na na na na na na na na batman
```

## Методы `padStart()` и `padEnd()`

Методы `padStart()` и `padEnd()` копируют строку и, если длина строки меньше указанной длины, добавляют отступы с любой стороны строки, чтобы расширить ее до определенной длины. Первый аргумент — желаемая длина, а второй — необязательная строка, добавляемая в качестве заполнителя. Если не указано иное, будет использоваться символ пробела U + 0020.

```javascript
let stringValue = "foo";
console.log(stringValue.padStart(6)); // "  foo"
console.log(stringValue.padStart(9, ".")); // "......foo"
console.log(stringValue.padEnd(6)); // "foo  "
console.log(stringValue.padEnd(9, ".")); // "foo......"
```

Необязательный аргумент не ограничивается одним символом. Если предоставлена многосимвольная строка, метод будет использовать конкатенированные отступы и урезать их до точной длины. Кроме того, если длина меньше либо равна длине строки, операция, по сути, запрещена.

```javascript
let stringValue = "foo";
console.log(stringValue.padStart(8, "bar")); // "barbafoo"
console.log(stringValue.padStart(2)); // "foo"
console.log(stringValue.padEnd(8, "bar")); // "foobarba"
console.log(stringValue.padEnd(2)); // "foo"
```

```md
# Строковые итераторы и деструктурирование

Прототип строки предоставляет метод `@@iterator` для каждой строки, позволяющий выполнять итерацию по отдельным символам. Ручное использование итератора работает следующим образом:

```javascript
let message = "abc";
let stringIterator = message[Symbol.iterator]();
console.log(stringIterator.next()); // {value: "a", done: false}
console.log(stringIterator.next()); // {value: "b", done: false}
console.log(stringIterator.next()); // {value: "c", done: false}
console.log(stringIterator.next()); // {value: undefined, done: true}
```

При использовании в цикле `for...of` цикл будет использовать этот итератор для посещения каждого символа в следующем порядке:

```javascript
for (const c of "abcde") {
  console.log(c);
}
// a
// b
// c
// d
// e
```

Строковый итератор становится особенно полезным, поскольку он допускает взаимодействие с оператором деструктурирования. Это позволяет легко разделить строку по символам:

```javascript
let message = "abcde";
console.log([...message]); // ["a", "b", "c", "d", "e"]
```

## Методы изменения регистра символов

Для изменения регистра символов можно использовать методы `toLowerCase()`, `toLocaleLowerCase()`, `toUpperCase()` и `toLocaleUpperCase()`. Методы `toLowerCase()` и `toUpperCase()` созданы по образцу аналогичных Java-методов (`java.lang.String`), а методы `toLocaleLowerCase()` и `toLocaleUpperCase()`, по идее, должны быть реализованы на основе конкретного регионального стандарта. Во многих региональных стандартах эти методы не отличаются от универсальных, но в некоторых языках, например в турецком, действуют специальные правила преобразования регистра символов Юникода, что требует использования специфичных методов. Вот некоторые примеры:

```javascript
let stringValue = "hello world";
console.log(stringValue.toLocaleUpperCase()); // "HELLO WORLD"
console.log(stringValue.toUpperCase()); // "HELLO WORLD"
console.log(stringValue.toLocaleLowerCase()); // "hello world"
console.log(stringValue.toLowerCase()); // "hello world"
```

Здесь методы `toLocaleUpperCase()` и `toUpperCase()` выводят строку "HELLO WORLD", а методы `toLocaleLowerCase()` и `toLowerCase()` — "hello world". Если вы не знаете, в какой языковой среде будет выполняться код, безопаснее использовать методы, специфичные для регионального стандарта.

```md
# Методы сопоставления строк с шаблонами

Тип `String` содержит несколько методов для сопоставления строк с шаблонами.

## Метод `match()`

Метод `match()` аналогичен методу `exec()` объекта `RegExp`. В качестве единственного аргумента он принимает или строку регулярного выражения, или объект `RegExp`, например:

```javascript
let text = "cat, bat, sat, fat";
let pattern = /.at/;
let matches = text.match(pattern);
console.log(matches.index); // 0
console.log(matches[0]); // "cat"
console.log(pattern.lastIndex); // 0
```

Метод `match()` возвращает такой же массив, что и метод `exec()` объекта `RegExp`, когда в него передается строка. Первым элементом массива является строка, которая соответствует всему шаблону, а все остальные элементы (если они есть) представляют группы захвата в выражении.

## Метод `search()`

Метод `search()` принимает такой же аргумент, что и метод `match()`, а именно — регулярное выражение в форме строки или объекта `RegExp`. Метод `search()` возвращает индекс первого вхождения шаблона в строку или `-1`, если найти его не удается. Поиск шаблона ведется с начала строки. Вот пример:

```javascript
let text = "cat, bat, sat, fat";
let pos = text.search(/at/);
console.log(pos); // 1
```

Здесь вызов `search(/at/)` возвращает `1` — позицию первого вхождения подстроки `"at"` в строку.

## Метод `replace()`

Чтобы упростить замену подстрок, ECMAScript предоставляет метод `replace()`, который принимает два аргумента. Первым может быть объект `RegExp` или строка (она не преобразуется в регулярное выражение), вторым — строка или функция. Если первым аргументом является строка, заменяется только первое вхождение подстроки в строку. Чтобы заменить все экземпляры подстроки, необходимо передать в метод регулярное выражение с глобальным флагом, например:

```javascript
let text = "cat, bat, sat, fat";
let result = text.replace("at", "ond");
console.log(result); // "cond, bat, sat, fat"
result = text.replace(/at/g, "ond");
console.log(result); // "cond, bond, sond, fond"
```

Если второй аргумент является строкой, для вставки значений можно использовать несколько специальных последовательностей символов. Доступные в ECMA-262 последовательности представлены в таблице:

| Последовательность | Текст для замены                                                                                                                                                       |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `$$`               | `$`                                                                                                                                                                    |
| `$&`               | Подстрока, совпадающая со всем шаблоном. То же, что `RegExp.lastMatch`                                                                                                 |
| `$'`               | Часть строки после совпавшей подстроки. То же, что `RegExp.rightContext`                                                                                               |
| `$`                | Часть строки перед совпавшей подстрокой. То же, что `RegExp.leftContext`                                                                                               |
| `$n`               | n-ная группа захвата, где n — значение от 0 до 9. Например, `$1` — это первая группа захвата, `$2` — вторая и т. д. Если захвата нет, используется пустая строка       |
| `$nn`              | nn-ная группа захвата, где nn — значение от 01 до 99. Например, `$01` — это первая группа захвата, `$02` — вторая и т. д. Если захвата нет, используется пустая строка |

С помощью этих специальных последовательностей можно заменять подстроки, используя сведения о последнем совпадении, например:

```javascript
let text = "cat, bat, sat, fat";
result = text.replace(/(.at)/g, "word ($1)");
console.log(result); // "word (cat), word (bat), word (sat), word (fat)"
```

Второй аргумент метода `replace()` может быть функцией. При наличии одного совпадения в нее передаются три аргумента: совпадение, позиция совпадения в строке и вся строка. Если групп захвата несколько, каждая совпавшая строка передается в функцию как аргумент, при этом двумя последними аргументами являются позиция совпадения с шаблоном в строке и оригинальная строка. Функция должна возвращать строку, указывающую, чем следует заменить совпадение. Использование функции в качестве второго аргумента обеспечивает более детальный контроль над текстом для замены, например:

```javascript
function htmlEscape(text) {
  return text.replace(/[<>"&]/g, function(match, pos, originalText) {
    switch(match) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      case "\"":
        return "&quot;";
    }
  });
}

console.log(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
// "&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;"
```

Здесь определяется функция `htmlEscape()`, которая обрабатывает знаки «меньше», «больше», амперсанды и двойные кавычки, подготавливая их к вставке в HTML-код. Для этого выполняется поиск этих знаков с помощью регулярного выражения, а затем определяется функция, которая возвращает специфические HTML-сущности для каждого совпавшего знака.

## Метод `split()`

Метод `split()` разбивает строку на массив подстрок по разделителю, которым может быть строка или объект `RegExp` (в этом методе строка не считается регулярным выражением). Необязательный второй аргумент, ограничение массива, гарантирует, что возвращенный массив не будет превышать определенный размер. Рассмотрим пример:

```javascript
let colorText = "red,blue,green,yellow";
let colors1 = colorText.split(","); // ["red", "blue", "green", "yellow"]
let colors2 = colorText.split(",", 2); // ["red", "blue"]
let colors3 = colorText.split(/[^\,]+/); // ["", ",", ",", ",", ""]
```

В этом примере строка `colorText` содержит список цветов, разделенных запятыми. Вызов `split(",")` возвращает массив этих цветов, разделяя строку по запятым. Далее метод вызывается со вторым аргументом, равным двум, при этом результат ограничивается двумя элементами. Наконец, с помощью регулярного выражения можно получить массив запятых. Обратите внимание, что в последнем вызове `split()` возвращенный массив содержит пустую строку перед запятыми и после. Это происходит потому, что разделитель, указанный с помощью регулярного выражения, имеется и в начале строки (подстрока `"red"`), и в конце (подстрока `"yellow"`).

## Методы для форматирования HTML-кода

Производители веб-браузеров быстро осознали потенциал динамического форматирования HTML-кода средствами JavaScript и добавили в спецификацию несколько предназначенных для этого методов, которые указаны в приведенной таблице. Однако, имейте в виду, что эти методы используются редко, потому что они генерируют несемантическую разметку.

| МЕТОД               | ВЫВОД                                      |
|---------------------|--------------------------------------------|
| `anchor(имя)`       | `<a name="имя">строка</a>`                 |
| `big()`             | `<big>строка</big>`                        |
| `bold()`            | `<b>строка</b>`                            |
| `fixed()`           | `<tt>строка</tt>`                          |
| `fontcolor(цвет)`   | `<font color="цвет">строка</font>`         |
| `fontsize(размер)`  | `<font size="размер">строка</font>`        |
| `italics()`         | `<i>строка</i>`                            |
| `link(url)`         | `<a href="url">строка</a>`                 |
| `small()`           | `<small>строка</small>`                    |
| `strike()`          | `<strike>строка</strike>`                  |
| `sub()`             | `<sub>строка</sub>`                        |
| `sup()`             | `<sup>строка</sup>`                        |

## Источники
- #### Книга  `Фрисби М. Ф89	JavaScript для профессиональных веб-разработчиков. 4-е международное изд. — СПб.: Питер, 2022. — 1168 с.: ил. — (Серия «Для профессионалов»). ISBN 978-5-4461-1740-6`