В JavaScript есть несколько важных концепций, связанных с областями видимости, контекстом выполнения и лексическим окружением.

## Области видимости (Scope)

Область видимости (Scope) — это концепция, которая определяет, где и как переменные и функции могут быть доступны в коде

### 1. Глобальная область видимости (Global Scope)

Глобальная область видимости — это самая внешняя область видимости в JavaScript. Переменные и функции, объявленные в глобальной области видимости, доступны из любого места в коде, включая функции и блоки.

#### Особенности:

  - Переменные и функции, объявленные в глобальной области видимости, становятся свойствами глобального объекта (в браузере это `window`).
  - Глобальные переменные могут быть перезаписаны или изменены из любой части кода, что может привести к неожиданным побочным эффектам.

```javascript
let globalVar = "I'm global";

function foo() {
    console.log(globalVar); // Доступно
}

foo();
console.log(globalVar); // Доступно
```

- В этом примере переменная `globalVar` объявлена в глобальной области видимости, поэтому она доступна как внутри функции `foo`, так и вне ее.

### 2. Локальная область видимости (Function Scope)

Локальная область видимости (или область видимости функции) — это область видимости, которая ограничена телом функции. Переменные и функции, объявленные внутри функции, доступны только внутри этой функции (или вложенных функций).

#### Особенности:

  - Переменные, объявленные с помощью `var`, имеют область видимости функции.
  - Локальные переменные не доступны вне функции, в которой они объявлены.

```javascript
function foo() {
    let localVar = "I'm local";
    console.log(localVar); // Доступно
}

foo();
console.log(localVar); // Ошибка: localVar is not defined
```

- В этом примере переменная `localVar` объявлена внутри функции `foo`, поэтому она доступна только внутри этой функции. Попытка обратиться к `localVar` вне функции приведет к ошибке.

### 3. Блочная область видимости (Block Scope)

Блочная область видимости — это область видимости, которая ограничена блоком кода, заключенным в фигурные скобки `{}`. Переменные, объявленные с помощью `let` и `const`, имеют блочную область видимости.

#### Особенности:

  - Переменные, объявленные с помощью `let` и `const`, доступны только внутри блока, в котором они объявлены.
  - Блочная область видимости была введена в ES6.

```javascript
if (true) {
    let blockVar = "I'm block scoped";
    console.log(blockVar); // Доступно
}

console.log(blockVar); // Ошибка: blockVar is not defined
```

- В этом примере переменная `blockVar` объявлена внутри блока `if`, поэтому она доступна только внутри этого блока. Попытка обратиться к `blockVar` вне блока приведет к ошибке.

### Цепочка областей видимости / Scope Chain (В рамках областей видимости)

Цепочка областей видимости — это механизм, который позволяет JavaScript искать переменные и функции в иерархии областей видимости. Когда JavaScript пытается найти переменную, он сначала ищет ее в текущей области видимости. Если переменная не найдена, он переходит к внешней области видимости и продолжает поиск до тех пор, пока не достигнет глобальной области видимости.

```javascript
let globalVar = "I'm global";

function outer() {
    let outerVar = "I'm outer";

    function inner() {
        let innerVar = "I'm inner";
        console.log(globalVar); // Доступно через цепочку областей видимости
        console.log(outerVar);  // Доступно через цепочку областей видимости
        console.log(innerVar);  // Доступно в текущей области видимости
    }

    inner();
}

outer();
```

- В этом примере функция `inner` имеет доступ к переменным `globalVar`, `outerVar` и `innerVar` благодаря цепочке областей видимости.
- JavaScript сначала ищет переменную в текущей области видимости (внутри `inner`), затем переходит к области видимости функции `outer`, и, наконец, к глобальной области видимости.

Более подробно про цепочку областей видимости можно прочитать ниже в пункте *Лексическое окружение (Lexical Environment)*


## Контекст выполнения (Execution Context)

Контекст выполнения — это окружение, в котором выполняется код. 
Каждый раз, когда JavaScript-движок начинает выполнение кода, он создает контекст выполнения, который содержит всю необходимую информацию для выполнения этого кода.

### Типы контекстов выполнения

1. **Глобальный контекст выполнения (Global Execution Context)**:
   - Это самый первый контекст, который создается при запуске программы.
   - Он связан с глобальной областью видимости, то есть с кодом, который не находится внутри какой-либо функции.
   - В браузере глобальный контекст выполнения связан с объектом `window`.
   - В глобальном контексте создаются глобальные переменные и функции, которые доступны из любого места в коде.

2. **Контекст выполнения функции (Function Execution Context)**:
   - Создается каждый раз, когда вызывается функция.
   - Каждая функция имеет свой собственный контекст выполнения, который включает локальные переменные, аргументы функции и ссылку на внешнее окружение (лексическое окружение).
   - Контекст выполнения функции существует только на время выполнения функции. После завершения выполнения функции контекст уничтожается.

В веб-браузерах глобальный контекст связан с объектом `window`. Глобальные переменные и функции, объявленные с помощью `var`, становятся свойствами и методами объекта `window`. Переменные, объявленные с помощью `let` и `const`, не добавляются в глобальный контекст.

### Структура контекста выполнения

Каждый контекст выполнения состоит из нескольких ключевых компонентов:

1. **Лексическое окружение (Lexical Environment)**:
   - Это внутренняя структура, которая хранит информацию о переменных и функциях, объявленных в текущей области видимости.
   - Лексическое окружение состоит из двух частей:
     - **Environment Record**: Хранит переменные и функции, объявленные в текущей области видимости.
     - **Ссылка на внешнее окружение (Outer Lexical Environment)**: Позволяет JavaScript искать переменные и функции во внешних областях видимости (цепочка областей видимости).

2. **This Binding**:
   - В контексте выполнения также определяется значение `this`, которое зависит от того, как была вызвана функция.
   - В глобальном контексте `this` ссылается на глобальный объект (в браузере это `window`).
   - В контексте функции значение `this` зависит от способа вызова функции (например, через метод объекта, через `call`, `apply`, `bind` и т.д.).

### Жизненный цикл контекста выполнения

1. **Создание контекста**:
   - Когда функция вызывается, создается новый контекст выполнения.
   - В этот момент создается лексическое окружение, которое включает в себя `Environment Record` и ссылку на внешнее окружение.
   - Также определяется значение `this`.

2. **Выполнение кода**:
   - В контексте выполнения происходит выполнение кода функции.
   - Переменные и функции, объявленные в текущей области видимости, добавляются в `Environment Record`.
   - Если код обращается к переменной или функции, которая не найдена в текущем лексическом окружении, JavaScript ищет ее во внешнем лексическом окружении (цепочка областей видимости).

3. **Завершение выполнения**:
   - После завершения выполнения функции контекст выполнения уничтожается.
   - Локальные переменные и функции, объявленные в этом контексте, больше не доступны.

### Пример работы контекста выполнения

```javascript
let globalVar = "I'm global";

function outer() {
    let outerVar = "I'm outer";

    function inner() {
        let innerVar = "I'm inner";
        console.log(globalVar); // Доступно через цепочку областей видимости
        console.log(outerVar);  // Доступно через цепочку областей видимости
        console.log(innerVar);  // Доступно в текущем контексте
    }

    inner();
}

outer();
```

- Когда вызывается функция `outer`, создается новый контекст выполнения для `outer`.
- Внутри `outer` вызывается функция `inner`, и создается новый контекст выполнения для `inner`.
- Внутри `inner` JavaScript ищет переменные в текущем лексическом окружении (Environment Record). Если переменная не найдена, он ищет ее во внешнем лексическом окружении (в данном случае в контексте `outer`), а затем в глобальном контексте.

### Цепочка областей видимости / Scope Chain (В рамках контекста выполнения)

При выполнении кода в контексте создается цепочка областей видимости (scope chain) объектов переменных. Первым звеном всегда является объект переменных текущего контекста. Если контекст — функция, используется объект активации (activation object), содержащий переменную `arguments`.

## Лексическое окружение (Lexical Environment)

Лексическое окружение — это внутренняя структура в JavaScript, которая используется для хранения информации о переменных, функциях и их связях в текущей области видимости. Оно также содержит ссылку на внешнее окружение, что позволяет реализовать цепочку областей видимости (scope chain).

### Что такое лексическое окружение?

Лексическое окружение — это объект, который состоит из двух частей:

1. **Environment Record**:
   - Это хранилище, где содержатся все переменные и функции, объявленные в текущей области видимости.
   - Например, если вы объявляете переменную с помощью `let`, `const` или `var`, она будет храниться в Environment Record текущего лексического окружения.

2. **Ссылка на внешнее окружение (Outer Lexical Environment)**:
   - Это ссылка на лексическое окружение, которое соответствует внешней области видимости.
   - Если переменная или функция не найдена в текущем Environment Record, JavaScript будет искать ее во внешнем лексическом окружении, используя эту ссылку.
   - Эта ссылка формирует **цепочку областей видимости (scope chain)**.

### Как работает лексическое окружение?

Когда JavaScript выполняет код, он создает лексическое окружение для каждой области видимости. Это может быть:

- Глобальная область видимости.
- Область видимости функции.
- Область видимости блока (для `let` и `const`).

Каждое лексическое окружение хранит свои переменные и функции, а также ссылку на внешнее окружение. Это позволяет JavaScript искать переменные и функции в цепочке областей видимости.

### Пример работы лексического окружения

```javascript
let globalVar = "I'm global";

function outer() {
    let outerVar = "I'm outer";

    function inner() {
        let innerVar = "I'm inner";
        console.log(globalVar); // Доступно через цепочку областей видимости
        console.log(outerVar);  // Доступно через цепочку областей видимости
        console.log(innerVar);  // Доступно в текущем окружении
    }

    inner();
}

outer();
```

- **Глобальное лексическое окружение**:
  - Environment Record: `{ globalVar: "I'm global", outer: function }`
  - Outer Lexical Environment: `null` (у глобального окружения нет внешнего окружения).

- **Лексическое окружение функции `outer`**:
  - Environment Record: `{ outerVar: "I'm outer", inner: function }`
  - Outer Lexical Environment: ссылка на глобальное лексическое окружение.

- **Лексическое окружение функции `inner`**:
  - Environment Record: `{ innerVar: "I'm inner" }`
  - Outer Lexical Environment: ссылка на лексическое окружение функции `outer`.

Когда функция `inner` пытается получить доступ к переменной `globalVar`, она сначала ищет ее в своем Environment Record. Если переменная не найдена, она переходит по ссылке на внешнее окружение (в данном случае окружение функции `outer`). Если и там переменная не найдена, поиск продолжается в глобальном окружении.

### Цепочка областей видимости / Scope Chain (В рамках контекста лексического окружения)

Цепочка областей видимости — это механизм, который позволяет JavaScript искать переменные и функции в лексических окружениях. Она формируется на основе ссылок на внешние окружения.

- Если переменная не найдена в текущем лексическом окружении, JavaScript переходит по ссылке на внешнее окружение и продолжает поиск.
- Этот процесс повторяется до тех пор, пока переменная не будет найдена или пока не будет достигнуто глобальное окружение (у которого внешнее окружение равно `null`).

### Замыкания и лексическое окружение

Замыкания — это функции, которые "запоминают" свое лексическое окружение, даже если они вызываются вне своей исходной области видимости. Это возможно благодаря тому, что лексическое окружение сохраняет ссылку на внешнее окружение.

```javascript
function outer() {
    let outerVar = "I'm outer";

    function inner() {
        console.log(outerVar); // Доступно через замыкание
    }

    return inner;
}

const closureFunc = outer();
closureFunc(); // Выведет: "I'm outer"
```

- Функция `inner` запоминает лексическое окружение функции `outer`, даже после того, как `outer` завершила выполнение.
- Когда `closureFunc` вызывается, она все еще имеет доступ к переменной `outerVar` благодаря замыканию.
