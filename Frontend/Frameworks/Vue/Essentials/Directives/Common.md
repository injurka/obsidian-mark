## v-text

- **Ожидает:** `string`
- **Подробности:**
    Обновляет свойство элемента [textContent](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent)

Обновляет свойство элемента [textContent](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) [](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent). При необходимости обновления лишь части содержимого `textContent` лучше использовать [интерполяцию с фигурными скобками](https://v3.ru.vuejs.org/ru/guide/template-syntax.html#текст).
    
- **Пример:**
    ```jsx
    <span v-text="msg"></span>
    <!-- тоже самое что и -->
    <span>{{ msg }}</span>
    ```

## v-html

- **Ожидает:** `string`
- **Подробности:**
    Обновляет свойство элемента [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)

Обновляет свойство элемента [innerHTML](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) [](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML)[(opens new window)](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML). **Учтите, что содержимое будет вставляться как обычный HTML и не будет компилироваться или обрабатываться как шаблоны Vue**. Если понимаете, что пытаетесь организовать составление шаблона с помощью `v-html`, то попробуйте переосмыслить реализацию с использованием компонентов.

> [!WARN] Внимание
> Динамическая отрисовка произвольного HTML-кода на сайте — опасная практика, которая приводит к [XSS-уязвимостям](https://en.wikipedia.org/wiki/Cross-site_scripting). Передавайте в `v-html` содержимое, которому можно доверять, и **НИКОГДА не передавайте содержимое, которое предоставляется пользователем**.

Локальные стили (`scoped`) в [однофайловых компонентах](https://v3.ru.vuejs.org/ru/guide/single-file-component.html) также не будут применяться к содержимому `v-html`, потому что этот HTML никак не обрабатывается компилятором шаблонов Vue. При необходимости стилизовать содержимое в `v-html` вместо локального CSS можно использовать [CSS-модули](https://vue-loader.vuejs.org/ru/features/css-modules.html)или указать дополнительный глобальный элемент `<style>` с собственной стратегией модульности, такой как БЭМ.

- **Пример:**
    ```jsx
    <div v-html="'<h1>Hello World</h1>'"></div>
    ```

## v-if

- **Ожидает:** `any`
- **Использование:**
    Отрисовывает элемент по условию, в зависимости от истинности указанного выражения. При переключении элемент и все содержащиеся в нём директивы / компоненты будут уничтожены и созданы заново. Для `<template>` будет отрисовываться его содержимое.

    Директива запускает анимации перехода при изменении состояния.

    Будет иметь больший приоритет, при совместном использовании с `v-for` на элементе, но не рекомендуется использовать эти две директивы одновременно — подробнее в разделе [отрисовки списков](https://v3.ru.vuejs.org/ru/guide/list.html#v-for-и-v-if).

## v-else

- **Не ожидает выражения**
- **Ограничение:** предыдущий элемент должен иметь директиву `v-if` или `v-else-if`.
- **Использование:**
    Обозначает «блок else» для `v-if` или цепочки `v-if`/`v-else-if`.
    ```jsx
    <div v-if="Math.random() > 0.5">
      Сейчас меня видно
    </div>
    <div v-else>
      А сейчас — нет
    </div>
    ```

## v-else-if

- **Ожидает:** `any`
- **Ограничение:** предыдущий элемент должен иметь директиву `v-if` или `v-else-if`.
- **Использование:**
    Обозначает «блок else if» для `v-if`. Можно использовать для создания цепочек условий.
    
    ```jsx
    <div v-if="type === 'A'">
      A
    </div>
    <div v-else-if="type === 'B'">
      B
    </div>
    <div v-else-if="type === 'C'">
      C
    </div>
    <div v-else>
      Не A/B/C
    </div>
    ```

## v-for

- **Ожидает:** `Array | Object | number | string | Iterable`
- **Использование:**
    Многократно отрисовывает элемент или блок шаблона на основании исходных данных. Значение директивы должно использовать специальный синтаксис `alias in expression`, чтобы объявить переменную для текущего элемента итерации:
    
    ```jsx
    <div v-for="item in items">
      {{ item.text }}
    </div>
    ```
    
Также можно объявить переменную для индекса (или ключа, при работе с объектом):

```jsx
<div v-for="(item, index) in items"></div>
<div v-for="(value, name) in object"></div>
<div v-for="(value, name, index) in object"></div>
```

По умолчанию `v-for` будет обновлять элементы «на месте», не перемещая их. Если необходимо переупорядочивать элементы при изменениях, то потребуется указывать специальный атрибут `key`:

```jsx
<div v-for="item in items" :key="item.id">
  {{ item.text }}
</div>
```

Кроме того, `v-for` может работать со значениями, реализующими [протокол Iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol)
включая нативные `Map` и `Set`.

Подробная информация об использовании `v-for` описана в разделе руководства по ссылке ниже.

## v-on

- **Сокращённая запись:** `@`
- **Ожидает:** `Function | Инлайн-выражение | Object`
- **Аргумент:** `event`
- **Модификаторы:**
    - `.stop` — вызывает `event.stopPropagation()`.
    - `.prevent` — вызывает `event.preventDefault()`.
    - `.capture` — отслеживает событие в режиме capture.
    - `.self` — вызывает обработчик только если событие произошло именно на этом элементе.
    - `.{keyAlias}` — вызывает обработчик только при нажатии определённой клавиши.
    - `.once` — вызывает обработчик события только один раз.
    - `.left` — вызывает обработчик только по нажатию левой кнопки мыши.
    - `.right` — вызывает обработчик только по нажатию правой кнопки мыши.
    - `.middle` — вызывает обработчик только по нажатию средней кнопки мыши.
    - `.passive` — добавляет обработчик события DOM с опцией `{ passive: true }`.
- **Использование:**
	Прикрепляет обработчик события к элементу. Тип события определяется аргументом. Выражение может быть именем метода, инлайн-выражением или даже не указываться, при использовании модификаторов.

	При использовании на обычном элементе отслеживает только [**нативные события DOM**](https://developer.mozilla.org/en-US/docs/Web/Events)При использовании на компонентах отслеживает **пользовательские события**, которые были сгенерированы в нём.

	При отслеживании нативных событий DOM в метод аргументом будет передаваться объект события. При указании инлайн-выражения, к объекту события можно получить доступ через специальное свойство `$event`: `v-on:click="handle('ok', $event)"`.

	Также `v-on` поддерживает привязку объекта из пар событие/обработчик без аргумента. Обратите внимание, что при использовании объектного синтаксиса модификаторы не поддерживаются.
    
- **Пример:**
    ```jsx
    <!-- использование метода в качестве обработчика -->
    <button v-on:click="doThis"></button>
    
    <!-- динамическое имя события -->
    <button v-on:[event]="doThis"></button>
    
    <!-- инлайн-выражение -->
    <button v-on:click="doThat('hello', $event)"></button>
    
    <!-- сокращённая запись -->
    <button @click="doThis"></button>
    
    <!-- сокращённая запись при динамическом имени события -->
    <button @[event]="doThis"></button>
    
    <!-- остановка всплытия события -->
    <button @click.stop="doThis"></button>
    
    <!-- остановка поведения по умолчанию -->
    <button @click.prevent="doThis"></button>
    
    <!-- остановка поведения по умолчанию без выражения -->
    <form @submit.prevent></form>
    
    <!-- цепочка модификаторов -->
    <button @click.stop.prevent="doThis"></button>
    
    <!-- модификатор клавиши с использованием keyAlias -->
    <input @keyup.enter="onEnter" />
    
    <!-- обработчик события будет вызван не больше одного раза -->
    <button v-on:click.once="doThis"></button>
    
    <!-- объектный синтаксис -->
    <button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
    ```
    
	Отслеживание пользовательских событий на компоненте (обработчик вызывается, когда в дочернем компоненте будет сгенерировано событие `my-event`):
	
	```jsx
	<my-component @my-event="handleThis"></my-component>
	
	<!-- инлайн-выражение -->
	<my-component @my-event="handleThis(123, $event)"></my-component>
	```

## v-bind
- **Сокращённая запись:** `:` или `.` (при использовании модификатора `.prop`)
- **Ожидает:** `any (если указан аргумент) | Object (без аргумента)`
- **Аргумент:** `attrOrProp (опционально)`
- **Модификаторы:**
    - `.camel` — преобразование имён атрибутов из kebab-case в camelCase.
    - `.prop` — форсирует установку привязки как свойством DOM. 3.2+
    - `.attr` — форсирует установку привязки атрибутом DOM. 3.2+
- **Использование:**
    Динамически привязывает один или несколько атрибутов или входных параметров компонента к выражению.

    При использовании с атрибутами `class` или `style` в качестве значений допускаются массивы и объекты. Подробнее можно узнать в разделе руководства по ссылкам ниже.

    При привязке входных параметров к дочернему компоненту необходимо также объявлять их внутри него.

    При использовании без аргумента можно привязать объект из пар имя-значение. Обратите внимание, в этом режиме не поддерживаются массивы или объекты для `class` и `style`.

- **Пример:**
    ```jsx
    <!-- привязка к атрибуту -->
    <img v-bind:src="imageSrc" />
    
    <!-- динамическое имя атрибута -->
    <button v-bind:[key]="value"></button>
    
    <!-- сокращённая запись -->
    <img :src="imageSrc" />
    
    <!-- сокращённая запись при динамическом имени атрибута -->
    <button :[key]="value"></button>
    
    <!-- инлайн-выражение с конкатенацией строк -->
    <img :src="'/path/to/images/' + fileName" />
    
    <!-- привязка классов -->
    <div :class="{ red: isRed }"></div>
    <div :class="[classA, classB]"></div>
    <div :class="[classA, { classB: isB, classC: isC }]"></div>
    
    <!-- привязка стилей -->
    <div :style="{ fontSize: size + 'px' }"></div>
    <div :style="[styleObjectA, styleObjectB]"></div>
    
    <!-- привязка объекта с несколькими атрибутами -->
    <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
    
    <!-- привязка входного параметра / "prop" должен быть объявлен в my-component -->
    <my-component :prop="someThing"></my-component>
    
    <!-- передача всех входных параметров родительского компонента в дочерний -->
    <child-component v-bind="$props"></child-component>
    
    <!-- XLink -->
    <svg><a :xlink:special="foo"></a></svg>
    ```
    

	При установке привязки к элементу, по умолчанию Vue проверяет оператором `in`, был ли определён ключ в элементе как свойство. Если свойство определено, то Vue будет устанавливать значение как свойство DOM, а не как атрибут. В большинстве случаев это и ожидается, но можно изменить поведение, явно указывая модификаторы `.prop` или `.attr`. Иногда это необходимо, особенно при [работе с пользовательскими элементами](https://v3.ru.vuejs.org/ru/guide/web-components.html#передача-своиств-dom).

	 В Vue, по умолчанию, привязки обновляют атрибут DOM. Однако, если вы хотите, чтобы привязка обновляла свойство DOM, вы можете использовать директиву `.prop`. Модификатор `.prop` также имеет сокращённую запись `.`:

	```jsx
	<div :someProperty.prop="someObject"></div>
	
	<!-- сокращённая запись -->
	<div .someProperty="someObject"></div>
	```
	
	Модификатор `.camel` позволяет приводить имя атрибута `v-bind` в camelCase при использовании DOM-шаблонов, так как в HTML-атрибутах используется kebab-case., например для атрибута `viewBox` в SVG:
	
	```jsx
	<svg :view-box.camel="viewBox"></svg>
	```
	
	Указывать `.camel` при использовании строковых шаблонов или компиляции шаблонов с помощью `vue-loader`/`vueify` не нужно.

	По умолчанию, привязки обновляют атрибут DOM. Однако, если вы хотите, чтобы привязка обновляла атрибут DOM, вы можете использовать директиву `.attr`.

   ```html
   <div :my-attribute.attr="myValue"></div>
   ```

	В этом примере, `my-attribute` будет обновляться как атрибут DOM, а не свойством.

	`.attr` директива в Vue.js используется для принудительного обновления атрибута DOM вместо свойства. Это может быть полезно, когда вы хотите обновить атрибут, который не является свойством DOM, например, `aria-*` атрибуты или `data-*` атрибуты.

	```html
	<template>
	  <div id="app">
	    <div :data-my-attribute.attr="myValue">{{ myValue }}</div>
	    <button @click="changeValue">Change Value</button>
	  </div>
	</template>
	
	<script>
	export default {
	  data() {
	    return {
	      myValue: 'Initial Value'
	    }
	  },
	  methods: {
	    changeValue() {
	      this.myValue = 'New Value';
	    }
	  }
	}
	</script>
	```

	В этом примере, когда вы нажимаете на кнопку "Change Value", значение `myValue` изменяется, и `data-my-attribute` атрибут также обновляется. Это происходит, потому что `.attr` директива принудительно обновляет атрибут DOM, а не свойство.

## v-model

- **Ожидает:** варьируется в зависимости от элемента формы или работы компонента
- **Использование ограничено:**
    - `<input>`
    - `<select>`
    - `<textarea>`
    - компоненты
- **Модификаторы:**
    - [`.lazy`](https://v3.ru.vuejs.org/ru/guide/forms.html#lazy) — отслеживание события `change` вместо `input`
    - [`.number`](https://v3.ru.vuejs.org/ru/guide/forms.html#number) — приведение корректной строки со значением к числу
    - [`.trim`](https://v3.ru.vuejs.org/ru/guide/forms.html#trim) — удаление пробелов в начале и в конце строки
- **Использование:**
    Создаёт двухстороннюю привязку к элементу ввода формы или к компоненту. Подробнее об использовании в разделах документации по ссылкам ниже.

## v-slot

- **Сокращённая запись:** `#`
- **Ожидает:** JavaScript выражение, допустимое в позиции аргумента функции (можно использовать деструктуризацию в [поддерживаемых окружениях](https://v3.ru.vuejs.org/ru/guide/component-slots.html#деструктуризация-входных-параметров-слота)). Опционально — требуется только в случае ожидания входных параметров, передаваемых в слот.
- **Аргумент:** имя слота (опционально, по умолчанию `default`)
- **Использование ограничено:**
    - `<template>`
    - [компонентами](https://v3.ru.vuejs.org/ru/guide/component-slots.html#сокращенныи-синтаксис-для-единственного-слота-по-умолчанию) (для единственного слота по умолчанию с входными параметрами)
- **Использование:**
    Обозначение именованного слота или слота, который получает входные параметры.
- **Пример:**
    ```jsx
    <!-- Именованный слот -->
    <base-layout>
      <template v-slot:header>
        Содержимое для заголовка
      </template>
    
      <template v-slot:default>
        Содержимое для слота по умолчанию
      </template>
    
      <template v-slot:footer>
        Содержимое для подвала
      </template>
    </base-layout>
    
    <!-- Именованный слот с входными параметрами -->
    <infinite-scroll>
      <template v-slot:item="slotProps">
        <div class="item">
          {{ slotProps.item.text }}
        </div>
      </template>
    </infinite-scroll>
    
    <!-- Слот по умолчанию с входными параметрами и деструктуризацией -->
    <mouse-position v-slot="{ x, y }">
      Mouse position: {{ x }}, {{ y }}
    </mouse-position>
    ```
    
	Дополнительную информацию можно получить по ссылкам ниже.

## v-pre

- **Не ожидает выражения**
- **Использование:**
    Пропускает компиляцию для элемента и всех его потомков. Можно использовать для отображения необработанных тегов фигурных скобок. Пропуск большого количества элементов без директив на них также может ускорить компиляцию.
- **Пример:**
    ```jsx
    <span v-pre>{{ это не будет скомпилировано }}</span>
    ```

## v-cloak

- **Не ожидает выражения**
- **Использование:**
    Директива остаётся на элементе, пока связанный с ним экземпляр компонента не завершит компиляцию. В сочетании с CSS-правилом `[v-cloak] { display: none }` позволяет скрывать нескомпилированные шаблоны до тех пор, пока не будет готов экземпляр компонента.
- **Пример:**
    ```css
    [v-cloak] {
      display: none;
    }
    ```
    
	
	```jsx
	<div v-cloak>
	  {{ message }}
	</div>
	```
	Элемента `<div>` не будет видно до завершения компиляции.

## v-once

- **Не ожидает выражения**
- **Подробности:**
    **Отрисовывает один раз** элемент или компонент. При последующих обновлениях данных и перерисовках элемент/компонент и все его потомки будут считаться статичными и пропускаться. Может использоваться для оптимизации производительности обновлений.
    
    ```jsx
    <!-- элемент -->
    <span v-once>Это значение никогда не изменится: {{ msg }}</span>
    
    <!-- элемент с потомками -->
    <div v-once>
      <h1>Комментарий</h1>
      <p>{{ msg }}</p>
    </div>
    
    <!-- компонент -->
    <my-component v-once :comment="msg"></my-component>
    
    <!-- директива `v-for` -->
    <ul>
      <li v-for="i in list" v-once>{{ i }}</li>
    </ul>
    ```
    

	Начиная с версии 3.2, можно использовать мемоизацию части шаблона, с возможностью указания условий для инвалидации, с помощью директивы [`v-memo`](https://v3.ru.vuejs.org/ru/api/directives.html#v-memo)

## v-memo *3.2+*

- **Ожидает:** `Array`
- **Подробности:**
    Мемоизация части поддерева шаблона. Может использоваться как для элементов, так и для компонентов. Директива ожидает массив фиксированной длины зависимых значений, которые станут использоваться для сравнения при мемоизации. Если каждое значение массива осталось таким же, как при последней отрисовке, то обновление всего поддерева будет пропущено. Например:
    
    ```jsx
    <div v-memo="[valueA, valueB]">
      ...
    </div>
    ```

	При повторной отрисовке компонента, если `valueA` и `valueB` остались неизменными, то будут пропущены все обновления этого `<div>` и его дочерних элементов. Фактически, будет пропущено даже создание VNode виртуального DOM, поскольку можно переиспользовать мемоизировую копию поддерева.
	
	Важно правильно определить массив для мемоизации, иначе можно пропустить обновления, которые действительно должны быть выполнены. `v-memo` с пустым массивом зависимостей (`v-memo="[]"`) будет функционально эквивалентен `v-once`.

	**Использование вместе с `v-for`**
	
	`v-memo` нужна **исключительно для микрооптимизации сценариев**, где критически важна производительность, и должна использоваться крайне редко. Наиболее частый случай, где она может оказаться полезной — отрисовка больших списков с помощью `v-for` (когда `length > 1000`):
	
	```jsx
	<div v-for="item in list" :key="item.id" v-memo="[item.id === selected]">
	  <p>ID: {{ item.id }} - выбран: {{ item.id === selected ? 'Да' : 'Нет' }}</p>
	  <p>...больше дочерних элементов</p>
	</div>
	```
	
	При изменении состояния `selected` в компоненте, будет создаваться большое число VNode, даже если большинство элементов остаётся таким же. Использование `v-memo` здесь уточняет, что «обновляем этот элемент только в том случае, если он перешёл из состояния не выбран в состояние выбран». Это позволит всем незатронутым элементам переиспользовать свою предыдущую VNode и полностью пропустить операцию сравнения. Обратите внимание, что `item.id` не нужно добавлять в массив зависимостей мемоизации, поскольку Vue автоматически определяет его из `:key` элемента.

> [!WARN] Предупреждение
> При использовании `v-memo` вместе с `v-for`, убедитесь, что они указываются на одном и том же элементе. **`v-memo` ВНУТРИ `v-for` НЕ БУДЕТ РАБОТАТЬ**.
	
- `v-memo` также можно использовать и на компонентах, чтобы вручную предотвращать нежелательные обновления в некоторых крайних случаях, когда проверка обновления дочернего компонента была де-оптимизирована. Но, повторимся, на разработчике лежит полная ответственность за указание правильного массива зависимостей, для избежания пропуска необходимых обновлений.