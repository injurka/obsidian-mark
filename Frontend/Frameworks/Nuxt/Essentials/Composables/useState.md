`useState` — это композабл, предоставляемый Nuxt, который позволяет создавать реактивное состояние, совместимое с SSR (Server-Side Rendering). Это особенно полезно, когда вам нужно сохранить состояние между сервером и клиентом, избегая проблем с гидратацией и несоответствиями данных.

## Основные моменты о `useState`:

1. **SSR-совместимость**: В отличие от `ref` из Vue 3, `useState` гарантирует, что состояние будет создано только один раз и будет одинаковым как на сервере, так и на клиенте. Это предотвращает проблемы с гидратацией, когда данные на сервере и клиенте различаются.

2. **Уникальный ключ**: `useState` принимает уникальный ключ в качестве первого аргумента. Этот ключ помогает Nuxt идентифицировать состояние и правильно дедуплицировать его между запросами. Если ключ не указан, Nuxt автоматически сгенерирует его на основе файла и строки, где был вызван `useState`.

3. **Инициализация состояния**: Второй аргумент `useState` — это функция, которая возвращает начальное значение состояния. Это значение будет использоваться, если состояние еще не было инициализировано.

4. **Сериализация данных**: Поскольку данные внутри `useState` сериализуются в JSON, важно, чтобы они не содержали несериализуемых объектов, таких как классы, функции или символы.

5. **Типизация (TypeScript)**: Вы можете указать тип состояния с помощью TypeScript, что делает код более безопасным и предсказуемым.

## Пример использования:

```ts
<script setup lang="ts">
const createRandomString = () => {
  return `random-${Math.random()}`;
};

// Используем useState для создания SSR-совместимого состояния
const randomStrings = useState<Array<string>>('randomStrings', () => [
  createRandomString(),
  createRandomString(),
  createRandomString(),
]);
</script>

<template>
  <div>
    <ul>
      <li v-for="randomString of randomStrings" :key="randomString">
        {{ randomString }}
      </li>
    </ul>
  </div>
</template>
```

## Когда использовать `useState`:

- **SSR-приложения**: Если ваш Nuxt-проект использует SSR, `useState` — это предпочтительный способ создания реактивного состояния, которое должно быть одинаковым на сервере и клиенте.
- **Общее состояние**: Если вам нужно общее состояние между компонентами, `useState` позволяет легко его создать и управлять им.

## Когда использовать `ref`:

- **SPA-приложения**: Если ваш Nuxt-проект не использует SSR (например, это SPA), вы можете использовать `ref` для создания реактивного состояния.
- **Локальное состояние**: Если состояние нужно только внутри одного компонента и не требуется его синхронизация между сервером и клиентом, `ref` будет более подходящим выбором.

### Дополнительные советы:

- **Оптимизация с `shallowRef`**: Если вам не нужно глубокое реактивное состояние (например, для больших объектов или массивов), вы можете использовать `shallowRef` в сочетании с `useState` для улучшения производительности.

```ts
const state = useState('my-shallow-state', () => shallowRef({ deep: 'not reactive' }));
```

- **Типизация**: Всегда указывайте тип состояния, если используете TypeScript, чтобы избежать ошибок и улучшить читаемость кода.

```ts
const count = useState<number>('counter', () => Math.round(Math.random() * 100));
```