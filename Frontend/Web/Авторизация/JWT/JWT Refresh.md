## 1. Структура токенов
- **Access Token**:
  - Короткий срок жизни (например, 15–30 минут).
  - Содержит данные пользователя (например, `userId`, `role`).
  - Подписывается секретным ключом или приватным ключом (для асимметричной подписи).
- **Refresh Token**:
  - Долгий срок жизни (например, 7–30 дней).
  - Хранится в безопасном месте (httpOnly cookie, Secure Storage).
  **Не должен содержать данные пользователя** — только уникальный идентификатор для связи с пользователем в БД.

## 2. Механизм работы
1. **Логин**:
   - Пользователь аутентифицируется (логин/пароль, OAuth и т.д.).
   - Сервер генерирует:
     - **Access Token** (короткоживущий).
     - **Refresh Token** (долгоживущий, сохраняется в БД).
   - Оба токена возвращаются клиенту.

2. **Доступ к защищенным ресурсам**:
   - Клиент отправляет Access Token в заголовке `Authorization: Bearer <token>`.
   - Сервер проверяет подпись и срок действия токена.

3. **Обновление Access Token**:
   - Если Access Token истек, клиент отправляет Refresh Token на эндпоинт `/refresh-token`.
   - Сервер:
     - Проверяет валидность Refresh Token (существует ли в БД, не отозван ли).
     - Генерирует **новый Access Token**.
     - (Опционально) Создает **новый Refresh Token** и удаляет старый из БД (ротация токенов).

4. **Логаут/Отзыв токенов**:
   - Удалите Refresh Token из БД.
   - Клиент удаляет Access Token и Refresh Token локально.

## 3. Безопасность
- **Хранение Refresh Token**:
  - На клиенте: httpOnly cookie с флагами `Secure`, `SameSite=Strict`.
  - В мобильных приложениях: Secure Storage (Keychain, Keystore).
- **Ротация Refresh Token**:
  - При каждом использовании Refresh Token генерируйте новый и удаляйте старый (предотвращает повторное использование).
- **HTTPS**:
  - Все запросы с токенами должны передаваться по HTTPS.
- **Blacklist/Whitelist**:
  - Храните Refresh Token в БД с привязкой к пользователю (`userId`, `deviceId`).
  - При отзыве (логаут, смена пароля) удаляйте все Refresh Token пользователя.
- **Ограничение попыток**:
  - Защитите эндпоинт `/refresh-token` от брутфорса (rate limiting).

## 4. Пример кода (Node.js)
```javascript
// Генерация токенов
const generateTokens = async (user) => {
  const accessToken = jwt.sign(
    { userId: user.id },
    process.env.ACCESS_TOKEN_SECRET,
    { expiresIn: '15m' }
  );

  const refreshToken = jwt.sign(
    { tokenId: uuidv4() }, // Уникальный ID для связи с БД
    process.env.REFRESH_TOKEN_SECRET,
    { expiresIn: '7d' }
  );

  // Сохраняем Refresh Token в БД
  await db.refreshToken.create({
    data: {
      id: refreshToken.tokenId, // Извлечь можно через jwt.decode(refreshToken).tokenId
      userId: user.id,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    },
  });

  return { accessToken, refreshToken };
};

// Эндпоинт для обновления токенов
app.post('/refresh-token', async (req, res) => {
  const { refreshToken } = req.cookies;

  // Проверка наличия токена
  if (!refreshToken) return res.sendStatus(401);

  // Верификация токена
  let payload;
  try {
    payload = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);
  } catch (err) {
    return res.sendStatus(403);
  }

  // Поиск токена в БД
  const storedToken = await db.refreshToken.findUnique({
    where: { id: payload.tokenId },
  });

  if (!storedToken || storedToken.userId !== payload.userId) {
    return res.sendStatus(403);
  }

  // Ротация: удаляем старый Refresh Token
  await db.refreshToken.delete({ where: { id: payload.tokenId } });

  // Генерируем новые токены
  const { accessToken, newRefreshToken } = await generateTokens(storedToken.user);

  // Отправка новых токенов клиенту
  res.cookie('refreshToken', newRefreshToken, { httpOnly: true, secure: true });
  res.json({ accessToken });
});
```

## 5. Обработка ошибок
- **Невалидный/просроченный Access Token** → статус `401 Unauthorized`.
- **Невалидный Refresh Token** → статус `403 Forbidden` + клиент должен запросить повторный логин.
- **Отозванный Refresh Token** → удалите его из БД и верните `403 Forbidden`.

## 6. Дополнительные меры
- **Device Fingerprinting**:
  - Привязывайте Refresh Token к устройству (например, через хэш user-agent + IP).
- **Срок действия Refresh Token**:
  - Реализуйте "скользящий" срок: обновляйте срок при каждом использовании (но это снижает безопасность).
- **Инвалидация всех сессий**:
  - При смене пароля удаляйте все Refresh Token пользователя из БД.


## Преимущество данной схемы

Давайте разберемся на простом примере, почему **один Access Token** — это как ходить с оголенным проводом, а **схема с Refresh Token** — это надежный автоматический выключатель.

### **Проблема с одним Access Token**
Представьте, что у вас есть **единственный ключ от дома** (Access Token), который:
- Работает **вечно** (или очень долго).
- Если его украдут, вор сможет заходить в ваш дом **сколько угодно**.
- Чтобы сменить ключ, вам придется **полностью переустанавливать замок** (например, сбрасывать пароль).

**Аналогия в IT**:
- Если злоумышленник перехватит Access Token (через Wi-Fi, XSS-атаку), он получит доступ к аккаунту **навсегда**.
- Чтобы остановить его, придется **инвалидировать все токены** (например, сбросить пароль), что неудобно для пользователя.

---

### **Решение: Access Token + Refresh Token**
Теперь у вас **два ключа**:
1. **Access Token** — как временный пропуск:
   - Действует **15–30 минут**.
   - Если его украдут, вор сможет войти **только на полчаса**.
   - Автоматически "сгорает", даже если ничего не делать.

2. **Refresh Token** — как секретный ключ для генерации новых пропусков:
   - Хранится в **сейфе** (httpOnly-куки, защищенное хранилище).
   - Не дает доступа к данным, но позволяет получать **новые Access Token**.
   - Можно **отозвать в любой момент** (например, при логауте).

---

### **Как это работает на практике**
1. **Пользователь логинится**:
   - Получает Access Token (живет 15 минут) и Refresh Token (живет 7 дней).

2. **Access Token истек**:
   - Приложение автоматически отправляет Refresh Token на сервер → получает **новый Access Token**.

3. **Если злоумышленник украл Access Token**:
   - Он сможет использовать его **только до истечения срока** (15 минут), а потом токен "умрет".
   - **Refresh Token у вора нет** → он не может получить новый Access Token.

4. **Пользователь вышел из системы (логаут)**:
   - Сервер удаляет Refresh Token из базы → **все Access Token становятся бесполезными** (даже если они еще не истекли).

---

### **Главные преимущества Refresh Token**
1. **Сокращение ущерба при утечке Access Token**:
   - Злоумышленник получает доступ **только на короткое время**.
   - Чтобы украсть Refresh Token, нужно преодолеть **дополнительные защиты** (httpOnly, HTTPS).

2. **Удобство для пользователя**:
   - Не нужно постоянно вводить пароль (система автоматически обновляет Access Token через Refresh Token).

3. **Контроль сессий**:
   - Можно **отозвать доступ** для конкретного устройства или всех устройств сразу (например, при смене пароля).

---

### **Пример из реальной жизни**
- **Access Token** — как QR-код для входа в кинотеатр:
  - Действует только на один сеанс.
  - Если кто-то его сфотографирует, он сможет войти, но **только на текущий фильм**.
  
- **Refresh Token** — как ваш аккаунт в приложении кинотеатра:
  - Чтобы получить новый QR-код, нужно авторизоваться в приложении (но это происходит автоматически).
  - Если телефон украдут, вы можете **удалить аккаунт из приложения** → все QR-коды станут недействительными.
