Существует 6 этапов CRP
Последовательность этих шагов, необходимая для первого отображения страницы, называется «Критический путь рендеринга»

| №   | Описание                | Задача             |
| --- | ----------------------- | ------------------ |
| 1   | построение DOM-дерева   | DOM                |
| 2   | построение CSSOM-дерева | CCSOM              |
| 3   | запуск JavaScript       | JavaScript         |
| 4   | создание Render-дерева  | Render DOM + CSSOM |
| 5   | генерация раскладки     | Layout             |
| 6   | отрисовка               | Paint              |

![[crp.png]]

## 1. Построение DOM-дерева

DOM (объектная модель документа) дерево это объект, представляющий полностью разобранную HTML-страницу. Начиная с корневого элемента `<html>`, узлы создаются для каждого элемента/текста на странице. Элементы, вложенные в другие элементы, представлены в виде дочерних узлов, и каждый узел содержит полный набор атрибутов для этого элемента. Например, элемент `<a>` будет иметь атрибут `href`, связанный с узлом.

Хорошая новость, касательно HTML, заключается в том, что он может быть исполнен по частям. Документ не должен быть загружен полностью для того, чтобы контент начал появляться на странице. Однако, другие ресурсы, такие как CSS и JavaScript, могут блокировать отрисовку страницы.

![[dom.webp]]
Пока браузер парсит документ и строит DOM, он натыкается на элементы типа [`<img>`](https://doka.guide/html/img/), [`<link>`](https://doka.guide/html/link/), [`<script>`](https://doka.guide/html/script/), которые содержат ссылки на другие ресурсы.

Если ресурс _неблокирующий_ (например, изображение), браузер запрашивает его параллельно с парсингом оставшейся части документа. _Блокирующие_ ресурсы (например, скрипты) приостанавливают обработку до своей полной загрузки.

Мы можем указывать браузеру, как именно ему следует запрашивать некоторые ресурсы, например, скрипты. Это может быть полезно, когда в скрипте мы собираемся работать с элементами, которые находятся в разметке после тега `<script>`:

> [!INFO] Памятка
> атрибут `defer` скажет браузеру продолжать парсить страницу и выполнить скрипт потом:

---

## 2. Построение CSSOM-дерева

CSSOM (объектная модель CSS) — это объект, представляющий стили, связанные с DOM. Он выглядит так же как DOM, но с соответствующими стилями для каждого узла. Не имеет значения были ли стили объявлены явно или наследуются.
В файле style.css, подключающемся в ранее упомянутом документе, мы имеем следующий набор стилей:

CSS считается «блокирующим обработку ресурсом». Это значит, что Render-дерево не может быть построено без полного первоначального разбора CSS.
В отличии от HTML, CSS не может быть использован по частям в силу своей каскадной природы. Стили, описанные в документе ниже, могут переопределять и изменять стили, определённые ранее. Так что если мы начнём использовать CSS-стили до того, как будет разобрана таблица стилей, мы можем столкнуться с ситуацией, когда стили будут применяться неверно. Это означает, что для перехода к следующему шагу, необходимо полностью разобрать CSS.

CSS-файлы блокируют рендер только если они применяются. `<link rel="stylesheet"> `может принимать медиа-атрибут, в котором мы можем указать любое медиавыражение, к которому будут относиться вложенные внутрь стили. Если, например, мы имеем таблицу стилей с медиа-атрибутом orientation:landscape, а мы просматриваем страницу в портретном режиме, то этот ресурс не будет считаться блокирующим обработку.

Благодаря оптимизациям (например, сканеру предзагрузки) стили могут не блокировать чтение HTML, но они точно блокируют выполнение JavaScript, потому что в JS могут использоваться CSS-селекторы для выборки элементов.

![[cssom.webp]]

---

## 3. Запуск JavaScript

JavaScript является блокирующим ресурсом для парсера. Это означает, что JavaScript блокирует разбор самого HTML-документа.

Когда парсер доходит до тега `<script>` (не важно внутренний он или внешний), он останавливается, забирает файл (если он внешний) и запускает его. Вот почему, если мы имеем JavaScript-файл, который ссылается на элементы документа, мы обязательно должны поместить его после их появления.

JavaScript можно загружать асинхронно, указав атрибут `async`, для того, чтобы избежать блокировки парсера.

---

## 4. Создание Render-дерева

Render-дерево — это совокупность DOM и CSSOM. Это дерево, которое даёт представление о том, что в конечном итоге будет отображено на странице. Это означает, что оно захватывает только видимый контент и не включает, например, элементы, которые были скрыты с помощью CSS-правила `display: none`.

![[render-tree.webp]]

---

## 5. Генерация раскладки layout

Раскладка — это то, что определяет размер видимой области документа (viewport), которая обеспечивает контекст для стилей CSS, зависимых от него, например, проценты или единицы вьюпорта.

Размер вьюпорта определяется метатэгом, находящемся в `<head>` документа или, если тэг не представлен, будет использовано стандартное значение вьюпорта шириною в 980 пикселей.

Например, наиболее частым значением для этого метатэга является размер, соответствующий с шириной устройства.
```html
<meta name="viewport" content="width=device-width,initial-scale=1">
```

Если пользователь посещает веб-страницу с устройства, ширина которого, например 1000 пикселей, то размеры будут опираться на это значение. Половина видимой области будет равна 500 пикселей, 10 процентов — 100 пикселей, и так далее.

Важно помнить, что Layout построен на поточной модели компоновки. Это значит, что если элементы не влияют на расположение и размеры других элементов, то их положение и размеры можно просчитать за один подход.

Именно поэтому при вёрстке макетов рекомендуется «находиться в потоке» — чтобы браузеру не приходилось несколько раз пересчитывать один и тот же элемент, так страница отрисовывается быстрее.

### Глобальный и инкрементальный Layout

_Глобальный Layout_ — это процесс просчёта всего дерева полностью, то есть каждого элемента. _Инкрементальный_ — просчитывает только часть.

Глобальный Layout запускается, например, при изменении размера окна, потому что браузеру требуется подогнать всю страницу под новый размер экрана. Это **очень** дорогой процесс.

Инкрементальный Layout запускает пересчёт только «грязных» элементов.
#### «Грязные» элементы

Это те элементы, которые были изменены, и их дочерние элементы.

Если мы как-то поменяли блок, то браузер перерисует его и его детей, потому что их положение и размеры могут зависеть от родителя.

![[dirty.webp]]
Дальше браузер приступает к, собственно, отрисовке.

---

## 6 Отрисовка paint

Наконец, на шаге отрисовки, видимый контент страницы может быть преобразован в пиксели, чтобы появиться на экране.

Время, которое займет этот этап, зависит как от величины DOM, так и от того, какие стили применяются. Некоторые стили требуют больше усилий, чтобы быть применёнными, чем другие. Например, сложное градиентное фоновое изображение потребует больше времени, чем простой сплошной цвет на фоне.

Отрисовка тоже бывает _глобальной_ и _инкрементальной_. Чтобы понять, какую часть вьюпорта надо перерисовать, браузер делит весь вьюпорт на прямоугольные участки. Логика тут та же, как и в Layout — если изменения ограничены одним участком, то пометится «грязным» и перерисуется лишь он.

Отрисовка — это _самый_ дорогой процесс из всех, что мы уже перечислили.

### Порядок отрисовки

Порядок отрисовки связан со стековым контекстом.
В общих чертах, отрисовка начинается с заднего плана и постепенно переходит к переднему:

- `background-color`;
- `background-image`;
- `border`;
- `children`;
- `outline`.

### CPU и композитинг

И Layout, и Paint работают за счёт _CPU (central process unit)_, поэтому относительно медленные. Плавные анимации при таком раскладе невероятно дорогие.

Для плавных анимаций в браузерах предусмотрен композитинг (Compositing).

_Композитинг_ — это разделение содержимого страницы на «слои», которые браузер будет перерисовывать. Эти слои друг от друга не зависят, из-за чего изменение элемента в одном слое не затрагивает элементы из других слоёв, и перерисовывать их становится не нужно.

Именно из-за разнесения элементов по разным композиционным слоям свойство `transform` не так сильно нагружает браузер. Поэтому чтобы анимации не тормозили, их рекомендуется делать с применением `transform` и `opacity`.

![[layers.webp]]

Применение таких свойств, как, например, `transform`, «выносит» элемент на отдельный композитный слой, где положение элемента не зависит от других и не влияет на них.

> Чтобы узнать, вызывает ли конкретное CSS-свойство композитинг и перерисовку в браузере, воспользуйтесь инструментом «[CSS Triggers](https://csstriggers.com)».

### Перерисовка, Reflow (relayout) и Repaint

Процесс отрисовки — циклический. Браузер перерисовывает экран каждый раз, когда на странице происходят какие-то изменения.

Если, например, в DOM-дереве добавился новый узел, или изменился текст, то браузер построит новое дерево рендеринга и запустит вычисление позиции и отрисовку заново.

Один цикл обновления — это animation frame.

Зная «расписание отрисовки» браузера, мы можем «предупредить» его, что хотим запустить какую-то анимацию на каждый новый фрейм. Это можно сделать с помощью `requestAnimationFrame()`.

```js
const animate = () => {
  // Код анимации
}
```

Эта функция запускает новый кадр анимации: обновляет какое-то свойство или перерисовывает canvas.

Если мы хотим добиться плавной анимации, используя функцию выше, мы должны обеспечить в среднем 60 обновлений экрана за секунду (60 fps — frames per second).

Это можно сделать топорно, через интервал:
```js
// 60 раз в 1000 миллисекунд, приблизительно 16 мс.
const intervalMS = 1000 / 60
setInterval(animate, intervalMS)
```

Либо использовать `window.requestAnimationFrame()`:

```js
window.requestAnimationFrame(animate)
```

Интервалы не всегда запускаются в нужный момент. [`setInterval()`](https://doka.guide/js/setinterval/) не учитывает, на какой стадии отрисовки находится страница, и в итоге кадры отрисовки могут быть рваными или дёрганными.

С интервалом анимация может быть рваной, потому что перерисовка может быть запущена в неподходящее время.

А если вкладка была неактивна, то интервал может «попытаться догнать время», и несколько кадров запустятся разом:

![[reflow.webp]]

С `requestAnimationFrame()` анимация плавнее, потому что браузер знает, что в следующем фрейме надо запустить новый кадр анимации.

Она не гарантирует, что анимация будет запущена строго раз в 16 мс, но значение будет достаточно близким.

![[reflow-2.webp]]

> [!NOTE] Полезное
> Для динамики всегда используйте [`transform`](https://doka.guide/css/transform/) и [`opacity`](https://doka.guide/css/opacity/), избегайте изменения остальных свойств (типа `left`, `top`, [`margin`](https://doka.guide/css/margin/), [`background`](https://doka.guide/css/background/) и так далее).
>
> Таким образом вы дадите браузеру возможность оптимизировать отрисовку, отчего страница станет отзывчивее.
>
> Для анимаций, которые необходимо перерисовывать на каждый фрейм, используйте `requestAnimationFrame()`.
> 
> Это сделает тяжёлую анимацию менее рваной. 

## Источник
- #### [дока](https://doka.guide/tools/how-the-browser-creates-pages/)