Сборка мусора (Garbage Collection, GC) в Unreal Engine — это механизм автоматического управления памятью, который освобождает память, занятую объектами, которые больше не используются. Это позволяет разработчикам сосредоточиться на создании контента, не беспокоясь о ручном управлении памятью.

### Основные понятия

* **UObject**: Базовый класс для всех объектов, поддерживающих сборку мусора. Все объекты, которые должны быть собраны сборщиком мусора, должны быть производными от `UObject`.
* **Root Set**: Набор объектов, которые считаются "корневыми" и не будут собраны сборщиком мусора. Объекты, на которые ссылаются корневые объекты, также не будут собраны.
* **Marking**: Процесс, в котором сборщик мусора проходит по всем объектам в Root Set и помечает их и все объекты, на которые они ссылаются.
* **Sweeping**: Процесс, в котором сборщик мусора удаляет все непомеченные объекты.

### Как использовать сборку мусора

1. **Создание объектов**:
    * Чтобы объект мог быть собран сборщиком мусора, он должен быть производным от `UObject`.
    * Используйте функцию `NewObject<T>()` для создания объектов.

Пример:

```cpp
UMyObject* MyObject = NewObject<UMyObject>();
```

2. **Добавление объектов в Root Set**:
    * Чтобы предотвратить сборку объекта сборщиком мусора, добавьте его в Root Set с помощью функции `AddToRoot()`.

Пример:

```cpp
MyObject->AddToRoot();
```

3. **Удаление объектов из Root Set**:
    * Чтобы разрешить сборку объекта сборщиком мусора, удалите его из Root Set с помощью функции `RemoveFromRoot()`.

Пример:

```cpp
MyObject->RemoveFromRoot();
```

4. **Ссылки на объекты**:
    * Используйте `TWeakObjectPtr<T>` для слабых ссылок, которые не предотвращают сборку объекта сборщиком мусора.
    * Используйте `TSharedPtr<T>` для сильных ссылок, которые предотвращают сборку объекта сборщиком мусора.

Пример:

```cpp
TWeakObjectPtr<UMyObject> WeakPtr = MyObject;
TSharedPtr<UMyObject> SharedPtr = MakeShareable(MyObject);
```

### Нюансы и советы

* **Производительность**: Сборка мусора может занимать значительное время, особенно в больших проектах. Старайтесь минимизировать количество объектов, которые нужно собрать.
* **Утечки памяти**: Если вы забудете добавить объект в Root Set или не освободите ссылки на него, объект может быть собран сборщиком мусора, когда он все еще нужен. Это приведет к утечке памяти.
* **Сложность**: Сборка мусора может быть сложной для понимания и отладки. Будьте внимательны при работе с объектами и ссылками.

### Примеры

**Пример 1: Создание и сборка объекта**

```cpp
void MyFunction()
{
    UMyObject* MyObject = NewObject<UMyObject>();

    // Объект будет собран сборщиком мусора, так как он не добавлен в Root Set
}
```

**Пример 2: Добавление объекта в Root Set**

```cpp
void MyFunction()
{
    UMyObject* MyObject = NewObject<UMyObject>();
    MyObject->AddToRoot();

    // Объект не будет собран сборщиком мусора, так как он добавлен в Root Set
}
```

**Пример 3: Использование слабых ссылок**

```cpp
void MyFunction()
{
    UMyObject* MyObject = NewObject<UMyObject>();
    TWeakObjectPtr<UMyObject> WeakPtr = MyObject;

    // Объект будет собран сборщиком мусора, так как на него нет сильных ссылок
}
```

**Пример 4: Использование сильных ссылок**

```cpp
void MyFunction()
{
    UMyObject* MyObject = NewObject<UMyObject>();
    TSharedPtr<UMyObject> SharedPtr = MakeShareable(MyObject);

    // Объект не будет собран сборщиком мусора, так как на него есть сильная ссылка
}
```
