# Кратко

*Prediction* (предсказание) в контексте Gameplay Ability System (GAS) Unreal Engine — это механизм, который позволяет клиенту предсказывать действия и эффекты, не дожидаясь подтверждения от сервера. Это улучшает отзывчивость игры, делая её более плавной и предсказуемой для игрока.

## Основные концепции:

1. **Предсказание активации способностей (Ability Activation):**
   - Клиент может активировать `GameplayAbility` без ожидания подтверждения от сервера.
   - Сервер позже проверяет, было ли предсказание верным, и, если нет, откатывает изменения.

2. **Предсказание применения GameplayEffects:**
   - Клиент может предсказать применение `GameplayEffects`, таких как модификации атрибутов или изменения GameplayTags.
   - Сервер позже проверяет и корректирует предсказания клиента.

3. **Предсказание событий (Triggered Events):**
   - Клиент может предсказать события, которые должны быть вызваны в результате активации способности.

4. **Предсказание анимаций (Montages):**
   - Клиент может предсказать воспроизведение анимаций, чтобы они начинались синхронно с активацией способности.

5. **Предсказание движения (Movement):**
   - Клиент может предсказать движение персонажа, используя встроенные механизмы движения в Unreal Engine.

## Примеры:

### Пример 1: Предсказание активации способности:

```cpp
// Клиент генерирует ключ предсказания при активации способности
FGameplayAbilitySpecHandle AbilityHandle = AbilitySystemComponent->GiveAbility(FGameplayAbilitySpec(MyGameplayAbilityClass, 1, 0));
FGameplayAbilityActivationInfo ActivationInfo;
ActivationInfo.GenerateNewPredictionKey();

// Клиент активирует способность с предсказанием
AbilitySystemComponent->TryActivateAbility(AbilityHandle, true, &ActivationInfo);
```

### Пример 2: Предсказание применения GameplayEffect:

```cpp
// Клиент применяет GameplayEffect с предсказанием
FGameplayEffectSpecHandle EffectSpecHandle = AbilitySystemComponent->MakeOutgoingSpec(MyGameplayEffectClass, 1, AbilitySystemComponent->MakeEffectContext());
EffectSpecHandle.Data.Get()->PredictionKey = ActivationInfo.GetPredictionKeyForNewAction();
AbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get());
```

### Пример 3: Предсказание движения:

```cpp
// Клиент предсказывает движение персонажа
CharacterMovementComponent->ServerMove_Send(DeltaTime, InputVector, ClientLocation, ClientRotation);
```

## Ограничения:

- **Не предсказывается удаление GameplayEffects:**
  - Клиент не может предсказать удаление `GameplayEffects`. Это может быть решено путем предсказания обратного эффекта (например, предсказание ускорения вместо замедления).

- **Не предсказываются периодические эффекты (DOTs):**
  - Клиент не может предсказать периодические эффекты, такие как "урон от огня", который наносит урон через определенные интервалы времени.

## Будущее предсказания в GAS:

- **Предсказание удаления GameplayEffects:**
  - Epic Games рассматривает возможность добавления поддержки предсказания удаления `GameplayEffects` в будущих версиях GAS.

- **Предсказание периодических эффектов:**
  - Также рассматривается возможность предсказания периодических эффектов.

- **Network Prediction Plugin:**
  - Новый плагин Network Prediction от Epic Games, который заменит `CharacterMovementComponent`, будет полностью совместим с GAS.

# Подробно `(Доскональный перевод первоисточника)`

GAS поставляется с поддержкой клиентского прогнозирования; однако он не предсказывает все. Клиентское прогнозирование в GAS означает, что клиенту не нужно ждать разрешения сервера, чтобы активировать `GameplayAbility` и применить `GameplayEffects`. Он может «предсказать» сервер, дающий ему разрешение на это, и предсказать цели, к которым он применит `GameplayEffects`. Затем сервер запускает сетевое время задержки `GameplayAbility` после активации клиента и сообщает клиенту, был ли он прав или нет в своих прогнозах. Если клиент ошибся в каком-либо из своих прогнозов, он «откатит» свои изменения из своих «неправильных прогнозов», чтобы они соответствовали серверу.

Окончательным источником для прогнозирования, связанного с GAS, является `GameplayPrediction.h` в исходном коде плагина.

Epic стремится предсказывать только то, что вам «сойдет с рук». Например, Paragon и Fortnite не предсказывают урон. Скорее всего, они используют [`ExecutionCalculations`](#concepts-ge-ec) для своего урона, который в любом случае невозможно предсказать. Это не значит, что вы не можете попытаться предсказать определенные вещи, такие как урон. Конечно, если вы это делаете и это хорошо работает для вас, то это здорово.

> ... мы также не полностью за решение «предсказывать все: плавно и автоматически». Мы по-прежнему считаем, что прогнозирование игрока лучше свести к минимуму (имеется в виду: предсказывать минимальное количество вещей, которые вам могут сойти с рук).

*Комментарий Дейва Ратти из Epic о новом [Плагине прогнозирования сети](#concepts-p-npp)*

**Что прогнозируется:**
> * Активация способности
> * Срабатывающие события
> * Применение GameplayEffect:
> * Изменение атрибута (ИСКЛЮЧЕНИЯ: казни в настоящее время не прогнозируют, только модификаторы атрибутов)
> * Изменение GameplayTag
> * События Gameplay Cue (как из-за эффекта прогнозирования игрового процесса, так и сами по себе)
> * Монтажи
> * Движение (встроено в UCharacterMovement UE)

**Что не прогнозируется:**
> * Удаление GameplayEffect
> * Периодические эффекты GameplayEffect (тикающие точки)

*Из `GameplayPrediction.h`*

Хотя мы можем предсказать применение `GameplayEffect`, мы не можем предсказать удаление `GameplayEffect`. Один из способов обойти это ограничение — предсказать обратный эффект, когда мы хотим удалить `GameplayEffect`. Допустим, мы предскажем замедление скорости передвижения на 40%. Мы можем предсказать его, применив усиление скорости передвижения на 40%. Затем одновременно удалить оба `GameplayEffects`. Это не подходит для каждого сценария, и поддержка предсказания удаления `GameplayEffect` по-прежнему необходима. Дэйв Ратти из Epic выразил желание добавить его в [будущую итерацию GAS](https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89).

Поскольку мы не можем предсказать удаление `GameplayEffect`, мы не можем полностью предсказать кулдауны `GameplayAbility`, и для них нет обратного обходного пути `GameplayEffect`. Реплицированный сервером `Cooldown GE` будет существовать на клиенте, и любые попытки обойти его (например, с помощью режима репликации `Minimal`) будут отклонены сервером. Это означает, что клиентам с более высокими задержками требуется больше времени, чтобы сообщить серверу о необходимости перехода на кулдаун и получить удаление `Cooldown GE` сервера. Это означает, что игроки с более высокими задержками будут иметь более низкую скорострельность, чем игроки с более низкими задержками, что дает им преимущество перед игроками с более низкими задержками. Fortnite избегает этой проблемы, используя пользовательский учет вместо `Cooldown GE`.

Что касается прогнозирования урона, я лично не рекомендую этого делать, несмотря на то, что это одно из первых, что большинство людей пробуют при начале работы с GAS. Я особенно не рекомендую пытаться предсказать смерть. Хотя вы можете предсказать урон, сделать это сложно. Если вы неправильно предскажете нанесение урона, игрок увидит, как здоровье противника снова подскочит. Это может быть особенно неловко и неприятно, если вы попытаетесь предсказать смерть. Допустим, вы неправильно предсказали смерть `Персонажа`, и он начинает рэгдоллинг, но затем прекращает рэгдоллинг и продолжает стрелять в вас, когда сервер исправляет это.

**Примечание:** `Мгновенные` `GameplayEffects` (например, `Cost GEs`), которые изменяют `Атрибуты`, можно легко предсказать на себе, предсказывая `Мгновенные` `Атрибуты` изменения других персонажей, вы увидите кратковременную аномалию или "всплеск" в их `Атрибутах`. Предсказанные `Мгновенные` `GameplayEffects` фактически обрабатываются как `Бесконечные` `GameplayEffects`, поэтому их можно откатить, если они были неправильно предсказаны. Когда применяется `GameplayEffect` сервера, потенциально существует два одинаковых `GameplayEffect`, из-за чего `Модификатор` будет применен дважды или не будет применен вообще на короткое время. В конечном итоге он исправится сам, но иногда всплеск заметен игрокам.

Проблемы, которые пытается решить реализация прогнозирования GAS:
> 1. «Могу ли я это сделать?» Базовый протокол для прогнозирования.
> 2. «Отменить» Как отменить побочные эффекты, если прогнозирование не удалось.
> 3. «Повторить» Как избежать повторного воспроизведения побочных эффектов, которые мы предсказали локально, но которые также реплицируются с сервера.
> 4. «Полнота» Как убедиться, что мы /действительно/ предсказали все побочные эффекты.
> 5. «Зависимости» Как управлять зависимым прогнозированием и цепочками прогнозируемых событий.
> 6. «Переопределить» Как предсказательно переопределить состояние, которое в противном случае реплицируется/принадлежит серверу.

*Из `GameplayPrediction.h`*

## Ключ прогнозирования

Прогнозирование GAS работает на основе концепции `Ключа прогнозирования`, который является целочисленным идентификатором, который клиент генерирует при активации `GameplayAbility`.

* Клиент генерирует ключ прогнозирования при активации `GameplayAbility`. Это `Ключ прогнозирования активации`.
* Клиент отправляет этот ключ прогнозирования на сервер с помощью `CallServerTryActivateAbility()`.
* Клиент добавляет этот ключ прогнозирования ко всем `GameplayEffects`, которые он применяет, пока ключ прогнозирования действителен.
* Ключ прогнозирования клиента выходит за рамки. Для дальнейших предсказанных эффектов в том же `GameplayAbility` требуется новое [Scoped Prediction Window](#concepts-p-windows).

* Сервер получает ключ предсказания от клиента.
* Сервер добавляет этот ключ предсказания ко всем `GameplayEffects`, которые он применяет.
* Сервер реплицирует ключ предсказания обратно клиенту.

* Клиент получает реплицированные `GameplayEffects` от сервера с ключом предсказания, использованным для их применения. Если какой-либо из реплицированных `GameplayEffects` совпадает с `GameplayEffects`, который клиент применил с тем же ключом предсказания, они были предсказаны правильно. Временно будет две копии `GameplayEffect` на цели, пока клиент не удалит свою предсказанную.
* Клиент получает ключ предсказания обратно от сервера. Это `Replicated Prediction Key`. Этот ключ предсказания теперь помечен как устаревший.
* Клиент удаляет **все** `GameplayEffects`, которые он создал с помощью теперь устаревшего реплицированного ключа прогнозирования. `GameplayEffects`, реплицированные сервером, будут сохранены. Любые `GameplayEffects`, которые клиент добавил и не получил соответствующую реплицированную версию от сервера, были неверно предсказаны.

Ключи прогнозирования гарантированно действительны во время атомарного группирования инструкций «window» в `GameplayAbilities`, начиная с `Activation` из ключа прогнозирования активации. Вы можете думать об этом как о действительном только в течение одного кадра. Любые обратные вызовы из скрытого действия `AbilityTasks` больше не будут иметь действительного ключа прогнозирования, если только `AbilityTask` не имеет встроенной точки синхронизации, которая генерирует новое [Scoped Prediction Window](#concepts-p-windows).

## Создание новых окон прогнозирования в способностях

Чтобы прогнозировать больше действий в обратных вызовах из `AbilityTasks`, нам нужно создать новое окно прогнозирования с областью действия с новым ключом прогнозирования с областью действия. Иногда это называют точкой синхронизации между клиентом и сервером. Некоторые `AbilityTasks`, как и все связанные с вводом, поставляются со встроенной функциональностью для создания нового окна прогнозирования с областью действия, что означает, что атомарный код в обратных вызовах `AbilityTasks` имеет допустимый ключ прогнозирования с областью действия для использования. Другие задачи, такие как задача `WaitDelay`, не имеют встроенного кода для создания нового окна прогнозирования с областью действия для своего обратного вызова. Если вам нужно предсказать действия после `AbilityTask`, у которого нет встроенного кода для создания окна прогнозирования с областью действия, например `WaitDelay`, мы должны вручную сделать это с помощью `WaitNetSync` `AbilityTask` с опцией `OnlyServerWait`. Когда клиент достигает `WaitNetSync` с `OnlyServerWait`, он генерирует новый ключ прогнозирования с областью действия на основе ключа прогнозирования активации `GameplayAbility`, отправляет его RPC на сервер и добавляет его к любому новому `GameplayEffects`, который он применяет. Когда сервер достигает `WaitNetSync` с `OnlyServerWait`, он ждет, пока не получит новый ключ прогнозирования с областью действия от клиента, прежде чем продолжить. Этот ключ прогнозирования с областью действия выполняет ту же функцию, что и ключи прогнозирования активации — применяется к `GameplayEffects` и реплицируется обратно клиентам для пометки как устаревший. Ключ прогнозирования с областью действия действителен до тех пор, пока он не выйдет из области действия, то есть окно прогнозирования с областью действия не закроется. Итак, снова, только атомарные операции, ничего скрытого, могут использовать новый ключ прогнозирования с областью действия.

Вы можете создать столько окон прогнозирования с областью действия, сколько вам нужно.

Если вы хотите добавить функциональность точки синхронизации в свои собственные `AbilityTasks`, посмотрите, как входные по сути внедряют в них код `WaitNetSync` `AbilityTask`.

**Примечание:** При использовании `WaitNetSync` это блокирует `GameplayAbility` сервера от продолжения выполнения, пока он не получит ответ от клиента. Это может быть потенциально использовано злоумышленниками, которые взламывают игру и намеренно задерживают отправку своего нового ключа прогнозирования с областью действия. Хотя Epic использует `WaitNetSync` экономно, она рекомендует потенциально создать новую версию `AbilityTask` с задержкой, которая автоматически продолжается без клиента, если это беспокоит вас.

Пример проекта использует `WaitNetSync` в спринте `GameplayAbility` для создания нового окна прогнозирования с областью действия каждый раз, когда мы применяем стоимость выносливости, чтобы мы могли ее предсказать. В идеале нам нужен действительный ключ прогнозирования при применении стоимости и перезарядки.

Если у вас есть предсказанный `GameplayEffect`, который воспроизводится дважды на владеющем клиенте, ваш ключ прогнозирования устарел, и вы испытываете проблему «повтора». Обычно эту проблему можно решить, поместив `WaitNetSync` `AbilityTask` с `OnlyServerWait` прямо перед применением `GameplayEffect` для создания нового ключа прогнозирования с областью действия.

## Предиктивное создание актеров

Предиктивное создание `Actor` на клиентах — сложная тема. GAS не предоставляет функциональность для решения этой проблемы из коробки (`SpawnActor` `AbilityTask` создает `Actor` только на сервере). Ключевая концепция — создать реплицированный `Actor` как на клиенте, так и на сервере.

Если `Actor` просто косметический или не служит какой-либо игровой цели, простым решением будет переопределить функцию `Actor` `IsNetRelevantFor()`, чтобы запретить серверу реплицироваться на владеющего клиента. У владеющего клиента будет его локально созданная версия, а у сервера и других клиентов будет реплицированная версия сервера.
```c++
bool APAReplicatedActorExceptOwner::IsNetRelevantFor(const AActor * RealViewer, const AActor * ViewTarget, const FVector & SrcLocation) const
{
return !IsOwnedBy(ViewTarget);
}
```

Если созданный `Actor` влияет на игровой процесс как снаряд, которому нужно предсказывать урон, то вам нужна расширенная логика, которая выходит за рамки этой документации. Посмотрите, как UnrealTournament предсказательно создает снаряды на GitHub Epic Games. У них есть фиктивный снаряд, создаваемый только на клиенте-владельце, который синхронизируется с реплицированным снарядом сервера.

## Будущее прогнозирования в GAS

`GameplayPrediction.h` заявляет, что в будущем они потенциально могут добавить функционал для прогнозирования удаления `GameplayEffect` и периодических `GameplayEffects`.

Дэйв Ратти из Epic [выразил интерес](https://epicgames.ent.box.com/s/m1egifkxv3he3u3xezb9hzbgroxyhx89) к исправлению проблемы `согласования задержек` для прогнозирования перезарядки, что ставит игроков с более высокими задержками в невыгодное положение по сравнению с игроками с более низкими задержками.

Новый плагин [`Network Prediction`](#concepts-p-npp) от Epic, как ожидается, будет полностью совместим с GAS, как и `CharacterMovementComponent` *был* до него.

## Плагин Network Prediction

Epic недавно начала инициативу по замене `CharacterMovementComponent` новым плагином `Network Prediction`. Этот плагин все еще находится на очень ранних стадиях, но доступен для очень раннего доступа на Unreal Engine GitHub. Пока еще слишком рано говорить, в какой будущей версии движка он дебютирует в экспериментальной бета-версии.