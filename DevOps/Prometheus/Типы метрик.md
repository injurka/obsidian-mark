Несмотря на то что у метрик есть поле `TYPE` — под капотом разницы нет. Это, как и `HELP`, только для людей, чтобы было проще работать. Но библиотеки, которыми мы пишем метрики, построены вокруг этих типов. И некоторые функции в запросах корректно работают только для определенных типов. То есть можно считать тип **соглашением** о том, как себя ведет значение этой метрики.

## Counter

![[./_/counter.png]]

**Счетчик** – монотонно возрастающее число. Никогда не убывает! Может быть сброшен в ноль, например, при рестартах сервиса, который пишет метрику. Это важно, т.к. у Prometheus есть специальные функции, которые это учитывают. API: `increase()`, `add(x)`

```q
# Примеры метрик: количество обработаных запросов, ошибок, задач

http_requests_total{url="/login"} 10
http_requests_total{url="/"} 100

http_errors{status="500", url="/"} 3
http_errors{status="401", url="/"} 26
http_errors{status="400", url="/login"} 11
http_errors{status="404", url="/admin"} 298

jobs{type="cleanup", status="completed"} 42
jobs{type="cleanup", status="failed"} 38
```

Как узнать, сколько запросов было за единицу времени, когда у нас всего одно число? Посмотреть на дельту, т.к. Prometheus сохраняет снимки этого числа каждые 30 секунд. Ну и понадобится дополнительный костыль, если приложение перезапустилось, и счетчик вдруг сбросился в ноль – это уже учтено в функциях, которые работают со счетчиками.

### Примеры использования:

1. **Количество запросов**: Если вы хотите отслеживать количество HTTP-запросов, полученных вашим веб-сервером, вы можете использовать счетчик для подсчета каждого запроса.
    
2. **Количество ошибок**: Счетчик может быть использован для отслеживания количества ошибок, возникающих в вашем приложении или системе. Например, вы можете отслеживать количество ошибок входа в систему, ошибок базы данных или сетевых ошибок.
    
3. **Количество успешных операций**: Если ваше приложение выполняет определенные операции (например, обработку платежей, отправку сообщений), вы можете использовать счетчик для отслеживания количества успешных операций.
    
4. **Количество событий**: Если в вашей системе происходят определенные события (например, создание новых пользователей, обновление конфигурации), вы можете использовать счетчик для отслеживания количества этих событий.
    
5. **Количество прерываний**: В системах реального времени или встроенных системах счетчик может быть использован для отслеживания количества прерываний определенного типа.
    
6. **Количество сообщений**: Если ваше приложение работает с очередями сообщений (например, RabbitMQ, Kafka), вы можете использовать счетчик для отслеживания количества сообщений, обработанных или отправленных.

## Gauge

![[./_/gauge.png]]

**"Стрелка"** — число, которое может гулять вверх-вниз. API: `setValue(x)`, `increase()`, `decrease()`

```q
# Примеры метрик: количество обрабатываемых запросов прямо сейчас, занятая память, свободное место на диске

http_active_requests{app="web"} 5
http_active_requests{app="internal"} 1

memory_swap{host="test"} 0
memory_swap{host="prod"} 102400
memory_usage_bytes{host="test"} 1295007744
memory_usage_bytes{host="prod"} 5476434545

disk_free_bytes{path="/var/www/"} 29298077696
disk_free_bytes{path="/tmp/"} 37359484928
```

Поскольку эта штука не монотонная, для нее не сработают некоторые математические фокусы, то есть она чуть больше ограничена в использовании. 

### Примеры использования:

1. **Использование ресурсов**: Gauge может быть использован для отслеживания текущего использования ресурсов, таких как память, CPU, дисковое пространство или пропускная способность сети.
   
2. **Количество активных пользователей**: Если ваше приложение поддерживает множество пользователей, вы можете использовать Gauge для отслеживания количества активных пользователей в данный момент.
   
3. **Температура и другие физические параметры**: В системах мониторинга оборудования Gauge может быть использован для отслеживания текущей температуры, напряжения, тока и других физических параметров.
   
4. **Состояние очередей**: Если ваше приложение работает с очередями сообщений (например, RabbitMQ, Kafka), вы можете использовать Gauge для отслеживания текущего размера очереди или количества сообщений в очереди.
   
5. **Состояние сервисов**: Gauge может быть использован для отслеживания состояния различных сервисов в вашем приложении, например, количества запущенных экземпляров сервиса или доступности сервиса.

## Histogram

![[./_/histogram.png]]

**Гистограмма** — агрегация чего-то самим приложением, когда нам интересно знать **распределение** величин по **заранее определенным** группам (buckets). API: `observe(x)`

Например, мы хотим знать длительность HTTP-запросов. Определимся, какое время считать хорошим, какое плохим, и насколько детально мы хотим это знать. Можно сказать, **качественное распределение**:

- `<= 0.1` сек. — хороший запрос, ожидаем, что таких будет большинство;
    
- `<= 1` — сойдет, но лучше бы знать, что такие встречаются;
    
- `<= 5` — подозрительно, пойдем смотреть код, если таких окажется много;
    
- `больше 5` — вообще плохо, для однообразия можно сказать, что это `<= infinity`.
    

Как это работает: пришел запрос, померяли время обработки `X` и обновили гистограмму: добавили `+1` в соответствующие группы и добавили `+X` к суммарному времени. Вот несколько примеров попадания запросов с разным временем в бакеты:

- `0.01` попадет во все бакеты: `<= 0.1`, `<= 1`, `<= 5`, `<= infinity`;
    
- `0.3` попадет в бакеты кроме первого: `<= 1`, `<= 5`, `<= infinity`. В первый не попадает, т.к. время больше `0.1`;
    
- `4` попадет в бакеты: `<= 5`, `<= infinity`. В первый и второй не попадает, т.к. время больше `0.1` и `1`;
    
- `10` попадет только в бакет `<= infinity`. В остальные не попадает, т.к. время больше `0.1`, `1` и `5`.

```q
# Пример метрики: распределение времени обработки HTTP-запросов по 4 бакетам

http_duration_bucket{url="/", le="0.1"} 100
http_duration_bucket{url="/", le="1"} 130
http_duration_bucket{url="/", le="5"} 140
http_duration_bucket{url="/", le="+Inf"} 141

http_duration_sum{url="/"} 152.7625769  # это бонусом идет сумма всех значений, которые мы записали
http_duration_count{url="/"} 141  # это количество значений, т.е. counter который всегда делает +1 на каждое обновление гистограммы
```

> `le` — просто лейбл, который генерируется из наших бакетов. Никакой магии. Означает "less than or equal", то есть `<=`

Гистограмма считает **количество попаданий** в какую-то группу, то есть запоминает счетчики, а не сами значения! Мы ведь ограничены тем, что метрика сама по себе — это только одно число. Каждый бакет — как бы отдельная метрика.

Как этим пользоваться? Можно просто вывести на график нужный бакет, поделив его на `count`: получим соотношение этого бакета ко всем запросам, т.е. долю «хороших» или «плохих» запросов в общей массе, смотря что мы хотим наблюдать. Но лучше делать это не руками, а одной функцией агрегировать в квантили (см. в [следующей части](https://habr.com/ru/company/tochka/blog/690814/)). Это удобно, просто и будет обсчитываться на Prometheus-сервере, хоть и с потерей точности (меньше бакетов — меньше точность). Если вы хотите считать квантили самостоятельно или **не знаете заранее, какие бакеты нужны**, есть другой тип — Summary.

### Примеры использования:

1. **Время ответа сервера**: Если вы хотите отслеживать время ответа вашего веб-сервера или API, Histogram позволит вам увидеть, как время ответа распределено и какие запросы выполняются быстрее или медленнее.
    
2. **Размер запросов и ответов**: Histogram может быть использован для отслеживания размера запросов и ответов, чтобы понять, какие запросы генерируют больше данных и как это влияет на производительность.
    
3. **Время выполнения задач**: Если ваше приложение выполняет различные задачи, Histogram может помочь вам отслеживать время выполнения этих задач и понять, какие задачи занимают больше времени.
    
4. **Задержки в сети**: Для мониторинга сетевых задержек Histogram может быть использован для измерения времени, которое требуется для передачи данных между различными узлами или сервисами.
    
5. **Использование ресурсов**: Histogram может помочь вам отслеживать распределение использования ресурсов, таких как память или CPU, и понять, как эти ресурсы распределены между различными компонентами системы.

## Summary

![[./_/summary.png]]

**Сводка** - готовьтесь, сейчас будет сложно. На первый взгляд, похожа на гистограмму, но на самом деле — это результат агрегации гистограммы. Она выдает сразу квантили, можно сказать, **количественное распределение**, когда мы заранее не можем определить бакеты. API: `observe(x)`

> Читайте про квантили [в следующей части](https://habr.com/ru/company/tochka/blog/690814/) и смело возвращайтесь — станет гораздо понятнее!

Проще всего объяснить на практике: обычно мы заранее не знаем, что считать хорошим временем для запроса, а что плохим. Поэтому просто закинем измеренное время в Summary, и потом посмотрим, во что впишутся 95% запросов. Ну и 50%, и 99% тоже. Итак, пришел запрос, померяли время обработки `X`, записали в Summary:

- +1 в счетчик количества запросов;
    
- само время `X` закинули во **множество значений в памяти приложения;**
    
- пересчитали квантили;
    
- периодически придется выкидывать из памяти старые значения, чтобы не расходовать ее бесконечно.
    

```q
# Пример метрики: распределение времени обработки HTTP-запросов по 5 квантилямhttp_duration_summary{quantile="1"} 100http_duration_summary{quantile="0.99"} 4.300226799http_duration_summary{quantile="0.95"} 2.204090024http_duration_summary{quantile="0.5"} 0.073790038http_duration_summary{quantile="0.1"} 0.018127115http_duration_summary_sum 152.7625769  # как у гистограммы, сумма всех значенийhttp_duration_summary_count 141  # и количество значений
```

Как это интерпретировать? Здесь тоже что-то вроде бакетов, как в гистограмме, но с другим смыслом. Если вкратце, метрика с `quantile="0.95"` говорит нам, что 95% запросов выполнялись быстрее, чем за `2.2` секунды. Аналогично, 99% запросов выполнялись быстрее, чем `4.3` секунды, и так далее. Как это работает и зачем нужно, станет понятно только после объяснения квантилей, поэтому вернемся к Summary в последней части.

Сводки нельзя просто так агрегировать в лоб, _но вообще можно, если вы думаете головой_, с потерей точности (и об этом тоже в [следующей части](https://habr.com/ru/company/tochka/blog/690814/), ага). А еще они висят в памяти приложения, так как нужно запоминать набор значений за какой-то промежуток времени. Из-за этого сводки считают квантили с потерями: старые данные постепенно вытесняются, поэтому они оказывают меньшее влияние на значение, которое получается в данный момент. Можно применять разные подходы: например, «сдвигать окно» – выбрасывать самые старые значения. Или выкидывать случайные. Зависит от того, что мы больше хотим видеть в метрике: статистику по вообще всем запросам, или только по недавним.

> В примерах используется одна и та же метрика – `http_duration`. Так сделано только для наглядности в статье. Одну и ту же метрику не нужно писать сразу в двух видах, это избыточно. Выбирайте либо histogram, либо summary.

### Примеры использования:

1. **Время ответа сервера**: Если вы хотите отслеживать квантили времени ответа вашего веб-сервера или API, Summary позволит вам увидеть, как время ответа распределено и какие запросы выполняются быстрее или медленнее.
    
2. **Размер запросов и ответов**: Summary может быть использован для отслеживания квантилей размера запросов и ответов, чтобы понять, какие запросы генерируют больше данных и как это влияет на производительность.
    
3. **Время выполнения задач**: Если ваше приложение выполняет различные задачи, Summary может помочь вам отслеживать квантили времени выполнения этих задач и понять, какие задачи занимают больше времени.
    
4. **Задержки в сети**: Для мониторинга сетевых задержек Summary может быть использован для измерения квантилей времени, которое требуется для передачи данных между различными узлами или сервисами.
    
5. **Использование ресурсов**: Summary может помочь вам отслеживать квантили использования ресурсов, таких как память или CPU, и понять, как эти ресурсы распределены между различными компонентами системы.

## Источники
- #### [habr](https://habr.com/ru/companies/tochka/articles/685636/)
