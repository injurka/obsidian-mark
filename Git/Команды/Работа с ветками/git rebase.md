Позволяет переместить последовательность коммитов из одной ветки на вершину другой ветки, создавая новую историю. Это полезно, когда нужно упростить историю проекта, объединить изменения или избежать лишних коммитов слияния.

## Основные варианты использования команды

1. **Перемещение коммитов на другую ветку:**
   Чтобы переместить коммиты из текущей ветки на вершину другой ветки, используй команду:

   ```bash
   git rebase <имя_ветки>
   ```

   Например, чтобы переместить коммиты из ветки `feature/login` на вершину ветки `main`:

   ```bash
   git rebase main
   ```

   Git возьмет коммиты из текущей ветки и применит их поверх указанной ветки.

2. **Интерактивный режим:**
   Чтобы изменить историю коммитов в интерактивном режиме, используй флаг `-i` или `--interactive`:

   ```bash
   git rebase -i <коммит>
   ```

   Например, чтобы изменить последние три коммита:

   ```bash
   git rebase -i HEAD~3
   ```

   Git откроет редактор, где можно выбрать действия для каждого коммита: изменить сообщение, объединить коммиты, переупорядочить их или удалить.

3. **Продолжение после конфликта:**
   Если при выполнении `rebase` возникают конфликты, Git остановит процесс и предложит разрешить их вручную. После разрешения конфликтов добавь измененные файлы в индекс и продолжи процесс:

   ```bash
   git add <файл>
   git rebase --continue
   ```

   Если нужно отменить процесс, используй команду:

   ```bash
   git rebase --abort
   ```

4. **Пропуск коммита:**
   Если нужно пропустить коммит, который вызывает конфликт, используй команду:

   ```bash
   git rebase --skip
   ```

   Git пропустит текущий коммит и перейдет к следующему.

5. **Редактирование коммитов:**
   Чтобы изменить отдельные коммиты во время `rebase`, используй команду:

   ```bash
   git rebase --edit-todo
   ```

   Это полезно, если нужно изменить действия для коммитов в интерактивном режиме.

6. **Автоматическое разрешение конфликтов:**
   Если нужно автоматически разрешать конфликты в пользу одной из сторон, используй флаги `-X ours` или `-X theirs`:

   ```bash
   git rebase -X ours <имя_ветки>
   ```

   Например, чтобы автоматически разрешать конфликты в пользу текущей ветки:

   ```bash
   git rebase -X ours main
   ```

7. **Перемещение одной ветки на другую:**
   Чтобы переместить одну ветку на вершину другой, используй команду:

   ```bash
   git rebase <исходная_ветка> <целевая_ветка>
   ```

   Например, чтобы переместить ветку `feature/login` на вершину ветки `main`:

   ```bash
   git rebase main feature/login
   ```

## Примеры использования
  1. **До выполнения `rebase`**

Предположим, у нас есть две ветки: `main` и `feature/login`. Ветка `main` находится на коммите `C`, а ветка `feature/login` содержит два новых коммита `D` и `E`, которые были созданы после точки расхождения.

#### Древо до `rebase`:

```
A --- B --- C (main)
         \
          D --- E (feature/login)
```

2. **После выполнения `git rebase main`**

Когда вы выполняете `git rebase main` из ветки `feature/login`, Git:

1. Находит общий предок (`B`) между `main` и `feature/login`.
2. Временно удаляет коммиты `D` и `E` из ветки `feature/login`.
3. Применяет коммиты `D` и `E` поверх последнего коммита ветки `main` (`C`).

> Древо после `rebase`:
```
A --- B --- C (main)
               \
                D' --- E' (feature/login)
```

Обратите внимание, что коммиты `D` и `E` были пересозданы как `D'` и `E'`, потому что их хэши изменились (они теперь основаны на коммите `C`).


3. **Интерактивный режим (`git rebase -i`)**

Если вы используете интерактивный режим (`git rebase -i`), вы можете:

- Изменить порядок коммитов.
- Объединить коммиты (squash).
- Редактировать сообщения коммитов.
- Удалить коммиты.

> Пример интерактивного `rebase`:

Выполните команду:

```bash
git rebase -i HEAD~3
```

Git откроет редактор с списком коммитов:

```
pick D Добавлена логика входа
pick E Исправлена ошибка авторизации
```

Вы можете изменить `pick` на `squash`, чтобы объединить коммиты, или на `edit`, чтобы изменить сообщение коммита.

## Как работает `git rebase`

1. **Определение общего предка:**
   Git находит общий предок текущей ветки и ветки, на которую выполняется `rebase`. Это точка, где ветки разошлись.

2. **Создание временной копии коммитов:**
   Git создает временную копию коммитов из текущей ветки, которые нужно переместить.

3. **Применение коммитов:**
   Git последовательно применяет коммиты из временной копии на вершину указанной ветки. Если возникают конфликты, Git останавливает процесс и предлагает их разрешить.

4. **Обновление указателя ветки:**
   После успешного завершения `rebase` Git обновляет указатель текущей ветки, чтобы он указывал на последний примененный коммит.

## Важные моменты

- **Конфликты:**
   Если при выполнении `rebase` возникают конфликты, Git остановит процесс и предложит их разрешить. После разрешения конфликтов нужно добавить измененные файлы в индекс и продолжить процесс.

- **Интерактивный режим:**
   Интерактивный режим позволяет изменять историю коммитов: объединять, переупорядочивать, удалять или редактировать коммиты.

- **Отмена процесса:**
   Если что-то пошло не так, можно отменить процесс с помощью `git rebase --abort`.

- **Автоматическое разрешение конфликтов:**
   Флаги `-X ours` и `-X theirs` позволяют автоматически разрешать конфликты в пользу одной из сторон.

## Пример сценария

1. В ветке `feature/login` есть изменения, которые нужно переместить на вершину ветки `main`. Переключаешься на ветку `feature/login` и выполняешь:

   ```bash
   git rebase main
   ```

2. Если Git выполняет `rebase` без конфликтов, коммиты из ветки `feature/login` будут перемещены на вершину ветки `main`.

3. Если возникает конфликт, разрешаешь его вручную, добавляешь измененные файлы в индекс и продолжаешь процесс:

   ```bash
   git add <файл>
   git rebase --continue
   ```

4. Если нужно изменить историю коммитов, используешь интерактивный режим:

   ```bash
   git rebase -i HEAD~3
   ```

5. Если нужно автоматически разрешать конфликты в пользу текущей ветки, используешь:

   ```bash
   git rebase -X ours main
   ```



