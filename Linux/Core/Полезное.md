## Команды Управление файлами

- **ls** - Утилита для просмотра содержимого каталогов. По умолчанию показывает текущий каталог. Если в параметрах передать путь, то она перечислит содержимое того каталога. Полезные опции -l (List) и -a (All). Первая форматирует вывод в виде списка с более подробной информацией, а вторая включает показ скрытых файлов.
- **cat** - Печатает содержимое файла, переданного в параметре, в стандартный вывод. Если передать несколько файлов, команда склеит их. Также можно перенаправить вывод в еще один файл, с помощью символа '>'. Если нужно вывести только определенное количество строк используйте опцию -n (Number).
- **cd** - Позволяет перейти из текущего каталога, в указанный. Если запустить без параметров - возвращает в домашний каталог. Вызов с двумя точками возвращает на уровень вверх относительно текущего каталога. Вызов с тире (cd -) возвращает к предыдущему каталогу.
- **pwd** - Печатает на экран текущий каталог. Это может быть полезно, если ваша командная строка Linux не выводит такую информацию, а также особенно полезно в Bash программировании, для получения ссылки на каталог в котором выполняется скрипт.
- **mkdir** - Создание новых каталогов. Наиболее удобная опция - p (Parents), позволяет создать всю структуру подкаталогов одной командой, даже если они еще не существуют.
- **file** - Показывает тип файла. В Linux файлы не обязаны всегда иметь расширения для того, чтобы с ними работать. Поэтому пользователю иногда трудно определить, что за файл перед ним.
- **cp** - Копирование файлов и каталогов. Она не копирует каталоги рекурсивно по умолчанию, поэтому не забудьте добавить опцию -r (Recursive) или -a (Archive). Последняя включает режим сохранения атрибутов, владельца и временного штампа, в дополнение к рекурсивному копированию.
- **mv** - Перемещение или переименование файлов и каталогов. Примечательно, что переименование и перемещение - это одна и та же операция. Переименование - это перемещение файла в ту же папку с другим именем.
- **rm** - Удаляет файлы и папки. Очень полезная команда Linux, с помощью нее вы можете убрать весь беспорядок. Однако будьте осторожны при ее использовании. Хоть и для того чтобы повредить систему вам нужно серьезно постараться, вы можете удалить собственные важные файлы. Rm не удаляет файлы в корзину, из которой потом все можно будет восстановить. Так что будьте осторожны, чтобы потом не говорили: "rm съела мою курсовую". Все действия необратимы. Если нужно рекурсивное удаление, используйте опцию -r.
- **ln** - Создает жесткие или символические ссылки на файлы. Символические или программные ссылки - это что-то похожее на ярлыки в Windows. Они предоставляют удобный способ доступа к определенному файлу. Символические ссылки указывают на файл, но не имеют никаких метаданных. Жесткие ссылки в отличие от символических указывают на физический адрес области диска, где хранятся данные файла.
- **chmod**

`chmod опции права /путь/к/файлу`

Изменяет права доступа к файлу.

Есть три основных вида прав:

- **r** - чтение;
- **w** - запись;
- **x** - выполнение;
- **s** - выполнение от имени суперпользователя (дополнительный);

Также есть три категории пользователей, для которых вы можете установить эти права на файл linux:

- **u** - владелец файла;
- **g** - группа файла;
- **o** - все остальные пользователи;

Наиболее популярен восьмеричный формат задания прав:

- **0** - никаких прав;
- **1** - **только выполнение**;
- **2** - **только запись**;
- **3** - выполнение и запись;
- **4** - **только чтение**;
- **5** - чтение и выполнение;
- **6** - чтение и запись;
- **7** - чтение запись и выполнение.

Например:

- **744** - разрешить все для владельца, а остальным только чтение;
    
- **755** - все для владельца, остальным только чтение и выполнение;
    
- **764** - все для владельца, чтение и запись для группы, и только чтение для остальных;
    
- **777** - всем разрешено все.
    
- **chown** - Изменяющая владельца и/или группу для указанных файлов. Только суперпользователь может изменять владельцев. Для рекурсивного изменения используйте опцию -R. Поменять владельца для `strace.log` в 'rob' и идентификатор группы в developers: `chown rob:developers strace.log`
    
- **find** - Поиск в файловой системе, файлов и папок. Это очень гибкая и мощная команда Linux не только из-за своих возможностей поиска, но и благодаря возможности выполнять произвольные команды для найденных файлов.
    

**locate**

В отличие от find ведет поиск в базе данных updatedb, для шаблонов имен файлов. Эта база данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадежен, потому что вы не можете быть уверены, что ничего не изменилось с момента последнего снимка.

**du**

(disk usage) Показать размер файла или каталога. Одни из наиболее полезных опций - h (Human), которая преобразует размеры файлов в легко читаемый формат, -s (Summarize) выводит минимум данных и -d (Depth) - устанавливает глубину рекурсии по каталогам.

`du [опции][каталоги_или_файлы]`

Опции:

- `–b` выводит информацию в байтах(а не в килобайтах).
- `–c` выводит итоговую информацию об использовании дисковой памяти.
- `–k` выводит информацию в килобайтах(по умолчанию).
- `–s` выводит итоговую информацию об использовании дискового пространства без информации о каталогах.
- `-h` вывести информацию в человекочитаемом виде.
- `-d` (Depth) - устанавливает глубину рекурсии по каталогам.

**df**

**df**(disk free) - позволяет узнать размер свободного и занятого пространства во всех смонтированных файловых системах.

`df [опции][файловая_система]`

Опции:

- `-a` выводит информацию обо всех файловых системах.
- `-h` выводит размеры в удобном для человека виде (мегабайты, килобайты, гигабайты и т.д.)
- `-T` показать тип файловой системы.
- `-t` выводит информацию только об указанных типах файловых систем.

**dd**

Как сказано в официальном руководстве, это команда терминала для копирования и преобразования файлов. Не очень понятное описание, но это все что делает dd. Вы передаете ей файл-источник и пункт назначения, и пару дополнительных опций. Затем она делает копию одного файла в другой. Вы можете задать точный размер данных, которые нужно записать или скопировать. Работает утилита со всеми устройствами. Например, если вы хотите перезаписать жесткий диск нулями из /dev/zero, можете сделать это. Также она часто используется для создания LiveUSB или гибридных ISO образов.

**mount /umount**

Это команды консоли Linux для подключения и отключения файловых систем Linux. Можно подключать все, от USB накопителей, до ISO образов. И только у суперпользователя есть права для этого.


## Работа с текстом

**more/less**

Это две простенькие команды терминала, для просмотра длинных текстов, которые не вмещаются на одном экране. Представьте себе очень длинный вывод команды. Или вы вызвали cat для просмотра файла и вашему эмулятору терминала потребовалось несколько секунд, чтобы прокрутить весь текст. Если ваш терминал не поддерживает прокрутки, вы можете сделать это с помощью less. Less новее, чем more и поддерживает больше опций, поэтому использовать more нет причин.

**head/tail**

Еще одна пара, но здесь у каждой команды своя область применения. Head выводит несколько первых строк из файла (голова), а tail выдает несколько последних строк (хвост). По умолчанию каждая утилита выводит десять строк. Но это можно изменить с помощью опции -n. Еще один полезный параметр -f. Это сокращение от Follow (следовать), утилита постоянно выводит изменения в файле на экран. Например, если вы хотите следить за лог файлом, вместо того чтобы постоянно открывать и закрывать его используйте tail -nf.

**grep**

Grep, как и другие инструменты Linux делает одно действие, но делает его хорошо. Она ищет текст по шаблону. По умолчанию она принимает стандартный ввод, но вы можете искать в файлах. Шаблон может быть строкой, или регулярным выражением. Она может вывести как совпадающие, так и несовпадающие строки и их контекст. Каждый раз, когда вы выполняете команду, которая выдает очень много информации, не нужно анализировать все вручную, пусть grep делает свою магию.

**sort**

Сортировка строк текста по различным критериям. Наиболее полезные: -n (Numeric) - по числовому значению, и -r (Reverse), которая переворачивает вывод. Это может быть полезно для сортировки вывода du. Например, если хотите отсортировать файлы по размеру, просто соедините эти команды.

**wc**

wc(word count) -Утилита командной строки Linux для подсчета количества слов, строк, байт и символов.

```bash
 wc -l <filename> вывести количество строк
 wc -c <filename> вывести количество байт
 wc -m <filename> вывести количество символов
 wc -L <filename> вывести длину самой длинной строки
 wc -w <filename> вывести количество слов
```

**uniq**

Утилита Unix, с помощью которой можно вывести или отфильтровать повторяющиеся строки в отсортированном файле. Если входной файл задан как («-») или не задан вовсе, чтение производится из стандартного ввода. Если выходной файл не задан, запись производится в стандартный вывод. Вторая и последующие копии повторяющихся соседних строк не записываются. Повторяющиеся входные строки не распознаются, если они не следуют строго друг за другом, поэтому может потребоваться предварительная сортировка файлов.

```
uniq [-c | -d | -u] [-i] [-f число_полей] [-s | -w число_символов] [входной_файл [выходной_файл]]
```

Опции:

- `-u` Выводить только те строки, которые не повторяются на входе.
- `-d` Выводить только те строки, которые повторяются на входе.
- `-c` Перед каждой строкой выводить число повторений этой строки на входе и один пробел.
- `-i` Сравнивать строки без учёта регистра.
- `-s число_символов` Определяет количество символов, начиная с начала строки, игнорируемых при сравнении. Все остальные символы сравниваются. Символы нумеруются начиная с единицы.
- `-w число символов` Определяет количество символов, начиная с начала строки, участвующих в сравнении. Все остальные символы игнорируются.
- `-f число_полей` Игнорировать при сравнении первые число_полей полей каждой строки ввода. Полем является строка непробельных символов, отделённая от соседних полей пробельными символами. Поля нумеруются начиная с единицы.

**diff**

Показывает различия между двумя файлами, в построчном сравнении. Причем выводятся только строки, в которых обнаружены отличия. Измененные строки отмечаются символом "с", удаленные - "d", а новые - "а".


## Управление процессам

**kill / xkill / pkill / killall**

Все они служат для завершения процессов. Но они принимают различные параметры для идентификации процессов. **Kill** нужен PID процесса, xkill - достаточно кликнуть по окну, чтобы закрыть его, **killall** и **pkill** принимают имя процесса.

**Команда killall** в Linux предназначена для «убийства» всех процессов, имеющих одно и то же имя. Это удобно, так как нам не нужно знать PID процесса. Например, мы хотим закрыть все процессы с именем gcalctool. Выполните в терминале:

```bash
killall gcalctool
```

Команда killall, так же как и kill, по умолчанию шлет сигнал SIGTERM. Чтобы послать другой сигнал нужно воспользоваться опцией _-s_. Например:

```bash
killall -s 9 gcalctool
```

Когда вы выполняете команду "kill", то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение. Всего вы можете использовать до 60 сигналов, но все, что нужно знать, это SIGTERM (15) и SIGKILL (9).

**SIGTERM** – Этот сигнал запрашивает остановку процесса который работает. Этот сигнал может быть проигнорирован. Процессу дается время, чтобы хорошо выключился. Когда программа хорошо выключается, это означает, что ей дано время, чтобы спасти его прогресс и освободить ресурсы. Другими словами, он не «forced» прекращение работы процесса.

**SIGKILL** – сигнал SIGKILL заставляет процесс прекратить выполнение своей работы немедленно. Программа не может игнорировать этот сигнал. Несохраненный прогресс будет потерян.

Вы можете просмотреть все сигналы с помощью команды:

```bash
$ kill -l
```

Вот некоторые:

|N|Имя|Описание|Можно перехватывать|Можно блокировать|
|---|---|---|---|---|
|1|HUP|Hangup. Отбой|Да|Да|
|2|INT|Interrupt. В случае выполнения простых команд вызывает прекращение выполнения, в интерактивных программах - прекращение активного процесса|Да|Да|
|3|QUIT|Как правило, сильнее сигнала Interrupt|Да|Да|
|4|ILL|Illegal Instruction. Центральный процессор столкнулся с незнакомой командой (в большинстве случаев это означает, что допущена программная ошибка). Сигнал отправляется программе, в которой возникла проблема|Да|Да|
|8|FPE|Floating Point Exception. Вычислительная ошибка, например, деление на ноль|Да|Да|
|9|KILL|Всегда прекращает выполнение процесса|Нет|Нет|
|11|SEGV|Segmentation Violation. Доступ к недозволенной области памяти|Да|Да|
|13|PIPE|Была предпринята попытка передачи данных с помощью конвейера или очереди FIFO, однако не существует процесса, способного принять эти данные|Да|Да|
|15|TERM|Software Termination. Требование закончить процесс (программное завершение)|Да|Да|

​

**ps / pgrep**

Команда ps выдает информацию об активных процессах. По умолчанию информация дается только о процессах, ассоциированных с данным терминалом. Выводятся идентификатор процесса, идентификатор терминала, истраченное к данному моменту время ЦП и имя команды. Если нужна иная информация, следует пользоваться опциями. Одна из самых распространенных комбинаций флагов: `ps aux` Выводятся все процессы, выполняющиеся от имени всех пользователей (выводит статистику, время старта процесса и команду, которая его стартовала)

**top / htop**

Обе команды похожи, обе отображают процессы, и могут быть использованы как консольные системные мониторы. Я рекомендую установить htop, если в вашем дистрибутиве он не поставляется по умолчанию, так как это намного улучшенная версия top. Вы сможете не только просматривать, но и контролировать процессы через его интерактивный интерфейс.

**time**

Время выполнения процесса. Это секундомер для выполнения программы. Полезно если вам интересно насколько сильно ваша реализация алгоритма отстает от стандартной. Но несмотря на такое название она не сообщит вам текущее время, используйте для этого команду date.


## Пользовательское окружение

**su / sudo**

Su и sudo - это два способа выполнить одну и ту же задачу - запустить программу от имени другого пользователя. В зависимости от вашего дистрибутива, вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет наиболее безопасным вариантом работы.

**сhroot**

Операция изменения корневого каталога диска для запущенного процесса и его дочерних процессов. Программа, запущенная в таком окружении не может получить доступ к файлам вне нового корневого каталога. Это измененное окружение называется chroot jail.

**date**

В отличие от time, делает именно то, чего вы от него и ожидаете - выводит дату и время в стандартный вывод. Вывод можно форматировать, в зависимости от ваших потребностей: вывести год, месяц, день, установить 12-ти или 24-ти часовой формат, получить наносекунды или номер недели. Например, date +"%j %V", выведет день в году и номер недели в формате ISO.

**alias**

Эта команда создает синонимы для других команд Linux. Это означает, что вы можете делать новые команды или группы команд, а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или создания более понятных имен для команд которые вы используете нечасто и не можете запомнить.

**uname**

Выводит некоторую основную информацию о системе. Без параметров она не покажет ничего полезного, кроме строчки Linux, но если задать параметр -a (All) можно получить информацию о ядре, имени хоста и узнать архитектуру процессора.

**uptime**

Сообщает вам время работы системы. Не очень существенная информация, но может быть полезна для случайных вычислений или просто ради интереса, как давно был перезагружен сервер.

**sleep**

Вам, наверное, интересно как же ее можно использовать. Но даже кроме Bash скриптинга, у нее есть свои преимущества. Например, если вы хотите выключить компьютер через определенный промежуток времени, или в качестве импровизированной тревоги.


## Управления пользователями

**useradd / userdel / usermod**

Эти команды консоли Linux позволяют вам добавлять, удалять и изменять учетные записи пользователей. Скорее всего, вы не будете использовать их очень часто. Особенно если это домашний компьютер, и вы являетесь единственным пользователем. И даже если нет, управлять пользователями можно с помощью графического интерфейса, но лучше о них знать на случай, если вдруг понадобится.

**passwd**

Эта команда позволяет изменить пароль учетной записи пользователя. Как суперпользователь, вы можете сбросить пароли всех пользователей, несмотря на то, что не можете их увидеть. Хорошая практика безопасности - менять пароль не очень редко.

#### Linux команды для просмотра документации

**man / whatis**

Команда man открывает руководство по определенной команде. Для всех основных команд Linux есть man страницы. Whatis какие разделы руководств есть для данной команды.

**whereis**

Показывает полный путь к исполняемому файлу программы. Также может показать путь к исходникам если они есть в системе.

### Команды Linux для управления сетью

**ip**

Если список команд Linux для управления сетью вам кажется слишком коротким, скорее всего, вы незнакомы с утилитой ip. В пакете net-tools содержится множество других утилит ipconfig, netstat и другие устаревшие, вроде iproute2. Все это заменяет одна утилита - ip. Вы можете рассматривать ее как швейцарский армейский нож для работы с сетью, или непонятную массу, но в любом случае за ней будущее.

**ping**

Ping - это ICMP ECHO_REQUEST дейтаграммы, но на самом деле это неважно. Важно то, что утилита ping может быть очень полезным диагностическим инструментом. Она поможет быстро проверить подключены ли вы к маршрутизатору или к интернету, и дает кое-какое представление о качестве этой связи.

**nethogs**

Если у вас медленный интернет, то вам, наверное, было бы интересно знать сколько трафика использует та или иная программа в Linux, или вообще какая программа потребляет всю скорость. Теперь это можно сделать с помощью утилиты nethogs. Для того чтобы задать сетевой интерфейс используйте опцию -i.

**traceroute**

Это усовершенствованная версия ping. Кроме непосредственно доступности узла, мы можем увидеть полный маршрут сетевых пакетов, а также время доставки их на каждый узел.


## Рецепты

- `lsof -i :8080` вывести список дескрипторов открытых файлов (`-i` — флаг для сетевых интерфейсов)
- `netstat | head -n20` вывести список открытых интернет/UNIX сокетов и связанной с ними информации
- `dstat -a` транслировать текущий диск, сеть, активность CPU и другое
- `nslookup <IP address>` найти hostname для удалённого IP-адреса
- `strace -f -e <syscall> <cmd>` отследить системные вызовы программы (`-e` — флаг для фильтрования конкретных системных вызовов)
- `ps aux | head -n20` вывести текущие активные процессы
- `file <file>` проверить тип файла (например исполняемый, бинарный, текстовый файл с кодировкой ASCII)
- `uname -a` информация о ядре ОС
- `lsb_release -a` информация об ОС
- `hostname` проверить hostname текущего компьютера (например, название, чтобы другие компьютеры могли иметь доступ к вашему)
- `pstree` визуализировать форки процессов
- `time <cmd>` исполнить команду и составить статистику о том, сколько времени потребовалось на исполнение
- `CTRL + z ; bg; jobs; fg` отправить процесс в текущий tty в background и обратно на передний план
- `cat file.txt | xargs -n1 | sort | uniq -c` посчитать количество уникальных слов в файле
- `wc -l <file>` количество строк в файле
- `du -ha` показать размер на диске для директорий и их содержимого
- `zcat <file.gz>` вывести содержимое заархивированного текстового файла
- `scp <user@remote_host> <local_path>` скопировать файл с удалённого на локальный сервер или наоборот
- `man {command}` показать инструкцию, (т.е. документацию) для команды (но скорее всего легче использовать Google)
