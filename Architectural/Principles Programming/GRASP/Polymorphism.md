Это шаблон проектирования, который позволяет объектам с разными типами данных выполнять одинаковые операции. Это означает, что если у вас есть объекты разных классов, но они должны выполнять одинаковые действия, вы можете использовать полиморфизм для обеспечения этого.

Устройство и поведение системы:

- Определяется данными
- Задано полиморфными операциями её интерфейса

Пример: Адаптация коммерческой системы к многообразию систем учёта налогов может быть обеспечена через внешний интерфейс объектов-адаптеров (смотрите также: Шаблон «Адаптеры»).

Пример **соблюдения** `Polymorphism`:

```ts
abstract class Animal {
    abstract makeSound(): void;
}

class Dog extends Animal {
    makeSound(): void {
        console.log('Woof!');
    }
}

class Cat extends Animal {
    makeSound(): void {
        console.log('Meow!');
    }
}

let animals: Animal[] = [new Dog(), new Cat()];
animals.forEach(animal => animal.makeSound());
```

В этом примере мы имеем абстрактный класс `Animal` с абстрактным методом `makeSound`. Затем мы создаем два класса `Dog` и `Cat`, которые наследуются от `Animal` и реализуют метод `makeSound`. Мы можем создать массив объектов `Animal` и вызвать метод `makeSound` для каждого объекта, не зная точного типа объекта. Это и есть пример использования полиморфизма.

---

Пример **нарушения** `Polymorphism`:

```ts
class Animal {
    makeSound(type: string): void {
        if (type === 'dog') {
            console.log('Woof!');
        } else if (type === 'cat') {
            console.log('Meow!');
        }
    }
}

let animal = new Animal();
animal.makeSound('dog');
animal.makeSound('cat');
```

В этом примере мы используем условный оператор для определения звука, который должен издать животное. Это нарушает принцип подстановки Барбары Лисков (Liskov Substitution Principle), который гласит, что подклассы должны быть заменяемыми на экземпляры своих суперклассов. В этом примере мы не можем заменить `Animal` на `Dog` или `Cat` без нарушения работы программы.