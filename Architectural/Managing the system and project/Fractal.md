По сравнению с компьютером, наш мозг вычислительно слаб. Нам трудно перемножать в уме большие числа, представлять в деталях сложные схемы или держать в голове одновременно много понятий.

При рефакторинге нам стоит следить за тем, насколько сложно «держать кусок кода в голове». Если приходится напрягаться, чтобы помнить обо всех деталях — в коде есть проблема.

В хорошем коде на экране ровно столько информации, сколько нужно читателю в конкретный момент. Марк Симанн предлагает писать программы так, чтобы на каждом «уровне детализации» количество составных частей не превышало некоторый лимит. Мы можем использовать эту эвристику, чтобы проверять, насколько код пересыщен деталями.

> [!WARN] Замечание
> В качестве лимита Марк предлагает число 7. Он опирается на предпосылки, что мы можем держать в голове 7±2 объекта. При этом он оговаривается, что конкретное число не принципиально, главное — наличие такого лимита.

Для визуализации «уровней» он предлагает использовать сетку из шестигранников. Каждый шестигранник — это часть системы, которая может быть детализирована глубже, на такие же шестигранники.

На каждом из уровней детализации мы будем видеть не больше N составных частей, важных для этого уровня. Если нам требуется узнать, как работает конкретная часть, то мы можем «провалиться» на уровень ниже и увидеть, из чего она состоит.

![[./_/fractal-1.png]]
>Так программа разбивается на куски, которые разбиваются на куски,
которые разбиваются на куски...

Чтобы понять, как это помогает рефакторить код, рассмотрим пример. Допустим, у нас есть приложение, в котором для залогиненных пользователей мы показываем дашборд, а для остальных — страницу входа.

Входная точка приложения (верхний уровень детализации) может выглядеть как-то так:

```javascript
const App = () => {
  const user = currentUser();
  const isManager = hasManagerRole(user);
  const isPromoAccount = checkPromoAccount(location);
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const handleSubmit = () => {
    /*...*/
  };
  return isManager || isPromoAccount ? (
    <Dashboard />
  ) : (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={({ target }) => setEmail(target.value)}
      />
      <input
        type="password"
        password={password}
        onChange={({ target }) => setPassword(target.value)}
      />
      <button>Login</button>
    </form>
  );
};
```

Понять такой код вполне реально, но из-за количества деталей на это уйдёт сравнительно больше времени. Количество информации в этом куске кода подбирается к пределам рабочей памяти нашего мозга.

Если выразить этот код на диаграмме детализации, можно заметить, что некоторые части на ней не помещаются:

![[./_/fractal-2.png]]

Код будет значительно проще исследовать, если на верхнем уровне мы «подготовим» читателя и расскажем, что делает компонент `App`. Имена переменных и подкомпонентов выразят намерение и сложатся в «историю»:

```javascript
const App = () => {
  const hasAccess = useHasAccess();
  return hasAccess ? <Dashboard /> : <Login />;
};

/**
* Если пользователям разрешён доступ (`hasAccess`) к панели управления,
* приложение покажет им компонент панели управления (`Dashboard`),
* в обратном случае им предложат залогиниться (`Login`).
*/
```

Подробности «истории» мы представим через реализацию соответствующих функций и компонентов. Например, мы расскажем, как определить, есть ли у пользователя доступ к панели управления, через реализацию хука `useHasAccess`:

```javascript
function useHasAccess() {
  const user = currentUser();
  const isManager = hasManagerRole(user);
  const isPromoAccount = checkPromoAccount(location);
  return isManager || isPromoAccount;
}

/**
* Мы проверим, является ли текущий пользователь (`currentUser`)
* менеджером (`hasManagerRole`),
* а также запущено ли приложение под промо-аккаунтом,
* в котором панель управления доступна всем подряд (`checkPromoAccount`).
*/
```

Так на верхнем уровне детализации мы видим всего лишь 3 составные части: `hasAccess`, `Dashboard` и `Login`. Такую схему нам гораздо проще «загрузить» в голову и вникать в отношения между частями.

![[./_/fractal-3.png]]

Если нам требуется детализировать часть «истории», мы можем «приблизиться» в одну из ячеек и рассмотреть её устройство.

Например, в `useHasAccess` мы видим, как её 4 составные части работают друг с другом. На этом уровне уже не так важно, что происходит «выше», мы сосредотачиваемся на устройстве `useHasAccess`.

![[./_/fractal-4.png]]

Польза фрактальности в том, что мы можем вкладывать один уровень в другой:

![[fractal-5.png]]

...И переключать внимание между уровнями в любой момент:

![[./_/fractal-6.png]]

Мы можем приблизить любой шестигранник, чтобы рассмотреть его части. И также мы можем приблизить любую из его частей, погружаясь в детали системы глубже и глубже, но контролируя их количество.

На каждом из уровней нас будет ждать ограниченный комфортный объём информации, которую нужно «загрузить в оперативную память» мозга. Исследовать и читать такой код значительно проще.

Абстракция «вшита» в этот подход. Мы можем «отзумиться» на уровень вверх, чтобы посмотреть на взаимодействие модуля с другими либо, наоборот, «провалиться» на уровень вниз, чтобы разглядеть детали его работы.

## Источники
- #### [bespoyasov](https://github.com/bespoyasov/refactor-like-a-superhero)