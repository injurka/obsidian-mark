Вместо того чтобы думать о системе как о наборе технических слоев (_Reducers_, _Actions_, _Selectors_ и компоненты), приложение можно представить как набор фичей (_features_), объектов из предметной области нашего проекта.

Другими словами это называется **подходом вертикальных слайсов** (_slice_, их еще называют срезами, но для простоты я ниже буду употреблять только «слайс»). Подход подразумевает, что архитектура строится не вокруг технических слоев (_layer_), а поверх конкретных слайсов (бизнес фич) проекта. Например, в случае онлайн магазина - это корзина/заказ/товар, в случае чата - контакт/чат/сообщение, в случае github-а - репозиторий/ветка/коммит.

Мы берем любую архитектуру на основе слоев (здесь так же может подойти и n-tier, гексагональная или чистая архитектура), удаляем границу между слоями и строим границы между слайсами:

![[./assets/vertical-sliced.jpg]]

Сперва начали складывать по слайсам только слои, которые относятся к состоянию приложения (в контексте редакса: _Reducers_, _Actions_, _Selectors_). Назвали это «_Duck modular approach_», а основные моменты описали в [github/ducks-modular-redux](https://github.com/erikras/ducks-modular-redux):

```treeview
src
├── api/
├── components/
├── constants/
├── containers/
├── ducks
│   ├── cart
│   │   ├── actions.ts
│   │   ├── reducer.ts
│   │   ├── selectors.ts
│   │   └── index.js
│   ├── product/
│   ├── ...
│   └── other/
├── pages/
└── index.js
```

Реальный пример можете посмотреть в одном из моих стареньких пет проектов [github/react-ssr-tutorial/src/store/ducks/catalog/*](https://github.com/noveogroup-amorgunov/react-ssr-tutorial/tree/master/src/store/ducks/catalog).

А после пришло понимание, что вертикальные слайсы можно применять не только для состояния, а на всех уровнях приложения:

```treeview
src
├── features
│   ├── cart
│   │   ├── api/
│   │   ├── components/
│   │   ├── containers/
│   │   ├── constants/
│   │   ├── ducks/
│   │   └── index.js
│   ├── product/
│   ├── ...
│   └── other/
├── pages/
└── index.js
```

Добавляя или изменяя фичу в приложении, обычно затрагивается множество технических слоев. Например, при добавлении промокодов в корзину (_cart_), нужно поменять пользовательский интерфейс, добавить поля в интерфейс модели, изменить проверки и так далее. Вместо изменений по всему приложению и связями между слоями, вертикальные слайсы позволяют работать в контексте самого слайса.

На выходе **получаем высокое зацепление (_high cohesion_) внутри слайса и низкую связанность (_low coupling_) между разными слайсами** (противоположную модель из первой архитектуры).

Любая новая продуктовая фича не будет затрагивать написанный код чужих модулей, и не нужно переживать по поводу возможных сайд эффектов. А рефакторинг текущих - только связанные слайсы. Круто, не так ли?

Например, нужно загрузить список с товарами или отменить заказ: все эти пользовательские истории будут реализовываться в рамках конкретной фичи.

![[./assets/user-cases-in-slices-context.jpg]]

### Что с общим кодом?

На любом проекте есть код, не связанный с бизнес фичами напрямую: общие хелперы, UI компоненты (кнопки, формы, лайаут) или глобальное shared-состояние, которые используются во многих фичах одновременно. А так же различные инфраструктурные вещи (работа с конфигами, переводами, нотификациями и т.д.). На этот случай выделяют специальную директорию _shared_, в которой все и складируют. Для того чтобы это папка не превращалась в _мусорку_, она может иметь те же название поддиректорий, что и любой слайс из фич (api, компоненты, контейнеры, _даки_ и т.д.):

```treeview
src
├── features/
├── pages/
├── shared
│   ├── api/
│   ├── components/
│   ├── store/
│   ├── ...
│   └── other/
└── index.js
```

> Глобальное shared-состояние - это кстати антипаттерн, но его часто можно встретить в боевых проектах

Уже здесь можно заметить, что у нас опять вырисовывается структура проекта на верхнем уровне на основе технических слоев, а в внутри каждого слоя код разделен на вертикальные слайсы (за исключением _shared_).

### Важное правило

Для вертикальных слайсов сохраняется однонаправленный поток импортов внутри самих слайсов. А так же добавляется новое правило: **фичи не могут напрямую использовать друг друга**. Если нужно использовать какие-нибудь данные/UI из соседней фичи, то можно использовать DI или паттерн _render-prop_, когда мы можем прокинуть зависимость снаружи (например, со страницы).

Это позволяет держать фичи максимально изолировано друг от друга (так называемая модульная архитектура), решить проблемы циклических импортов и следовать подходу _high cohesion_ - _low coupling_.

### «Фича драйвен девелопмент»

Давайте на время забудем о том, что мы обсуждали ранее, и посмотрим на фичи с другой стороны. Я уверен, что все, кто когда-то занимался архитектурой, приходит к следующему заключению: весь интерфейс можно разбить на самостоятельные модули (более высокоуровневые, чем просто компоненты или контейнеры), которые можно переиспользовать и содержащие свою бизнес логику. Такой подход даже получил название - _feature driven development_ (именно в рамках фронтенд разработки, так как есть еще одноименная методология в менеджменте), и он успешно применяется на многих проектах, в которых я работал.

Таким фичам обычно выставляют следующие требования:

- _self-contained_ - Изоляция - содержит внутри себя все необходимое для работы
- _user-facing_ - Ориентация на пользователя - направлена на какую-то пользовательскую потребность (сделать действие, показать информацию и т.д.)
- _reusable_ - Переиспользуемость - может быть переиспользована на различных страницах
- _complex logic_ - Сложная логика - сложнее чем обычный компонент или контейнер (более высокий уровень абстракции)

Рассмотрим пример модуля, который выводит детальную информацию о продукте - _productDetails_.

![Интерфейс модуля детальной информации и продукте](https://amorgunov.com/assets/images/2023-05-28-vertical-sliced-architecture-in-frontend/7-product-details.out.jpg)

У этого модуля может быть свой запрос в API, свое состояние (загружаются данные, была ли получена ошибка), свой UI (общая сетка, изображения, пользовательские действия (добавить товар в корзину), доступные размеры и т.д.). Он ориентирован на пользователя (предоставляет детальную информацию о товаре). Его можно переиспользовать в различных местах: на отдельной странице или внутри какого-нибудь модального окна. Все требования выполнены - это фича.

Все приложение может состоять из таких вот фичей:

![Разбиваем интерфейс на фичи](https://amorgunov.com/assets/images/2023-05-28-vertical-sliced-architecture-in-frontend/6-product-details-in-features-slice.out.jpg)

Но как объединить этот паттерн фичей со структурой проекта из прошлых разделов? Здесь нам поможет простое правило - не хватает уровня композиции для слоев, вводим новый слой!

## Новый слой - «Domain»

Для решения проблемы можно ввести еще один слой, в котором складывать все бизнес сущности (корзина, товары, пользователь и т.д.). Этот слой не что-то новое, а давно известное понятие из чистой архитектуры и DDD - домен приложения. **Под ним понимают те бизнес сущности, которые описывают предметную область приложения**. Простая аналогия (но не совсем правильная) - в домене можно хранить все то, что хранится в базе данных на бекенде.

Правда мы немного отойдем от канонов чистой архитектуры и помимо самих сущностей (типов и преобразований данных) будем хранить базовые UI (все же у нас фронтенд и все сильно завязано на UI), походы в API (например, получение информации о текущем пользователе), _TypeScript_ типы, состояние и т.д.

А в `features/*` мы будем складывать наши _self-contained_ модули:

```treeview
src
├── domain
│   ├── product
│   │   ├── api/
│   │   ├── components/
│   │   ├── store/
│   │   ├── ...
│   │   └── other/
│   ├── ...
│   └── other/
├── features/
│   ├── productDetails/
│   ├── productAlreadyPurchasedGrid/
│   │   ├── api/
│   │   ├── components/
│   │   ├── store/
│   │   ├── ...
│   │   └── other/
│   ├── productFavoriteList/
│   ├── productPopuparSlider/
│   ├── productListFilters/
│   ├── productListSorting/
│   ├── productListViewMode/
│   ├── ...
│   └── other/
├── pages/
├── shared/
└── index.js
```

> Кстати фичи можно группировать по префиксу в названии (чтобы не увеличить вложенность). Например, все что касается товаров, начинать с _product*_, корзины - _cart*_ и т.д.

### Пример, что может лежать в домене

Рассмотрим, что может находиться внутри домена (не забываем, что обсуждения идут в рамках фронтенд проекта). Есть какая-то фича со списком товаров:

![Что может лежать в домене](https://amorgunov.com/assets/images/2023-05-28-vertical-sliced-architecture-in-frontend/8-domain-parts.out.jpg)

Внутри списка используется карточка отображения, которая используется по всему приложению? Отличный кандидат для попадания в `domain/product/components/ProductCard.tsx`. Есть действие добавление в список желаний/корзину - `domain/product/store/actions/*`. Как то форматируется цена - `domain/product/helpers/formatPrice.ts`. И так далее. Все, что используется универсально на уровне бизнес сущности по всему приложению (в различных фичах или страницах) можно вынести в слой `domain`.