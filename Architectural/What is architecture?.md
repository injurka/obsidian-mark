Успешному рефакторингу большого куска приложения может мешать слабая архитектура. Высокое зацепление между частями кода и беспорядочные зависимости мешают находить швы и изолировать изменения во время работы с кодом. А неочевидное взаимодействие частей приложения делает код запутанным и непонятным.

## Не про «папочки»

Архитектура — это взаимодействие частей системы; верхний уровень детализации приложения; выявление и приоритизация требований.

В проектировании приложений не существует универсального решения, потому что особенности и требования у каждого проекта уникальны. Мы вряд ли сможем найти предметные области, которые бы не отличались друг от друга. То же и с проектами — два похожих приложения могут быть устроены по-разному из-за своих ограничений и требований.

Под требованиями имеется в виду функциональные, системные, бизнес- и другие требования.

Инструменты, о которых пойдёт речь дальше, — это не набор обязательных практик. Это скорее палитра, из которой можно выбирать подходящий инструмент под конкретную задачу. Ничего «обязательного» в архитектуре быть не может, каждый проект — это набор ограничений и компромиссов, баланс которых зависит от задачи.

### Самое важное что нужно помнить

> [!ERROR] Запомнить
> #### Проектирование ≠ раскладывание кода по папочкам

Папочки — это способ удобно исследовать код и открывать файлы в редакторе. Гораздо важнее, какие из выявленных требований критичны и как сделать так, чтобы организация кода не мешала развитию программы.

Требования дают понимание, как система должна себя вести в разных условиях. Это понимание уже подскажет детали организации: как должны друг с другом взаимодействовать части программы, что от чего должно зависеть, и какой уровень зацепления кода приемлем.

Цель приемлемой архитектуры в том, чтобы:
- не мешать разработке и не блокировать изменения программы;
- уменьшать количество решений, которые надо принимать прямо сейчас;
- стандартизировать написание кода и добавление фич;
- быть гибкой и оставлять пространство для изменений в будущем.

Не каждому приложению нужна пуленепробиваемая архитектура. Тратить время на улучшение архитектуры прототипа, который будет заброшен, бессмысленно. Но если приложение должно жить долго, а организация кода заметно мешает нам работать, можно попробовать выделить время на архитектурные улучшения.

> Нет гарантий, что попытка поможет улучшить ситуацию. Иногда действительно проще переписать приложение с нуля, учтя предыдущий опыт и требования, которые стали известны за время жизни проекта.

## Моделирование бизнес-процессов

Главная ценность приложения в его бизнес-логике — тех процессах, которые приносят прибыль. Описание таких процессов в коде — это модель предметной области или доменная модель. При рефакторинге приложения нам стоит обратить внимание, насколько чётко и однозначно определена эта модель. Могут ли разные разработчики определить из куска кода, о чём в нём идёт речь? Насколько точно они могут это сделать? Сколько будет разночтений в их мнениях?

### Повсеместный язык

При рефакторинге нам стоит следить, чтобы термины в коде соответствовали этому языку. Повсеместный язык уменьшает разногласия при чтении, потому что создаёт однозначные связи между термином и сущностью или процессом.

В примере ниже код нарушает этот принцип и использует разные термины для пользователя интернет-магазина:

```js
const isMerchant = (user) => user.role === "seller";
const SellerPanel = ({ user }) => isMerchant(user) && <main>{/*...*/}</main>;
```

Из контекста непонятно, чем отличаются термины “seller” и “merchant”. Если термины значат одно и то же, лучше выбрать и оставить только один из них. Предпочтительнее выбрать тот, которым пользуется продукт-оунер или стейкхолдеры.

```js
// Продукт-оунеры используют термин “seller”,
// поэтому и мы тоже будем использовать его:
const isSeller = (user) => user.role === "seller";
const SellerPanel = ({ user }) => isSeller(user) && <main>{/*...*/}</main>;
```

### Доменная модель

Как упомянуто ранее, доменная модель — это преобразования данных, отражающие бизнес-процессы. Доменные преобразования удобно выделять в отдельные функции, которые потом компоновать в цепочки преобразований данных.

Чтобы понять чем это полезно, посмотрим на пример. Допустим, перед нами функция онлайн-площадки для проведения аукционов. Функция создаёт объект нового аукциона и пытается добавить в него всё, что может произойти с аукционом за время его жизни:

```js
function composeAuction(user, from, to, products, startPrice, invited) {
  return {
    created: true,
    author: user,
    timeRange: { from, to },
    lots: products.map(lotFromProduct),
    price: startPrice,
    participants: invited.filter(accepted),
    winners: [],
    bids: [],
    bestBid: null,
    open: false,
    expired: false,
    cancelled: false,
    closedLots: null
  };
}
```

Проблема функции `composeAuction` в том, что она не разделяет разные этапы жизненного цикла аукционов. При рефакторинге мы можем сперва выделить все возможные состояния, через которые проходит аукцион, а потом описать преобразования, которые будут приводить его в эти состояния. Например:

```js
function createAuction(user, from, to, lots, startPrice) {
  return {
    author: user,
    timeRange: { from, to },
    lots: products.map(lotFromProduct),
    price: startPrice,
    status: STATUS.created,
  };
}

function inviteParticipants(auction, participants) {
  return {
    ...auction,
    participants,
    status: STATUS.inviting,
  };
}

function canStart(auction) {
  const moment = Date.now();
  const { from, to } = auction.timeRange;
  return moment >= from && moment <= to;
}

function startAuction(auction) {
  return {
    ...auction,
    participants: auction.participants.filter(accepted),
    currentLot: auction.lots.find(available),
    status: STATUS.active,
  };
}

function addBid(auction, bid) {
  return { ...auction, bids: [...auction.bids, bid] };
}

function expireAuction(auction) {
  const { currentLot, ...rest } = auction;
  return {
    ...rest,
    closedLots: auction.lots.filter(isClosed),
    status: STATUS.expired,
  };
}

function defineWinners(auction) {
  return { ...auction, winners: participants.filter(ownsLot) };
}
```

Функции доменной модели должны уметь «прокручивать» бизнес-процессы от начала и до конца, преобразовывая данные. Если мы можем это сделать, значит мы достаточно адекватно и полно отобразили предметную область в коде.

### Направление зависимостей

Код, описывающий пользовательские сценарии, лучше выражать в виде Impureim-сендвича. В таком коде мы сперва получаем данные из «нечистых» источников, затем прогоняем их через цепочки преобразований, а потом сохраняем или выводим на экран.

## Связь с внешним миром

При рефакторинге большого куска приложения нам также стоит обращать внимание на зацепление кода со внешним миром. Зацепление может быть явным, когда мы используем сервис напрямую, привязываясь к его структуре. Но также зацепление может быть неявным.

Например, в интернет-магазине для создания заказа сервер просит в запросе от клиента объект с полем `products`. Так совпало, что в клиентском коде объект заказа тоже содержит поле `products`. Появляется желание использовать этот объект напрямую при отправке заказа:

```js
function createOrder(user, products) {
  return { user, products };
}

async function sendOrder(order) {
  const response = await fetch("/api/orders/", {
    method: "POST",
    body: JSON.stringify(order),
  });
}

const order = createOrder(currentUser, productList);
await sendOrder(order);
```

Выглядит удобно, но мы только что создали точку зацепления с сервером. Мы теперь не можем изменить структуру объекта заказа внутри `createOrder`, потому что это поломает совместимость с сервером.

Это может быть пустяком для небольших проектов, которые редко меняют структуры данных или API. Но если нам важно масштабирование или гибкость API, или мы часто меняем названия полей в структурах данных на клиенте — это станет проблемой.

В таких ситуациях мы можем добавить анти-коррозионный слой (Anti-Corruption Layer, ACL):

```js
function toServerOrder(clientOrder) {
  const serverOrder = {
    userId: clientOrder.user.id,
    orderItems: clientOrder.products.map(product => ({
      productId: product.id,
      quantity: product.quantity,
    })),
  };
  return serverOrder;
}

async function sendOrder(order) {
  const dto = toServerOrder(order);
  const response = await fetch("/api/orders/", {
    method: "POST",
    body: JSON.stringify(dto),
  });
}
```

Анти-коррозионный слой может увеличить сложность кода. Обычно его стоит добавлять места, где есть подозрение, что могут измениться данные или API: аналитика, логирование, сохранение данных на девайс пользователя и т.д.

### Порты и адаптеры

Стоит упомянуть и архитектурный паттерн «Порты и адаптеры». Под адаптером мы понимаем сущность, которая преобразует несовместимый интерфейс одного модуля к нуждам другого. Порт — это спецификация того, как модуль хочет, чтобы с ним общались другие.

Использование стиля «Порты и адаптеры» автоматически подталкивает к написанию кода в стиле Impureim-сендвича, потому что толкает «общение с чужаками» к краям приложения.

Использование этого подхода помогает уменьшить количество моков для тестов. Если мы везде используем один адаптер для запросов к сети, то проверить надо только его, а не мокать каждый запрос к сети. Это снижает необходимость обновлять тесты на каждое изменение кода, делая урон от тестов ниже.

Также порты и адаптеры купируют распространение изменений в пределах модуля. Место сочленения адаптера и интерфейса, который он адаптирует, служит барьером, на котором изменение должно остановиться.

> Не любому проекту это может быть нужно. В простых приложениях, которые не собираются масштабироваться, порты и адаптеры могут добавить лишней работы без явной выгоды.

## Источники
- #### [bespoyasov](https://github.com/bespoyasov/refactor-like-a-superhero)