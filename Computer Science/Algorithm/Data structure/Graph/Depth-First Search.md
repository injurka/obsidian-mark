Поиск в глубину (DFS) — это рекурсивный алгоритм обхода корневого дерева или графа, начинающий в корневой вершине (в случае графа может быть выбрана произвольная вершина) и рекурсивно обходящий весь граф, посещая каждую вершину ровно один раз.

**DFS** находит такой путь от данной вершины, до нужной, что этот путь содержит минимальную сумму ребер графа. Например, если мы ищем на карте метро путь от Сокольников, до Парка Победы, требующий наименьшее время для переезда(расстояние между каждыми соседними станциями, будет весом ребра), то мы ищем в глубину.

**DFS** следует концепции «погружайся глубже, головой вперед» («go deep, head first»). Идея заключается в том, что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по определенному пути) до тех пор, пока не достигнем конца пути или пункта назначения (искомой вершины). Если мы достигли конца пути, но он не является пунктом назначения, то мы возвращаемся назад (к точке разветвления или расхождения путей) и идем по другому маршруту.

## Простой DFS

```javascript
const maxn = 1e5;
const used = new Array(maxn).fill(false); // Массив для отметки посещенных вершин

function dfs(v, g) {
    used[v] = true;
    for (let u of g[v]) {
        if (!used[u]) {
            dfs(u, g);
        }
    }
}
```

## Модифицированный DFS с сохранением времени входа и выхода

Мы будем сохранять для каждой вершины, в какой момент мы в неё вошли и в какой вышли, используя массивы `tin` и `tout`.

```javascript
const tin = new Array(maxn).fill(0);
const tout = new Array(maxn).fill(0);
let t = 0; // Таймер

function dfs(v, g) {
    tin[v] = t++;
    for (let u of g[v]) {
        if (!used[u]) {
            dfs(u, g);
        }
    }
    tout[v] = t; // Иногда счетчик тут тоже увеличивают
}
```

## Полезные свойства массивов `tin` и `tout`

1. Вершина `u` является предком `v` ⟺ `tin[v]` ∈ `[tin[u], tout[u])`. Эту проверку можно делать за константу.
2. Два полуинтервала `[tin[v], tout[v])` и `[tin[u], tout[u])` либо не пересекаются, либо один вложен в другой.
3. В массиве `tin` есть все числа от 0 до `(n-1)`, причём у каждой вершины свой номер.
4. Размер поддерева вершины `v` (включая саму вершину) равен `(tout[v] - tin[v])`.
5. Если ввести нумерацию вершин, соответствующую `tin`, то индексы любого поддерева всегда будут каким-то промежутком в этой нумерации.