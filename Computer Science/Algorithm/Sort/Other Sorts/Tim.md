Tim Sort — это гибридный алгоритм сортировки, полученный из merge sort и insertion sort. Он был разработан для хорошей работы с различными видами реальных данных. Tim Sort является алгоритмом сортировки по умолчанию, используемым в функциях Python `sorted()` и `list.sort()`.

## Основная идея Tim Sort

Основная идея Tim Sort заключается в использовании существующего порядка в данных для минимизации количества сравнений и перестановок. Это достигается путем разделения массива на небольшие подмассивы, называемые "runs", которые уже отсортированы, а затем слияния этих runs с использованием модифицированного алгоритма merge sort.

## Как работает Tim Sort?

Рассмотрим следующий массив в качестве примера: `arr[] = {4, 2, 8, 6, 1, 5, 9, 3, 7}`.

### Шаг 1: Определение размера run

- Минимальный размер run: 32 (мы проигнорируем этот шаг, так как наш массив мал)

### Шаг 2: Разделение массива на runs

- На этом шаге мы будем использовать сортировку вставками для сортировки небольших подпоследовательностей (runs) внутри массива.
- Исходный массив: `[4, 2, 8, 6, 1, 5, 9, 3, 7]`
- Начальных runs нет, поэтому мы создадим runs с использованием сортировки вставками.
- Отсортированные runs: `[2, 4]`, `[6, 8]`, `[1, 5, 9]`, `[3, 7]`
- Обновленный массив: `[2, 4, 6, 8, 1, 5, 9, 3, 7]`

### Шаг 3: Слияние runs

- На этом шаге мы будем сливать отсортированные runs с использованием модифицированного алгоритма merge sort.
- Сливать runs до тех пор, пока весь массив не будет отсортирован.
- Объединенные runs: `[2, 4, 6, 8]`, `[1, 3, 5, 7, 9]`
- Обновленный массив: `[2, 4, 6, 8, 1, 3, 5, 7, 9]`

### Шаг 4: Настройка размера run

- После каждой операции слияния мы удваиваем размер run до тех пор, пока он не превысит длину массива.
- Размер run удваивается: 32, 64, 128 (мы проигнорируем этот шаг, так как наш массив мал)

### Шаг 5: Продолжение слияния

- Повторять процесс слияния до тех пор, пока весь массив не будет отсортирован.
- Финальный объединенный run: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`

Финальный отсортированный массив: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`.

Ниже приведена реализация Tim Sort:

```ts
const MIN_MERGE: number = 32; 

function minRunLength(n: number): number { 
    // Становится 1, если какие-либо 1 биты сдвигаются 
    let r: number = 0; 
    while (n >= MIN_MERGE) { 
        r |= (n & 1); 
        n >>= 1; 
    } 
    return n + r; 
} 

// Эта функция сортирует массив от левого индекса 
// до правого индекса, который имеет размер не более RUN 
function insertionSort(arr: number[], left: number, right: number): void { 
    for (let i: number = left + 1; i <= right; i++) { 
        let temp: number = arr[i]; 
        let j: number = i - 1; 
        
        while (j >= left && arr[j] > temp) { 
            arr[j + 1] = arr[j]; 
            j--; 
        } 
        arr[j + 1] = temp; 
    } 
} 

// Функция merge объединяет отсортированные прогоны 
function merge(arr: number[], l: number, m: number, r: number): void { 
    // Исходный массив разбит на две части 
    // левый и правый массивы 
    let len1: number = m - l + 1; 
    let len2: number = r - m; 
    let left: number[] = new Array(len1); 
    let right: number[] = new Array(len2); 
    for (let x: number = 0; x < len1; x++) { 
        left[x] = arr[l + x]; 
    } 
    for (let x: number = 0; x < len2; x++) { 
        right[x] = arr[m + 1 + x]; 
    } 

    let i: number = 0; 
    let j: number = 0; 
    let k: number = l; 

    // После сравнения, мы объединяем эти два 
    // массива в больший подмассив 
    while (i < len1 && j < len2) { 
        if (left[i] <= right[j]) { 
            arr[k] = left[i]; 
            i++; 
        } else { 
            arr[k] = right[j]; 
            j++; 
        } 
        k++; 
    } 

    // Копируем оставшиеся элементы 
    // левого, если таковые есть 
    while (i < len1) { 
        arr[k] = left[i]; 
        k++; 
        i++; 
    } 

    // Копируем оставшиеся элементы 
    // правого, если таковые есть 
    while (j < len2) { 
        arr[k] = right[j]; 
        k++; 
        j++; 
    } 
} 

// Итеративная функция timSort для сортировки 
// массива[0...n-1] (аналогично merge sort) 
function timSort(arr: number[], n: number): void { 
    let minRun: number = minRunLength(MIN_MERGE); 
        
    // Сортируем отдельные подмассивы размером RUN 
    for (let i: number = 0; i < n; i += minRun) { 
        insertionSort(arr, i, Math.min((i + MIN_MERGE - 1), (n - 1))); 
    } 

    // Начинаем объединение с размера 
    // RUN (или 32). Оно будет 
    // объединяться, образуя размер 64, 
    // затем 128, 256 и так далее 
    // .... 
    for (let size: number = minRun; size < n; size = 2 * size) { 
        
        // Выбираем начальную точку 
        // левого подмассива. Мы 
        // собираемся объединить 
        // arr[left..left+size-1] 
        // и arr[left+size, left+2*size-1] 
        // После каждого объединения, мы 
        // увеличиваем left на 2*size 
        for (let left: number = 0; left < n; left += 2 * size) { 

            // Находим конечную точку левого подмассива 
            // mid+1 является начальной точкой правого подмассива 
            let mid: number = left + size - 1; 
            let right: number = Math.min((left + 2 * size - 1), (n - 1)); 

            // Объединяем подмассив arr[left.....mid] & 
            // arr[mid+1....right] 
            if (mid < right) { 
                merge(arr, left, mid, right); 
            } 
        } 
    } 
} 

let arr: number[] = [-2, 7, 15, -14, 0, 15, 0, 7, -7, -4, -13, 5, 8, -14, 12]; 
let n: number = arr.length; 
console.log("Заданный массив", arr); 
timSort(arr, n); 

console.log("После сортировки массив", arr); 
```

### Как реализуется:

1. **insertionSort**:
   - Функция `insertionSort` сортирует подмассив от `left` до `right` с использованием алгоритма сортировки вставками.

2. **merge**:
   - Функция `merge` объединяет два отсортированных подмассива. Она создает временные массивы `L` и `R` для левой и правой частей соответственно, а затем объединяет их в исходный массив.

1. **timSort**:
   - Функция `timSort` реализует основной алгоритм Tim Sort.
   - Сначала она сортирует отдельные подмассивы размером `RUN` (в данном случае 32) с использованием `insertionSort`.
   - Затем она объединяет эти отсортированные подмассивы, увеличивая размер слияния вдвое на каждой итерации, пока весь массив не будет отсортирован.

## Источники
- #### [baeldung](https://www.baeldung.com/cs/timsort)