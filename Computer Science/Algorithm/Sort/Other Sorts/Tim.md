Tim Sort — это гибридный алгоритм сортировки, полученный из merge sort и insertion sort. Он был разработан для хорошей работы с различными видами реальных данных. Tim Sort является алгоритмом сортировки по умолчанию, используемым в функциях Python `sorted()` и `list.sort()`.

## Основная идея Tim Sort

Основная идея Tim Sort заключается в использовании существующего порядка в данных для минимизации количества сравнений и перестановок. Это достигается путем разделения массива на небольшие подмассивы, называемые "runs", которые уже отсортированы, а затем слияния этих runs с использованием модифицированного алгоритма merge sort.

## Как работает Tim Sort?

Рассмотрим следующий массив в качестве примера: `arr[] = {4, 2, 8, 6, 1, 5, 9, 3, 7}`.

### Шаг 1: Определение размера run

- Минимальный размер run: 32 (мы проигнорируем этот шаг, так как наш массив мал)

### Шаг 2: Разделение массива на runs

- На этом шаге мы будем использовать сортировку вставками для сортировки небольших подпоследовательностей (runs) внутри массива.
- Исходный массив: `[4, 2, 8, 6, 1, 5, 9, 3, 7]`
- Начальных runs нет, поэтому мы создадим runs с использованием сортировки вставками.
- Отсортированные runs: `[2, 4]`, `[6, 8]`, `[1, 5, 9]`, `[3, 7]`
- Обновленный массив: `[2, 4, 6, 8, 1, 5, 9, 3, 7]`

### Шаг 3: Слияние runs

- На этом шаге мы будем сливать отсортированные runs с использованием модифицированного алгоритма merge sort.
- Сливать runs до тех пор, пока весь массив не будет отсортирован.
- Объединенные runs: `[2, 4, 6, 8]`, `[1, 3, 5, 7, 9]`
- Обновленный массив: `[2, 4, 6, 8, 1, 3, 5, 7, 9]`

### Шаг 4: Настройка размера run

- После каждой операции слияния мы удваиваем размер run до тех пор, пока он не превысит длину массива.
- Размер run удваивается: 32, 64, 128 (мы проигнорируем этот шаг, так как наш массив мал)

### Шаг 5: Продолжение слияния

- Повторять процесс слияния до тех пор, пока весь массив не будет отсортирован.
- Финальный объединенный run: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`

Финальный отсортированный массив: `[1, 2, 3, 4, 5, 6, 7, 8, 9]`.

Ниже приведена реализация Tim Sort:

```ts
function insertionSort(arr: number[], left: number, right: number): void {
    // Сортировка вставками для подмассива от left до right
    for (let i = left + 1; i <= right; i++) {
        const temp = arr[i];
        let j = i - 1;
        while (j >= left && arr[j] > temp) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}

function merge(arr: number[], left: number, mid: number, right: number): void {
    // Объединение двух отсортированных подмассивов
    const len1 = mid - left + 1;
    const len2 = right - mid;
    const L = new Array(len1);
    const R = new Array(len2);

    // Копирование данных во временные массивы L и R
    for (let i = 0; i < len1; i++) {
        L[i] = arr[left + i];
    }
    for (let i = 0; i < len2; i++) {
        R[i] = arr[mid + 1 + i];
    }

    let i = 0; // Индекс для первого подмассива
    let j = 0; // Индекс для второго подмассива
    let k = left; // Индекс для объединенного массива

    // Объединение временных массивов обратно в arr[left..right]
    while (i < len1 && j < len2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Копирование оставшихся элементов L[], если есть
    while (i < len1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Копирование оставшихся элементов R[], если есть
    while (j < len2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

function timSort(arr: number[]): void {
    const n = arr.length;
    const RUN = 32; // Размер подмассива для сортировки вставками

    // Сортировка отдельных подмассивов размером RUN
    for (let i = 0; i < n; i += RUN) {
        insertionSort(arr, i, Math.min(i + RUN - 1, n - 1));
    }

    // Объединение отсортированных подмассивов
    for (let size = RUN; size < n; size = 2 * size) {
        for (let left = 0; left < n; left += 2 * size) {
            const mid = left + size - 1;
            const right = Math.min(left + 2 * size - 1, n - 1);
            if (mid < right) {
                merge(arr, left, mid, right);
            }
        }
    }
}

// Пример использования
let arr = [4, 2, 8, 6, 1, 5, 9, 3, 7];
timSort(arr);
console.log(arr); // Вывод: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### Как реализуется:

1. **insertionSort**:
   - Функция `insertionSort` сортирует подмассив от `left` до `right` с использованием алгоритма сортировки вставками.

2. **merge**:
   - Функция `merge` объединяет два отсортированных подмассива. Она создает временные массивы `L` и `R` для левой и правой частей соответственно, а затем объединяет их в исходный массив.

3. **timSort**:
   - Функция `timSort` реализует основной алгоритм Tim Sort.
   - Сначала она сортирует отдельные подмассивы размером `RUN` (в данном случае 32) с использованием `insertionSort`.
   - Затем она объединяет эти отсортированные подмассивы, увеличивая размер слияния вдвое на каждой итерации, пока весь массив не будет отсортирован.