Используется для упорядочивания элементов в массиве целых чисел или строк. Он работает путем сортировки элементов по разрядам, начиная с младшего разряда и заканчивая старшим.

![[./_/radix.webp]]

**Полезен в следующих случаях:**

- Когда необходимо сортировать целые числа или строки с фиксированной длиной.
- Когда все элементы, которые нужно отсортировать, находятся в ограниченном диапазоне значений.
- Когда требуется устойчивая сортировка (сохранение относительного порядка элементов с одинаковым ключом).
- Когда необходимо сортировать большое количество элементов, и эффективность алгоритма имеет значение.

Radix sort может быть эффективным выбором для сортировки больших объемов данных, когда выполнены указанные выше условия. Он может быть быстрее других алгоритмов сортировки, таких как сортировка слиянием или быстрая сортировка, в таких сценариях.

**Как реализуется:**

1. Начните сортировку с младшего разряда (например, с единиц) и переходите к старшим разрядам.
2. Для каждого разряда используйте стабильную сортировку (например, сортировку подсчетом или сортировку вставками).
3. Повторяйте процесс сортировки для каждого разряда, пока не дойдете до старшего разряда.
4. После завершения сортировки по всем разрядам, массив будет упорядочен.

```ts
function countingSort(arr: number[], exp: number): number[] {
    let output = new Array(arr.length).fill(0);
    let count = new Array(10).fill(0);

    for (let i = 0; i < arr.length; i++) {
        count[(arr[i] / exp) % 10]++;
    }

    for (let i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    for (let i = arr.length - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    return output;
}

function radixSort(arr: number[]): number[] {
    let max = Math.max(...arr);
    let exp = 1;

    while (max / exp > 0) {
        arr = countingSort(arr, exp);
        exp *= 10;
    }

    return arr;
}

let arr = [170, 45, 75, 90, 802, 24, 2, 66];
console.log(radixSort(arr)); // Output: [2, 45, 66, 75, 90, 170, 24, 802]
```

---

## Временная сложность

Поскольку поразрядная сортировка представляет собой алгоритм сортировки, не основанный на сравнении, он имеет определенные преимущества при сортировке целых чисел.

Сортировка подсчетом имеет временную сложность, определяющую размер массива и максимальный элемент в массиве.`(n+k)``n``k`

При поразрядной сортировке мы используем сортировку подсчетом для каждой цифры максимального элемента массива. Назовем эти цифры `d`, поэтому временная сложность равна .`O(d * (n + k))`

|Худший|Средний|Лучший|
|---|---|---|
|O(d * (размер + макс))|O(d * (размер + макс))|O(d * (размер + макс))|

Таким образом, поразрядная сортировка имеет линейную временную сложность, которая лучше, чем O(nlog n) алгоритмов сравнительной сортировки.

Если мы возьмем очень большие числа или количество других оснований, таких как 32-битные и 64-битные числа, тогда они могут выполняться за линейное время, однако промежуточная сортировка занимает много места.

Это делает пространство поразрядной сортировки неэффективным. Именно по этой причине этот вид не используется в библиотеках программного обеспечения.

---

## Пространственная сложность

Пространственная сложность сортировки по основанию равна O(max). Чем больше диапазон элементов, тем больше сложность пространства.


---

## Источники
- #### [learnersbucket](https://learnersbucket.com/tutorials/algorithms/radix-sort-algorithm-in-javascript/)
