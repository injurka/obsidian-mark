**Trampoline Func** на самом деле является вспомогательной функцией, которая используется для реализации хвостовой рекурсии. При этом мы преобразуем все вложенные вызовы функций в последовательное количество вызовов функций, что, таким образом, помогает нам предотвратить состояние переполнения стека. 

Функция трамплина по сути включает рекурсивную функцию в цикл и, таким образом, далее вызывает эту рекурсивную функцию по частям, пока рекурсивные вызовы не перестанут присутствовать.

Однако функции-батуты являются лучшим примером функционального программирования на JavaScript. Эта функция предоставит нам результат для гораздо больших значений, который не был достигнут ранее упомянутыми методами (ни в обычной рекурсии, ни в хвостовой рекурсии).

Для реализации Trampoline следует выполнить следующие шаги:

1. **Определите базовый случай**: Это условие, которое останавливает рекурсию. Он должен быть простым и не включать в себя рекурсивных вызовов.
    
2. **Определите функцию, которая будет вызываться рекурсивно**: Это может быть любая функция, которая вызывает саму себя.
    
3. **Оберните рекурсивный вызов в функцию, которая будет возвращать другую функцию**: Вместо немедленного вызова функции, верните функцию, которая будет вызываться в следующей итерации.
    
4. **Создайте функцию-транспайлер**: Эта функция будет принимать функцию, которая должна быть обернута, и будет вызывать ее, пока она не вернет не функцию.
    
5. **Используйте функцию-транспайлер для вызова рекурсивной функции**: Вместо прямого вызова рекурсивной функции, используйте функцию-транспайлер.

Реализация через *BigInt*

```ts
type Thunk<T> = () => T | Thunk<T>;

function trampoline<T>(thunk: Thunk<T>): T {
  while (typeof thunk === 'function') {
    thunk = thunk();
  }
  return thunk;
}

function recursiveFunction(n: bigint, acc: bigint = BigInt(1)): Thunk<bigint> | bigint {
  if (n === 0n) {
    return acc; // Базовый случай
  } else {
    return () => recursiveFunction(BigInt(n) - 1n, BigInt(n) * acc); // Обернуть рекурсивный вызов в функцию
  }
}

const result = trampoline(() => recursiveFunction(BigInt(32768)));
console.log(result);
```

Реализация через *number*

```ts
type Thunk<T> = () => T | Thunk<T>;

function trampoline<T>(thunk: Thunk<T>): T {
  while (typeof thunk === 'function') {
    thunk = thunk();
  }
  return thunk;
}

function recursiveFunction(n: number, acc: number = 1): Thunk<number> | number {
  if (n === 0) {
    return acc; // Базовый случай
  } else {
    return () => recursiveFunction(n - 1, n * acc); // Обернуть рекурсивный вызов в функцию
  }
}

const result = trampoline(() => recursiveFunction(10));
console.log(result); // Выведет: 120
```