# Кратко

Вот как работает процесс защиты информации с помощью симметричного шифрования:

1. Отправитель (или получатель) выбирает алгоритм шифрования, генерирует ключ, информирует получателя (или отправителя, в зависимости от случая) о выбранном алгоритме и отправляет ключ по защищенному каналу связи.
2. Отправитель шифрует сообщение с помощью ключа и отправляет зашифрованное сообщение получателю.
3. Получатель получает зашифрованное сообщение и расшифровывает его с помощью того же ключа.

![[symmetric.png]]

## Типы криптографии с симметричным ключом

Существует два основных типа симметричных шифров: блочные и поточные.  
  
При блочном шифровании информация разбивается на блоки фиксированной длины (например, 64 или 128 бит). Затем эти блоки шифруются один за другим. Ключ применяется к каждому блоку в заданном порядке. Обычно это подразумевает несколько циклов смешивания и замещения. Блочный шифр является важным компонентом многих криптографических протоколов и широко используется для защиты данных, передаваемых по сети.  
  
Каждый исходный символ преобразуется в зашифрованный в потоковом шифре в зависимости от используемого ключа и его расположения в исходном тексте. Потоковые шифры имеют более высокую скорость шифрования, чем блочные, но они также имеют больше уязвимостей.

## Алгоритмы криптографии с симметричным ключом

Симметричных шифров довольно много. Вот некоторые из самых известных примеров.  
  
Блокировать шифры:

- DES (Стандарт шифрования данных) — это алгоритм шифрования, разработанный IBM и одобренный правительством США в 1977 году в качестве официального стандарта. Размер блока для DES составляет 64 бита. В настоящее время считается устаревшим и неиспользуемым.
- 3DES (Triple DES) был создан в 1978 году на основе алгоритма DES для устранения главного недостатка последнего: небольшой длины ключа (56 бит), который можно взломать методом грубой силы. Скорость 3DES в три раза ниже, чем у DES, но криптостойкость гораздо выше. Алгоритм 3DES основан на DES, поэтому для его реализации можно использовать программы, созданные для DES. Он все еще используется, особенно в индустрии электронных платежей, но постепенно заменяется более новыми алгоритмами.
- AES (расширенный стандарт шифрования). Этот алгоритм шифрования с размером блока 128 бит и ключом 128/192/256 бит был разработан в 2001 году как замена DES. В настоящее время он считается одним из самых эффективных и безопасных симметричных шифров и поэтому широко используется.
- IDEA (International DATA Encryption Algorithm) — алгоритм, разработанный в 1991 году швейцарской компанией Ascom. Он использует 128-битный ключ и 64-битный размер блока. Хотя сейчас он также считается устаревшим, он все еще используется.

  
**Потоковые шифры:**

- RC4 (Rivest cypher 4) — алгоритм, разработанный в 1987 году американской компанией RSA Security. Он стал популярен благодаря простоте аппаратной и программной реализации и высокой скорости алгоритма. В настоящее время он считается устаревшим и недостаточно безопасным, но все еще используется.
- SEAL (программно-оптимизированный алгоритм шифрования) был разработан в 1993 году компанией IBM. Алгоритм оптимизирован и рекомендован для 32-битных процессоров. Это один из самых быстрых шифров и считается очень безопасным.

### Сильные и слабые стороны криптографии с симметричным ключом

Наиболее заметным преимуществом симметричного шифрования является его простота, поскольку для шифрования и дешифрования используется один ключ. Таким образом, симметричные алгоритмы шифрования значительно быстрее асимметричных и требуют меньше вычислительной мощности.  
  
В то же время тот факт, что для шифрования и дешифрования используется один и тот же ключ, является основной уязвимостью систем симметричного шифрования. Необходимость передачи ключа другой стороне является уязвимостью системы безопасности, поскольку, если он попадет в чужие руки, информация будет расшифрована. Соответственно особое внимание следует уделить возможным способам перехвата ключа и повышения безопасности передачи.

---

# Подробно

## Классификация симметричных алгоритмов шифрования

будем считать, что симметричный алгоритм шифрования преобразует двоичные строки

> **Поточное шифрование**
> 
> Алгоритм обрабатывает один бит открытого текста и на выходе выдаёт один бит зашифрованного текста.

> **Блочное шифрование**
> 
> На вход принимается блок битов открытого текста, а выходом становится блок битов зашифрованного текста. Количество битов в обработке обычно является фиксированным числом и называется размером блока шифра.

![[./assets/symmetric_1.png]]

Однако такое деление весьма условно по нескольким причинам:

1. Поточные шифры можно рассматривать как блочные шифры с размером блока, равным единице.
2. Некоторые симметричные алгоритмы шифрования, которые обычно считаются поточными шифрами, фактически обрабатывают данные в байтах. Следовательно, они могут рассматриваться как блочные шифры с размером, равным 8 битам.
3. Блочные шифры часто используют в режимах работы, которые эффективно преобразуют их в поточные шифры. Например, блочный шифр может применяться для генерации управляющей гаммы: её используют для шифрования данных с помощью простого поточного шифрования.

---

## Поточные шифры

![[symmetric_2.png]]

Шифрование и расшифрование выполняются с помощью операции **«исключающее ИЛИ»**

Похож на шифр Вернама или схему одноразового блокнота, в котором для получения шифртекста открытый текст складывается с ключом по модулю два.

### Важные свойства ключа

1. Быть истинно случайным.
2. Совпадать по размеру с заданным открытым текстом.
3. Применяться только один раз.

В поточном шифре обычно использует ключ, который намного короче длины открытого текста

> **Гамма** - поток битов, который получается преобразованием короткого ключа, и накладывается на исходную последовательность при помощи определённой функции, например, «исключающего ИЛИ».

### Для расшифрования зашифрованного текста

Необходимо иметь:

- тем же коротким ключом
- тем же генератором гаммы

Шифр Вернама можно рассматривать как поточный шифр, в котором ключ генерируется истинно случайным образом.

### Особенности ключей поточных шифров

1. **Длина ключа**. Хотя в поточных шифрах используются ключи намного короче открытого текста, ключевой поток, полученный из этих ключей, должен быть такой же длины, что и открытый текст.
2. **Псевдослучайный характер ключей**. С одной стороны, это удешевляет и упрощает процесс генерации ключей, с другой**

> влияет на стойкость криптографической системы.

1. **Одноразовое использование ключей**. Гамма генерируется при помощи детерминированного процесса, то есть при подаче на вход генератора гаммы одного и того же ключа, на выходе получают точно такой же ключевой поток.

### Повторное использование ключа поточного шифра

различия между двумя зашифрованными текстами покажут различия между двумя соответствующими открытыми текстами

Этого можно избежать с помощью одного из следующих действий или их комбинаций

1. Использовать ключ поточного шифрования только один раз.
2. Никогда повторно не использовать одну и ту же часть управляющей гаммы.
3. Вместо того, чтобы использовать начальный ключ, можно получать уникальный ключ из начального ключа каждый раз, когда используется поточный шифр. Например, использовать временные данные при получении уникального ключа.
4. Использовать более сложную функцию для выработки шифртекста.

Управление ключами для поточных шифров**

> как и в любых симметричных криптографических примитивах**
> 
> происходит с помощью относительно коротких симметричных ключей

### Ошибки

> **Ошибки передачи**
> 
> это ошибки, которые происходят в канале связи. Однобитная ошибка передачи возникает, если в канале связи при передаче данных _0 становится 1 или 1 становится 0_.

> **Ошибки потери передачи**
> 
> возникают, когда _бит теряется в канале связи_. Однобитная потеря передачи происходит, если один бит данных теряется в канале связи, но предыдущие и последующие биты принимаются правильно.

> **Вычислительные ошибки**
> 
> это ошибки, которые происходят во время криптографического вычисления. Одноразрядная вычислительная ошибка возникает, если результат вычисления приводит к некорректному выходному биту.

Чаще всего встречаются ошибки передачи и потери.

### Примечательные свойства, позволяеющие использовать их во многих важных приложениях

#### 1. Отсутствие распространения ошибок

Поскольку поточные шифры оперируют с открытым текстом побитово

однобитовая ошибка передачи приведёт только к однобитовой ошибке в шифрованном тексте.

-> часто применяют в случаях, когда канал связи имеет низкое качество и ошибки неизбежны, например в системах мобильной связи.

#### 2. Скорость и простота реализации

Простой процесс шифрования позволяет

- легко реализовать поточные шифры
- высокая скорость обработки данных.

-> пригодны для применения в приложениях, например в сфере мобильной связи.

#### 3. Шифрование «на лету»

Побитовое шифрование означает, что большие фрагменты открытого текста не ожидают обработки долго. Следовательно, поточные шифры могут быть использованы в таких приложениях, как доверенные терминалы, где требуется немедленная защита отдельных нажатий клавиш.

#### 4. Эффективность реализации

Некоторые поточные шифры имеют чрезвычайно простую аппаратную реализацию, что позволяет достигать высоких скоростей шифрования.

### Недостатки

- Необходимо синхронизировать данные отправителя и получателя из-за побитовой обработки информации
- Результат однобитовой потери данных при передаче критичен
- Необходимо периодически пересинхронизировать ключевой поток

#### Синхронизация

1. **Повторный пересчёт ключевого потока с использованием нового ключа**.  
    Можно выполнять либо через фиксированные периоды времени, либо после отправки специальной последовательности, указывающей на повторную синхронизацию.
2. **Повторная непрерывная синхронизация**.  
    В этом случае ключевой поток зависит не только от ключа, но и от нескольких последних битов зашифрованного текста (рис. 3). Предположим, что обратная связь включает в себя m битов шифрованного текста. Если получатель временно потеряет синхронизацию, восстановление возможно при условии, что он затем получит m последовательных правильных битов зашифрованного текста. Такой тип поточных шифров называется **самосинхронизирующимся**. Отметим, что, обратная связь может привести к небольшой степени распространения ошибок.

![[./assets/symmetric_3.png]]

---

## Блочные шифры

![[symmetric_4.png]]_Модель блочного шифра_

Если размер блока слишком мал, злоумышленник может обнаружить блоки открытого текста, соответствующие некоторым зашифрованного текста.

Тогда можно провести атаку по словарю, сгенерировать пары открытого текста и шифрованного текста, полученные на одном и том же ключе.

Чем больше размер блока, тем сложнее осуществить подобную атаку.

Размер блока слишком велик -> блочный шифр перестаёт быть эффективным

Рекомендуют выбирать размер блока кратный `8, 16, 32 или 64`

### Часто встречающиеся свойства блочных шифров

#### 1. Многофункциональность

Блочные шифры используются не только для шифрования, но и в качестве составляющих других криптографических примитивов. Например, кодов аутентификации или хэш-функций.

#### 2. Совместимость

Стойкие блочные шифры — наиболее широко используемые алгоритмы шифрования. Их применяют во многих приложениях, что позволяет говорить об их совместимости.

#### 3. Адаптивность

Блочные шифры могут быть реализованы в разных режимах работы, о них мы поговорим далее. Благодаря адаптивности их используют для достижения различных целей защиты информации.

### Недостатки

#### 1. Распространение ошибок

Если блочный шифр построен по схеме, приведённой на рис. 4:

- ошибка передачи в один бит изменяет только один бит блока шифрованного текста.
- результат расшифрования этого ошибочного блока будет содержать примерно половину ошибочных битов.

#### 2. Необходимость дополнения

Блочные шифры оперируют фиксированными размерами блоков, но длина открытого текста может быть не кратна размеру блока.

-> последняя группа битов должна быть дополнена избыточной информацией до длины, кратной длине блока

В некоторых случаях есть вероятность, что это повлияет на безопасность схемы.

## Режимы работы блочных шифров

### Режим простой замены (электронной кодовой книги)

1. Последовательно беруться блоки текста
2. Каждый блок шифруется своим ключем
3. Получаем блоки шифрованного текста

После определения ключа шифрование проводится с помощью огромной кодовой книги. Сверяясь с ней, устанавливают соответствие между блоками открытого и зашифрованного текстов.

- редко используется для шифрования длинных открытых текстов, состоящих из большого количества блоков.
- Подвержен статистическим атакам
    - эффективны, если шифр регулярно используется для шифрования небольшого набора открытых текстов
    - большие размеры блоков желательны для защиты от атак по словарю
- использования одного и того же ключа -> одинаковые блоки открытого текста всегда преобразуются в одинаковые блоки шифрованного текста

### Режим сцепления блоков

- каждый блок зашифрованного текста отправляется получателю
- одновременно подаётся на вход операции шифрования для последующего блока открытого текста
- блоки зашифрованного текста вычислительно «соединены» вместе

#### Зашифрование

![[symmetric_5.png]]

- `E` - представляет алгоритм блочного шифрования
- два ряда ячеек — временные регистры длины блока
- регистры содержат промежуточные значения, необходимые для выполнения шифрования

1. Сначала заполняют верхний регистр  
    его содержимое называют **вектором инициализации**. Он должен быть известен отправителю и получателю, согласовать его они могут и по открытому каналу связи. Как правило, вектор инициализации выбирается случайным образом и используется однократно.
2. Берут первый блок открытого текста P_1 и содержимое верхнего регистра. К ним применяют операцию «исключающее ИЛИ» и результат помещают в нижний регистр.
3. Содержимое нижнего регистра и ключ подают на вход алгоритму шифрования, в результате чего получается первый блок шифрованного текста C_1. Он отправляется получателю и помещается в верхний регистр.
4. Вышеописанные операции повторяют до тех пор, пока не будет обработан последний блок открытого текста.

- использование одного и того же ключа в режиме сцепления блоков не приводит к появлению одинаковых блоков шифрованного текста

#### Расшифрование

![[./assets/symmetric_6.png]]

- Согласованный вектор инициализации помещают в верхний регистр.
- Первый блок зашифрованного текста C_1 расшифровывают на соответствующем ключе и помещают в нижний регистр.
- Содержимое обоих регистров подвергают операции «исключающее ИЛИ». Результат — P_1
- , первый блок открытого текста.
- Содержимое верхнего регистра заменяют на C_1 и повторяют операцию.

### Режим обратной связи

> альтернативный способ обеспечения зависимости от сообщений

#### Зашифрование

![[./assets/symmetric_7.png]]

- Вектор инициализации помещают в верхний регистр. Как и в режиме сцепления блоков, он должен быть известен отправителю и получателю.
- Содержимое верхнего регистра зашифровывают на соответствующем ключе и помещают в нижний регистр.
- Первый блок открытого текста P_1 и содержимое нижнего регистра подвергают операции «исключающее ИЛИ». Результат — C_1, первый блок шифрованного текста.
- C_1 отправляют получателю и помещают в верхний регистр. Указанные операции повторяются.

#### Расшифрования

> для расшифрования используется операция зашифрования

### Режим счётчика

> модификацию режима обратной связи

- отправитель и получатель должны иметь доступ к надёжному **счётчику**
    - вычисляет новое общее значение каждый раз при обмене блоком зашифрованного текста
    - не обязательно является секретным значением
    - должен быть

#### Зашифрование

![[symmetric_8.png]]

- Начальным значением в верхнем регистре является начальное значение счётчика. Это значение одинаково для отправителя и получателя и играет ту же роль, что и вектор инициализации.
- Значение счётчика зашифровывают с помощью ключа и помещают в нижний регистр.
- Операцию «исключающее ИЛИ» применяют к первому блоку открытого текста P_1 и к содержимому нижнего регистра. Результат — C_1, первый блок шифрованного текста.
- C_1 отправляют получателю и обновляют счётчик. Далее операции повторяются.
#### Расшифрования

> Расшифрование выполняется аналогично зашифрованию


