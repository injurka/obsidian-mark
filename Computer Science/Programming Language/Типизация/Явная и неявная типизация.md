Помимо разделения на _статическую/динамическую_ и _сильную/слабую_ типизацию, типизированные языки программирования разделяются по признакам _явной/неявной_ типизации.

---

## Явная типизация

Язык с _явной типизацией_ (explicit typing) предполагает, что указание принадлежности языковых элементов к конкретному типу возлагается на разработчика.

Явная типизация делает код более понятным (читабельным) и позволяет разработчикам, не знакомым с ним, быстрее включаться в процесс разработки, тем самым снижая время на модификацию программы.

Явная типизация, обязывая явно указывать типы, способствует развитию у разработчика навыков, необходимых для проектирования архитектуры программ.

В львиной доле языков с явной типизацией существует возможность указывать типы неявно.

Рассмотрим пример кода, демонстрирующего явную типизацию.

```ts
class Controller {
  public check(eggs: IEgg[]): boolean {
    const isValid: boolean = Validator.valid(eggs);

    return isValid;
  }
}
```

Класс `Controller` содержит метод `check`, который имеет один обязательный параметр `eggs` c типом `IEgg[ ]` и возвращающий тип `boolean`. Если бы не явно указанные типы параметров, то разработчикам пришлось бы только гадать, с чем именно им предстоит работать. Это же относится и к возвращаемому типу.

Результатом выполнения `Validator.valid( eggs )` внутри метода `check` является возвращаемое из функции значение типа `boolean`. Если бы при объявлении переменной `isValid` тип `boolean` не был бы указан явно, то было бы сильно сложнее догадаться, что же возвращает метод `valid`.

Разработчику, впервые увидевшему этот код, или тому, кто имел с ним дело очень давно, не составит труда разобраться, за что отвечает данный участок кода.

К языкам с явной типизацией относятся _С++_, _С#_ и многие другие.

---

## Неявная типизация

Язык с _неявной типизацией_ (implicit typing) при объявлении языковых элементов не требует от разработчика указания принадлежности к конкретному типу данных и возлагает определение типов на компилятор или интерпретатор.

За основу примера неявной типизации возьмем код из предыдущего примера, только лишим его признаков, характерных для явной типизации.

```ts
class Controller {
  check(eggs) {
    const isValid = Validator.valid(eggs);

    return isValid;
  }
}
```

Этот код стал занимать меньше места, что является одним из нескольких доводов, которые можно услышать в пользу языков с неявной типизацией. Но на самом деле это не так.

На практике считается хорошим тоном при объявлении языковых элементов уделять особое внимание именованию. Ведь именно от выбора названия будет зависеть то время, которое уйдет у программиста на понимание участка кода при отладке, рефакторинге или модернизации.

Те же рассуждения, в процессе которых происходит рождение более информативного названия, приводят к более детальному осмыслению кода.

```ts
class EggController {
  checkEgg(eggAll) {
    const isEggValid = EggValidator.qualityEggValid(eggAll);

    return isEggValid;
  }
}
```

Именно по этой причине правило именования распространяется и на языки с явной типизацией.

А тот факт, что неявная типизация позволяет реализовывать несложные алгоритмы с меньшими временными затратами, разбивается о возможность всех современных языков с явной типизацией указывать тип неявно, что достигается благодаря выводу типов.

```ts
class EggController {
  public checkEgg(eggAll: IEgg[]): boolean {
    const isEggValid: boolean = EggValidator.qualityEggValid(
      eggAll
    );

    return isEggValid;
  }
}
```

К языкам с неявной типизацией относятся такие языки, как _JavaScript_, _PHP_ и другие.

---
## Источники
- #### [scriptdev](https://scriptdev.ru/guide/006/)
- #### [habr](https://habr.com/ru/articles/161205)
