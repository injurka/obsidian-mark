Парадигма программирования — это способ концептуализации и организации кода, который определяет стиль, методы и правила написания программ. Различные парадигмы предлагают разные подходы к решению задач, что влияет на то, как программисты думают о проблемах и как они структурируют свои программы.

## Императивная парадигма

Императивная парадигма — это способ написания программ, где программа описывает последовательность команд, которые изменяют состояние программы. Программист явно указывает, что и как нужно делать.

### Процедурная парадигма

Процедурная парадигма основана на идее процедур или функций, которые выполняют определенные задачи. Программа состоит из набора процедур, которые вызывают друг друга.

Пример на Python:

```python
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

result = add(5, 3)
print(result)  # Output: 8
```

### Структурная парадигма

Структурная парадигма улучшает процедурную парадигму за счет использования структур управления, таких как циклы и условные операторы, что делает код более читаемым и организованным.

Пример на Python:

```python
def factorial(n):
    result = 1
    for i in range(1, n + 1):
        result *= i
    return result

print(factorial(5))  # Output: 120
```

### Аспектно-ориентированная парадигма

Аспектно-ориентированное программирование (AOP) позволяет разделять поперечные интересы (например, логирование, безопасность) от основного кода. Это упрощает добавление и изменение таких аспектов.

Пример на Python с использованием библиотеки `aspectlib`:

```python
import aspectlib

@aspectlib.Aspect
def log_call(*args, **kwargs):
    print(f"Calling with args: {args}, kwargs: {kwargs}")
    yield
    print("Called")

@log_call
def add(a, b):
    return a + b

add(5, 3)
```

### Объектно-ориентированная парадигма

Объектно-ориентированное программирование (ООП) основывается на концепции объектов, которые содержат данные (атрибуты) и поведение (методы). Объекты взаимодействуют друг с другом, обмениваясь сообщениями.

Пример на Python:

```python
class Calculator:
    def add(self, a, b):
        return a + b

calc = Calculator()
print(calc.add(5, 3))  # Output: 8
```

#### Агентно-ориентированная парадигма

Агентно-ориентированное программирование фокусируется на агентах — автономных сущностях, которые взаимодействуют друг с другом для выполнения задач.

Пример на Python с использованием библиотеки `agentspeak`:

```python
from agentspeak import Agent, Environment

class MyAgent(Agent):
    def on_init(self):
        self.beliefs.add("hello", "world")

    def on_hello(self, term):
        print(f"Hello, {term}!")

env = Environment()
agent = MyAgent("agent1")
env.add_agent(agent)
env.run()
```

#### Компонентно-ориентированная парадигма

Компонентно-ориентированное программирование фокусируется на создании и использовании компонентов, которые могут быть легко заменены или обновлены.

Пример на C#:

```csharp
public interface ICalculator
{
    int Add(int a, int b);
}

public class SimpleCalculator : ICalculator
{
    public int Add(int a, int b)
    {
        return a + b;
    }
}

class Program
{
    static void Main()
    {
        ICalculator calculator = new SimpleCalculator();
        Console.WriteLine(calculator.Add(5, 3));  // Output: 8
    }
}
```

#### Прототипно-ориентированная парадигма

Прототипно-ориентированное программирование основывается на идее прототипов — объектов, которые служат шаблонами для создания других объектов.

Пример на JavaScript:

```javascript
const proto = {
    add: function(a, b) {
        return a + b;
    }
};

const calculator = Object.create(proto);
console.log(calculator.add(5, 3));  // Output: 8
```

### Обобщённое программирование

Обобщённое программирование позволяет писать код, который может работать с различными типами данных без указания конкретного типа.

Пример на C++:

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(5, 3) << std::endl;  // Output: 8
    std::cout << add(5.5, 3.3) << std::endl;  // Output: 8.8
    return 0;
}
```

## Декларативная парадигма

Декларативная парадигма — это способ написания программ, где программа описывает, что должно быть сделано, а не как это сделать. Программист указывает желаемый результат, а не последовательность действий для его достижения.

### Чистота языка

Чистота языка означает, что язык не допускает побочных эффектов и является детерминированным.

#### Чистота функции

Чистая функция — это функция, которая не имеет побочных эффектов и всегда возвращает один и тот же результат для одних и тех же входных данных.

Пример на Haskell:

```haskell
add :: Int -> Int -> Int
add a b = a + b

main = print (add 5 3)  -- Output: 8
```

### Функциональная парадигма

Функциональная парадигма основывается на использовании чистых функций и неизменяемых данных.

#### В терминах рефал-машины

РЕФАЛ (РЕкурсивных Функций АЛгоритмический) — это функциональный язык, который использует рефал-машину для выполнения программ.

Пример на РЕФАЛ:

```refal
$ENTRY Go { = <Add 5 3>; }
Add { a b = <Plus a b>; }
Plus { a b = a + b; }
```

#### Аппликативная парадигма

Аппликативная парадигма основывается на применении функций к аргументам.

Пример на Haskell:

```haskell
add :: Int -> Int -> Int
add a b = a + b

main = print (add 5 3)  -- Output: 8
```

#### Комбинаторная парадигма

Комбинаторная парадигма основывается на использовании комбинаторов — функций высшего порядка, которые манипулируют другими функциями.

Пример на Haskell:

```haskell
compose :: (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)

addOne :: Int -> Int
addOne x = x + 1

double :: Int -> Int
double x = x * 2

main = print (compose double addOne 5)  -- Output: 12
```

#### Бесточечная парадигма

Бесточечная парадигма основывается на использовании функций без явного указания аргументов.

Пример на Haskell:

```haskell
add :: Int -> Int -> Int
add = (+)

main = print (add 5 3)  -- Output: 8
```

### Логическая парадигма

Логическая парадигма основывается на формальной логике и позволяет описывать факты и правила, а затем запрашивать решения.

#### Ограничениями

Ограниченное программирование позволяет описывать задачи в терминах ограничений и затем решать их.

Пример на Prolog:

```prolog
add(A, B, Sum) :- Sum is A + B.

?- add(5, 3, Result).
% Result = 8.
```

## Конкатенативная парадигма

Конкатенативная парадигма основывается на конкатенации строк для создания новых значений.

Пример на Python:

```python
result = "Hello, " + "World!"
print(result)  # Output: Hello, World!
```

## Векторная парадигма

Векторная парадигма основывается на манипулировании векторами и матрицами.

Пример на Python с использованием NumPy:

```python
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

result = a + b
print(result)  # Output: [5 7 9]
```

## Метапрограммирование

Метапрограммирование — это программирование, которое манипулирует другими программами или самим собой.

### Языково-ориентированная парадигма

Языково-ориентированное программирование позволяет создавать новые языки или расширять существующие.

#### Предметно-ориентированная парадигма

Предметно-ориентированное программирование (DSL) позволяет создавать языки, специализированные для конкретной области.

Пример на Python с использованием библиотеки `textX`:

```python
from textx import metamodel_from_str

grammar = """
Model: commands*=Command;
Command: Add | Subtract;
Add: 'add' a=INT b=INT;
Subtract: 'subtract' a=INT b=INT;
"""

metamodel = metamodel_from_str(grammar)
model = metamodel.model_from_str("add 5 3")

for command in model.commands:
    if command.__class__.__name__ == "Add":
        print(command.a + command.b)  # Output: 8
```

#### Пользователями

Пользовательское метапрограммирование позволяет пользователям создавать и изменять программы.

Пример на JavaScript с использованием `eval`:

```javascript
const code = "console.log('Hello, World!');";
eval(code);  // Output: Hello, World!
```

### Автоматизация процесса программирования

Автоматизация процесса программирования позволяет автоматически генерировать код на основе определенных правил.

Пример на Python с использованием библиотеки `jinja2`:

```python
from jinja2 import Template

template = Template("""
def add(a, b):
    return a + b

result = add({{ a }}, {{ b }})
print(result)
""")

rendered = template.render(a=5, b=3)
exec(rendered)  # Output: 8
```

## Рефлексивность

Рефлексивность — это способность программы анализировать и модифицировать свою структуру и поведение во время выполнения.

### Гомоиконичность

Гомоиконичность — это свойство языка, при котором код и данные представлены в одном и том же формате.

Пример на Lisp:

```lisp
(defun add (a b)
  (+ a b))

(print (add 5 3))  ; Output: 8
```

