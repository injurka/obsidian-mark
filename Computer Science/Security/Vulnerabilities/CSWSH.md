> Cross-Site WebSocket Hijacking

Когда мы произносим вместе слова «cookie» и «аутентификация» или «токен», то помним, что услышав подобную комбинацию слов, полезно подумать про защиту от [CSRF](https://owasp.org/www-community/attacks/csrf). Для WebSocket существует аналогичная уязвимость, называемая _Cross‑Site WebSocket Hijacking_ или же _CSWSH_.

Чтобы можно было точнее понять суть ее работы, сперва вспомним следующие понятия:

- `Site` - совокупность eTLD+1 и схемы*
- `Origin` - совокупность схемы, хоста порта

![[origin-scheme.png]]

> [!INFO]
> Исключение составляют запросы со схемами `ws://` и `wss://`. На самом деле, это и позволило в примерах выше отправлять cookie в запросах на установку соединения. В таком случае следующие запросы будут считаться Same-Site:
> 
> - `wss://` соединение, устанавливаемое с `https:// страницы`
>
> - `ws://` соединение, устанавливаемое с `http:// страницы`
>
> The request's URL when establishing a WebSockets connection has scheme “http” or “https”, rather than “ws” or “wss”. FETCH maps schemes when constructing the request. This mapping allows same‑site cookies to be sent with WebSockets.


## Как воспроизвести!?

У нас есть легитимный сервис `chat.com`, который использует WebSocket. Пользователь заходит на сайт, проходит аутентификацию, у него в браузере появляется cookie с неким токеном на домене `chat.com`. Теперь в дело вступает злоумышленник, который создает свой зловредный ресурс `malicious.com` и заманивает туда пользователя (например, отправив ссылку с предложением посмотреть на милых котят). Пользователь в том же сеансе браузера открывает `malicious.com`, после чего на странице выполняется скрипт злоумышленника, который «от лица пользователя» отправляет запрос на установку WebSocket‑соединения с `malicious.com` на `chat.com`, в котором _якобы_ будет передана существующая cookie, поскольку она уже есть в браузере для домена `chat.com`. Соединение тогда будет установлено, и злоумышленник _якобы_ сможет в рамках него получить какие‑то данные с сервера или же наоборот отправить их.

Объясняется это, как правило, тем, что существующий в браузерах защитный механизм [Same-Origin Policy (SOP](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)), который в том числе не позволяет на большинстве современных сайтов просто так проэксплуатировать CSRF вышеописанным образом, не работает для WebSocket. И это является правдой, так уж исторически сложилось.

Подвох в том, что на самом деле воспроизвести уязвимость несколько сложнее. Для реальной эксплуатации требуется следующее одновременное сочетание условий:

1. Наличие атрибута `SameSite=None` у cookie или обход (_bypass_) SameSite
    
2. Отсутствие проверки Origin или защиты от CSRF
    

Только имея оба этих условия выполненными вы сможете воспроизвести уязвимость, поскольку политика SameSite не даст просто так браузеру отправить любую cookie с другого домена.

Задавать `SameSite` в None для cookie с токеном и раньше было (простите, за каламбур) нонсенсом: в таком случае cookie отправлялась бы в запросах с любых других Sites. Также наличию таких cookie не способствует [применяемая в Chrome политика](https://www.chromium.org/updates/same-site/) по трактовке пустого значения `SameSite` как Lax по умолчанию (правда, пока [не все браузеры](https://caniuse.com/mdn-http_headers_set-cookie_samesite_lax_default) реализовали подобное). В ближайшем будущем крышку в гроб подобного подхода должно вбить планируемое у того же Chrome изменение по [прекращению поддержки third‑party cookies](https://developers.google.com/privacy-sandbox/3pcd), то есть как раз cookie с подобным значением атрибута `SameSite`.  

Тем не менее, хоть уязвимость так легко не воспроизводится, защита от нее все равно нужна. Доказывает это, например, прошлогодняя [история с раскруткой CSWSH до RCE в Gitpod](https://snyk.io/blog/gitpod-remote-code-execution-vulnerability-websockets/). SameSite исследователи обошли как раз тем, что все сервисы находились на поддоменах gitpod.io:

Один из самых простых способов защиты здесь — это проверка Origin. Как минимум проверяя Origin входящих запросов по белому списку разрешенных, по аналогии с тем, как мы делаем для CORS, можно снизить риск эксплуатации подобной уязвимости в вашем сервисе. Таким образом вы сможете продолжать обрабатывать запросы с разрешенных Origin, а запросы с тех, которые не являются разрешенными, сразу «отбивать» с ошибкой.