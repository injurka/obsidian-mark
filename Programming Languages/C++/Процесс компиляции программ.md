---
dg-publish: true
---
Процесс компиляции исходных текстов на языке Си в исполняемый файл происходит в три основных этапа: **препроцессинг**, **компиляция** и **компоновка**.

![[./_/compile-process.png]]

## Препроцессинг

Препроцессинг — это первый этап компиляции, на котором исходный текст программы обрабатывается текстовым препроцессором. Основные операции, выполняемые на этом этапе, включают:

- **Замена комментариев пустыми строками**: Все комментарии в исходном коде удаляются или заменяются пустыми строками.
- **Текстовое включение файлов**: Директива `#include` используется для включения содержимого других файлов в исходный код. Например, заголовочные файлы (`.h`) могут содержать объявления функций и переменных, которые используются в основном коде.
- **Макроподстановки**: Директива `#define` используется для определения макросов, которые затем заменяются соответствующими значениями в коде.
- **Обработка директив условной компиляции**: Директивы `#if`, `#ifdef`, `#elif`, `#else`, `#endif` позволяют компилировать или исключать определенные части кода в зависимости от условий.

## Компиляция

Компиляция — это второй этап, на котором исходный код преобразуется в объектный код. Процесс компиляции включает в себя несколько подэтапов, каждый из которых выполняет свою специфическую задачу.

### 1. Лексический анализ

> **Вход**: Исходный код (текст программы).
> **Выход**: Последовательность лексем (токены).

**Лексический анализ** — это первый подэтап компиляции, на котором последовательность символов исходного файла преобразуется в последовательность лексем (токены). Лексемы — это базовые элементы языка, такие как:

- **Ключевые слова**: Например, `int`, `if`, `while`, `return`.
- **Идентификаторы**: Имена переменных, функций, структур и т.д.
- **Операторы**: Например, `+`, `-`, `*`, `/`, `=`, `==`.
- **Литералы**: Числовые константы, строки, символы.
- **Разделители**: Точки с запятой, запятые, скобки и т.д.

Лексический анализатор (сканер) читает исходный код символ за символом и группирует их в лексемы. Этот этап также удаляет пробелы, комментарии и другие незначащие символы.

### 2. Синтаксический анализ

> **Вход**: Последовательность лексем.
> **Выход**: Дерево разбора (синтаксическое дерево).

**Синтаксический анализ** — это второй подэтап, на котором последовательность лексем преобразуется в дерево разбора (синтаксическое дерево). Дерево разбора отражает структуру программы в соответствии с правилами синтаксиса языка.

- **Грамматика языка**: Синтаксический анализатор использует грамматику языка (набор правил) для построения дерева разбора.
- **Дерево разбора**: Каждый узел дерева представляет собой конструкцию языка (например, оператор, выражение, блок кода). Листья дерева — это лексемы, полученные на этапе лексического анализа.

Если синтаксический анализатор обнаруживает ошибку в синтаксисе, он выдает сообщение об ошибке и прекращает работу.

### 3. Семантический анализ

> **Вход**: Дерево разбора.
> **Выход**: Дерево разбора с дополнительной семантической информацией.

**Семантический анализ** — это третий подэтап, на котором дерево разбора обрабатывается с целью установления его семантики (смысла). Основные задачи семантического анализа включают:

- **Привязка идентификаторов**: Каждый идентификатор (имя переменной, функции и т.д.) связывается с его декларацией.
- **Проверка типов**: Проверка совместимости типов в выражениях и присваиваниях.
- **Проверка соответствия**: Проверка соответствия объявлений и определений функций и переменных.
- **Обработка контекстных зависимостей**: Например, проверка доступа к переменным в разных областях видимости.

Если семантический анализатор обнаруживает ошибки (например, несовместимость типов или неопределенные идентификаторы), он выдает соответствующие сообщения об ошибках.

### 4. Оптимизация

> **Вход**: Дерево разбора с семантической информацией.
> **Выход**: Оптимизированное дерево разбора.

**Оптимизация** — это четвертый подэтап, на котором выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла. Основные техники оптимизации включают:

- **Удаление мертвого кода**: Удаление кода, который никогда не будет выполнен.
- **Встраивание функций**: Замена вызовов функций их телами для уменьшения накладных расходов на вызов.
- **Оптимизация циклов**: Уменьшение количества итераций цикла, вынесение инвариантных выражений за пределы цикла.
- **Упрощение выражений**: Замена сложных выражений на более простые эквиваленты.
- **Распределение регистров**: Оптимальное использование регистров процессора для хранения переменных.

Оптимизация может значительно улучшить производительность программы, но также может увеличить время компиляции.

### 5. Генерация кода

> **Вход**: Оптимизированное дерево разбора.
> **Выход**: Объектный код.

**Генерация кода** — это заключительный подэтап компиляции, на котором из промежуточного представления порождается объектный код. Объектный код представляет собой программу на языке машинных кодов, которая может быть выполнена на целевой платформе.

- **Промежуточное представление**: Перед генерацией кода компилятор может использовать промежуточное представление (например, трехадресный код), которое упрощает процесс генерации.
- **Машинные инструкции**: Объектный код состоит из последовательности машинных инструкций, которые выполняются процессором.
- **Символьная информация**: Объектный код может сохранять некоторую символьную информацию (например, имена переменных, функции), которая используется на этапе компоновки и отладки.

**Результатом компиляции** является объектный код. Объектный код содержит машинные инструкции, но может сохранять некоторую символьную информацию, необходимую для дальнейшей компоновки.

## Компоновка (Линковка)

Компоновка, также известная как связывание или линковка, — это заключительный этап сборки программы. На этом этапе отдельные объектные файлы проекта соединяются в единый исполняемый файл. Основные задачи компоновки включают:

- **Связывание объектных файлов**: Все объектные файлы, созданные на этапе компиляции, объединяются в один исполняемый файл.
- **Разрешение внешних ссылок**: Если в программе используются функции или переменные, определенные в других модулях, компоновщик должен найти их определения и связать с соответствующими объявлениями.
- **Генерация исполняемого файла**: В результате компоновки создается исполняемый файл, который можно запустить на целевой платформе.

**Ошибки связывания**: Если функция или переменная была объявлена, но не определена, ошибка обнаружится только на этапе компоновки. Например, если функция `foo()` была объявлена в одном файле, но не определена ни в одном из объектных файлов, компоновщик выдаст ошибку "undefined reference to `foo()`".

## Заключение

Процесс сборки программы на языке Си включает в себя три основных этапа: препроцессинг, компиляция и компоновка. Каждый этап выполняет свои задачи, чтобы в итоге получить исполняемый файл, который можно запустить на целевой платформе.